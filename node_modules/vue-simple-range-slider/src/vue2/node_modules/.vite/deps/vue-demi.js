import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// src/vue2/node_modules/vue/dist/vue.runtime.common.dev.js
var require_vue_runtime_common_dev = __commonJS({
  "src/vue2/node_modules/vue/dist/vue.runtime.common.dev.js"(exports, module) {
    "use strict";
    var emptyObject2 = Object.freeze({});
    var isArray3 = Array.isArray;
    function isUndef3(v) {
      return v === void 0 || v === null;
    }
    function isDef2(v) {
      return v !== void 0 && v !== null;
    }
    function isTrue2(v) {
      return v === true;
    }
    function isFalse2(v) {
      return v === false;
    }
    function isPrimitive3(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
    }
    function isFunction3(value) {
      return typeof value === "function";
    }
    function isObject3(obj) {
      return obj !== null && typeof obj === "object";
    }
    var _toString2 = Object.prototype.toString;
    function toRawType2(value) {
      return _toString2.call(value).slice(8, -1);
    }
    function isPlainObject3(obj) {
      return _toString2.call(obj) === "[object Object]";
    }
    function isRegExp2(v) {
      return _toString2.call(v) === "[object RegExp]";
    }
    function isValidArrayIndex3(val) {
      const n = parseFloat(String(val));
      return n >= 0 && Math.floor(n) === n && isFinite(val);
    }
    function isPromise2(val) {
      return isDef2(val) && typeof val.then === "function" && typeof val.catch === "function";
    }
    function toString3(val) {
      return val == null ? "" : Array.isArray(val) || isPlainObject3(val) && val.toString === _toString2 ? JSON.stringify(val, null, 2) : String(val);
    }
    function toNumber2(val) {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    }
    function makeMap2(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => map[val.toLowerCase()] : (val) => map[val];
    }
    var isBuiltInTag2 = makeMap2("slot,component", true);
    var isReservedAttribute2 = makeMap2("key,ref,slot,slot-scope,is");
    function remove$22(arr, item) {
      if (arr.length) {
        const index3 = arr.indexOf(item);
        if (index3 > -1) {
          return arr.splice(index3, 1);
        }
      }
    }
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function hasOwn3(obj, key) {
      return hasOwnProperty2.call(obj, key);
    }
    function cached2(fn) {
      const cache = /* @__PURE__ */ Object.create(null);
      return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    }
    var camelizeRE2 = /-(\w)/g;
    var camelize2 = cached2((str) => {
      return str.replace(camelizeRE2, (_, c) => c ? c.toUpperCase() : "");
    });
    var capitalize2 = cached2((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var hyphenateRE2 = /\B([A-Z])/g;
    var hyphenate2 = cached2((str) => {
      return str.replace(hyphenateRE2, "-$1").toLowerCase();
    });
    function polyfillBind2(fn, ctx) {
      function boundFn(a) {
        const l = arguments.length;
        return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
      }
      boundFn._length = fn.length;
      return boundFn;
    }
    function nativeBind2(fn, ctx) {
      return fn.bind(ctx);
    }
    var bind2 = Function.prototype.bind ? nativeBind2 : polyfillBind2;
    function toArray2(list, start) {
      start = start || 0;
      let i = list.length - start;
      const ret = new Array(i);
      while (i--) {
        ret[i] = list[i + start];
      }
      return ret;
    }
    function extend2(to, _from) {
      for (const key in _from) {
        to[key] = _from[key];
      }
      return to;
    }
    function toObject2(arr) {
      const res = {};
      for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
          extend2(res, arr[i]);
        }
      }
      return res;
    }
    function noop2(a, b, c) {
    }
    var no2 = (a, b, c) => false;
    var identity2 = (_) => _;
    function looseEqual2(a, b) {
      if (a === b)
        return true;
      const isObjectA = isObject3(a);
      const isObjectB = isObject3(b);
      if (isObjectA && isObjectB) {
        try {
          const isArrayA = Array.isArray(a);
          const isArrayB = Array.isArray(b);
          if (isArrayA && isArrayB) {
            return a.length === b.length && a.every((e, i) => {
              return looseEqual2(e, b[i]);
            });
          } else if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
          } else if (!isArrayA && !isArrayB) {
            const keysA = Object.keys(a);
            const keysB = Object.keys(b);
            return keysA.length === keysB.length && keysA.every((key) => {
              return looseEqual2(a[key], b[key]);
            });
          } else {
            return false;
          }
        } catch (e) {
          return false;
        }
      } else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
      } else {
        return false;
      }
    }
    function looseIndexOf2(arr, val) {
      for (let i = 0; i < arr.length; i++) {
        if (looseEqual2(arr[i], val))
          return i;
      }
      return -1;
    }
    function once2(fn) {
      let called = false;
      return function() {
        if (!called) {
          called = true;
          fn.apply(this, arguments);
        }
      };
    }
    function hasChanged2(x, y) {
      if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
      } else {
        return x === x || y === y;
      }
    }
    var SSR_ATTR2 = "data-server-rendered";
    var ASSET_TYPES2 = ["component", "directive", "filter"];
    var LIFECYCLE_HOOKS2 = [
      "beforeCreate",
      "created",
      "beforeMount",
      "mounted",
      "beforeUpdate",
      "updated",
      "beforeDestroy",
      "destroyed",
      "activated",
      "deactivated",
      "errorCaptured",
      "serverPrefetch",
      "renderTracked",
      "renderTriggered"
    ];
    var config2 = {
      optionMergeStrategies: /* @__PURE__ */ Object.create(null),
      silent: false,
      productionTip: true,
      devtools: true,
      performance: false,
      errorHandler: null,
      warnHandler: null,
      ignoredElements: [],
      keyCodes: /* @__PURE__ */ Object.create(null),
      isReservedTag: no2,
      isReservedAttr: no2,
      isUnknownElement: no2,
      getTagNamespace: noop2,
      parsePlatformTagName: identity2,
      mustUseProp: no2,
      async: true,
      _lifecycleHooks: LIFECYCLE_HOOKS2
    };
    var unicodeRegExp2 = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
    function isReserved2(str) {
      const c = (str + "").charCodeAt(0);
      return c === 36 || c === 95;
    }
    function def3(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }
    var bailRE2 = new RegExp(`[^${unicodeRegExp2.source}.$_\\d]`);
    function parsePath2(path) {
      if (bailRE2.test(path)) {
        return;
      }
      const segments = path.split(".");
      return function(obj) {
        for (let i = 0; i < segments.length; i++) {
          if (!obj)
            return;
          obj = obj[segments[i]];
        }
        return obj;
      };
    }
    var hasProto2 = "__proto__" in {};
    var inBrowser2 = typeof window !== "undefined";
    var UA2 = inBrowser2 && window.navigator.userAgent.toLowerCase();
    var isIE2 = UA2 && /msie|trident/.test(UA2);
    var isIE92 = UA2 && UA2.indexOf("msie 9.0") > 0;
    var isEdge2 = UA2 && UA2.indexOf("edge/") > 0;
    UA2 && UA2.indexOf("android") > 0;
    var isIOS2 = UA2 && /iphone|ipad|ipod|ios/.test(UA2);
    UA2 && /chrome\/\d+/.test(UA2) && !isEdge2;
    UA2 && /phantomjs/.test(UA2);
    var isFF2 = UA2 && UA2.match(/firefox\/(\d+)/);
    var nativeWatch2 = {}.watch;
    var supportsPassive2 = false;
    if (inBrowser2) {
      try {
        const opts = {};
        Object.defineProperty(opts, "passive", {
          get() {
            supportsPassive2 = true;
          }
        });
        window.addEventListener("test-passive", null, opts);
      } catch (e) {
      }
    }
    var _isServer2;
    var isServerRendering2 = () => {
      if (_isServer2 === void 0) {
        if (!inBrowser2 && typeof global !== "undefined") {
          _isServer2 = global["process"] && global["process"].env.VUE_ENV === "server";
        } else {
          _isServer2 = false;
        }
      }
      return _isServer2;
    };
    var devtools2 = inBrowser2 && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    function isNative3(Ctor) {
      return typeof Ctor === "function" && /native code/.test(Ctor.toString());
    }
    var hasSymbol3 = typeof Symbol !== "undefined" && isNative3(Symbol) && typeof Reflect !== "undefined" && isNative3(Reflect.ownKeys);
    var _Set2;
    if (typeof Set !== "undefined" && isNative3(Set)) {
      _Set2 = Set;
    } else {
      _Set2 = class Set {
        constructor() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
        has(key) {
          return this.set[key] === true;
        }
        add(key) {
          this.set[key] = true;
        }
        clear() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
      };
    }
    var currentInstance3 = null;
    function getCurrentInstance2() {
      return currentInstance3 && { proxy: currentInstance3 };
    }
    function setCurrentInstance3(vm = null) {
      if (!vm)
        currentInstance3 && currentInstance3._scope.off();
      currentInstance3 = vm;
      vm && vm._scope.on();
    }
    var VNode2 = class {
      constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = void 0;
        this.context = context;
        this.fnContext = void 0;
        this.fnOptions = void 0;
        this.fnScopeId = void 0;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = void 0;
        this.parent = void 0;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = void 0;
        this.isAsyncPlaceholder = false;
      }
      get child() {
        return this.componentInstance;
      }
    };
    var createEmptyVNode2 = (text = "") => {
      const node = new VNode2();
      node.text = text;
      node.isComment = true;
      return node;
    };
    function createTextVNode2(val) {
      return new VNode2(void 0, void 0, void 0, String(val));
    }
    function cloneVNode2(vnode) {
      const cloned = new VNode2(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
      cloned.ns = vnode.ns;
      cloned.isStatic = vnode.isStatic;
      cloned.key = vnode.key;
      cloned.isComment = vnode.isComment;
      cloned.fnContext = vnode.fnContext;
      cloned.fnOptions = vnode.fnOptions;
      cloned.fnScopeId = vnode.fnScopeId;
      cloned.asyncMeta = vnode.asyncMeta;
      cloned.isCloned = true;
      return cloned;
    }
    var uid$22 = 0;
    var Dep2 = class {
      constructor() {
        this.id = uid$22++;
        this.subs = [];
      }
      addSub(sub) {
        this.subs.push(sub);
      }
      removeSub(sub) {
        remove$22(this.subs, sub);
      }
      depend(info) {
        if (Dep2.target) {
          Dep2.target.addDep(this);
          if (info && Dep2.target.onTrack) {
            Dep2.target.onTrack(Object.assign({ effect: Dep2.target }, info));
          }
        }
      }
      notify(info) {
        const subs = this.subs.slice();
        if (!config2.async) {
          subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
          if (info) {
            const sub = subs[i];
            sub.onTrigger && sub.onTrigger(Object.assign({ effect: subs[i] }, info));
          }
          subs[i].update();
        }
      }
    };
    Dep2.target = null;
    var targetStack2 = [];
    function pushTarget2(target3) {
      targetStack2.push(target3);
      Dep2.target = target3;
    }
    function popTarget2() {
      targetStack2.pop();
      Dep2.target = targetStack2[targetStack2.length - 1];
    }
    var arrayProto2 = Array.prototype;
    var arrayMethods2 = Object.create(arrayProto2);
    var methodsToPatch2 = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    methodsToPatch2.forEach(function(method) {
      const original = arrayProto2[method];
      def3(arrayMethods2, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
          case "push":
          case "unshift":
            inserted = args;
            break;
          case "splice":
            inserted = args.slice(2);
            break;
        }
        if (inserted)
          ob.observeArray(inserted);
        {
          ob.dep.notify({
            type: "array mutation",
            target: this,
            key: method
          });
        }
        return result;
      });
    });
    var arrayKeys2 = Object.getOwnPropertyNames(arrayMethods2);
    var NO_INIITIAL_VALUE2 = {};
    var shouldObserve2 = true;
    function toggleObserving2(value) {
      shouldObserve2 = value;
    }
    var mockDep2 = {
      notify: noop2,
      depend: noop2,
      addSub: noop2,
      removeSub: noop2
    };
    var Observer2 = class {
      constructor(value, shallow = false, mock = false) {
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        this.dep = mock ? mockDep2 : new Dep2();
        this.vmCount = 0;
        def3(value, "__ob__", this);
        if (isArray3(value)) {
          if (!mock) {
            if (hasProto2) {
              value.__proto__ = arrayMethods2;
            } else {
              for (let i = 0, l = arrayKeys2.length; i < l; i++) {
                const key = arrayKeys2[i];
                def3(value, key, arrayMethods2[key]);
              }
            }
          }
          if (!shallow) {
            this.observeArray(value);
          }
        } else {
          const keys = Object.keys(value);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            defineReactive2(value, key, NO_INIITIAL_VALUE2, void 0, shallow, mock);
          }
        }
      }
      observeArray(value) {
        for (let i = 0, l = value.length; i < l; i++) {
          observe3(value[i], false, this.mock);
        }
      }
    };
    function observe3(value, shallow, ssrMockReactivity) {
      if (!isObject3(value) || isRef3(value) || value instanceof VNode2) {
        return;
      }
      let ob;
      if (hasOwn3(value, "__ob__") && value.__ob__ instanceof Observer2) {
        ob = value.__ob__;
      } else if (shouldObserve2 && (ssrMockReactivity || !isServerRendering2()) && (isArray3(value) || isPlainObject3(value)) && Object.isExtensible(value) && !value.__v_skip) {
        ob = new Observer2(value, shallow, ssrMockReactivity);
      }
      return ob;
    }
    function defineReactive2(obj, key, val, customSetter, shallow, mock) {
      const dep = new Dep2();
      const property = Object.getOwnPropertyDescriptor(obj, key);
      if (property && property.configurable === false) {
        return;
      }
      const getter = property && property.get;
      const setter = property && property.set;
      if ((!getter || setter) && (val === NO_INIITIAL_VALUE2 || arguments.length === 2)) {
        val = obj[key];
      }
      let childOb = !shallow && observe3(val, false, mock);
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          const value = getter ? getter.call(obj) : val;
          if (Dep2.target) {
            {
              dep.depend({
                target: obj,
                type: "get",
                key
              });
            }
            if (childOb) {
              childOb.dep.depend();
              if (isArray3(value)) {
                dependArray2(value);
              }
            }
          }
          return isRef3(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
          const value = getter ? getter.call(obj) : val;
          if (!hasChanged2(value, newVal)) {
            return;
          }
          if (customSetter) {
            customSetter();
          }
          if (setter) {
            setter.call(obj, newVal);
          } else if (getter) {
            return;
          } else if (isRef3(value) && !isRef3(newVal)) {
            value.value = newVal;
            return;
          } else {
            val = newVal;
          }
          childOb = !shallow && observe3(newVal, false, mock);
          {
            dep.notify({
              type: "set",
              target: obj,
              key,
              newValue: newVal,
              oldValue: value
            });
          }
        }
      });
      return dep;
    }
    function set3(target3, key, val) {
      if (isUndef3(target3) || isPrimitive3(target3)) {
        warn3(`Cannot set reactive property on undefined, null, or primitive value: ${target3}`);
      }
      if (isReadonly3(target3)) {
        warn3(`Set operation on key "${key}" failed: target is readonly.`);
        return;
      }
      const ob = target3.__ob__;
      if (isArray3(target3) && isValidArrayIndex3(key)) {
        target3.length = Math.max(target3.length, key);
        target3.splice(key, 1, val);
        if (ob && !ob.shallow && ob.mock) {
          observe3(val, false, true);
        }
        return val;
      }
      if (key in target3 && !(key in Object.prototype)) {
        target3[key] = val;
        return val;
      }
      if (target3._isVue || ob && ob.vmCount) {
        warn3("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
        return val;
      }
      if (!ob) {
        target3[key] = val;
        return val;
      }
      defineReactive2(ob.value, key, val, void 0, ob.shallow, ob.mock);
      {
        ob.dep.notify({
          type: "add",
          target: target3,
          key,
          newValue: val,
          oldValue: void 0
        });
      }
      return val;
    }
    function del3(target3, key) {
      if (isUndef3(target3) || isPrimitive3(target3)) {
        warn3(`Cannot delete reactive property on undefined, null, or primitive value: ${target3}`);
      }
      if (isArray3(target3) && isValidArrayIndex3(key)) {
        target3.splice(key, 1);
        return;
      }
      const ob = target3.__ob__;
      if (target3._isVue || ob && ob.vmCount) {
        warn3("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
        return;
      }
      if (isReadonly3(target3)) {
        warn3(`Delete operation on key "${key}" failed: target is readonly.`);
        return;
      }
      if (!hasOwn3(target3, key)) {
        return;
      }
      delete target3[key];
      if (!ob) {
        return;
      }
      {
        ob.dep.notify({
          type: "delete",
          target: target3,
          key
        });
      }
    }
    function dependArray2(value) {
      for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
          e.__ob__.dep.depend();
        }
        if (isArray3(e)) {
          dependArray2(e);
        }
      }
    }
    function reactive2(target3) {
      makeReactive2(target3, false);
      return target3;
    }
    function shallowReactive3(target3) {
      makeReactive2(target3, true);
      def3(target3, "__v_isShallow", true);
      return target3;
    }
    function makeReactive2(target3, shallow) {
      if (!isReadonly3(target3)) {
        {
          if (isArray3(target3)) {
            warn3(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);
          }
          const existingOb = target3 && target3.__ob__;
          if (existingOb && existingOb.shallow !== shallow) {
            warn3(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);
          }
        }
        const ob = observe3(target3, shallow, isServerRendering2());
        if (!ob) {
          if (target3 == null || isPrimitive3(target3)) {
            warn3(`value cannot be made reactive: ${String(target3)}`);
          }
          if (isCollectionType2(target3)) {
            warn3(`Vue 2 does not support reactive collection types such as Map or Set.`);
          }
        }
      }
    }
    function isReactive2(value) {
      if (isReadonly3(value)) {
        return isReactive2(value["__v_raw"]);
      }
      return !!(value && value.__ob__);
    }
    function isShallow(value) {
      return !!(value && value.__v_isShallow);
    }
    function isReadonly3(value) {
      return !!(value && value.__v_isReadonly);
    }
    function isProxy(value) {
      return isReactive2(value) || isReadonly3(value);
    }
    function toRaw2(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw2(raw) : observed;
    }
    function markRaw2(value) {
      def3(value, "__v_skip", true);
      return value;
    }
    function isCollectionType2(value) {
      const type = toRawType2(value);
      return type === "Map" || type === "WeakMap" || type === "Set" || type === "WeakSet";
    }
    var RefFlag = `__v_isRef`;
    function isRef3(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref$1(value) {
      return createRef2(value, false);
    }
    function shallowRef2(value) {
      return createRef2(value, true);
    }
    function createRef2(rawValue, shallow) {
      if (isRef3(rawValue)) {
        return rawValue;
      }
      const ref4 = {};
      def3(ref4, RefFlag, true);
      def3(ref4, "__v_isShallow", shallow);
      def3(ref4, "dep", defineReactive2(ref4, "value", rawValue, null, shallow, isServerRendering2()));
      return ref4;
    }
    function triggerRef2(ref4) {
      if (!ref4.dep) {
        warn3(`received object is not a triggerable ref.`);
      }
      {
        ref4.dep && ref4.dep.notify({
          type: "set",
          target: ref4,
          key: "value"
        });
      }
    }
    function unref2(ref4) {
      return isRef3(ref4) ? ref4.value : ref4;
    }
    function proxyRefs2(objectWithRefs) {
      if (isReactive2(objectWithRefs)) {
        return objectWithRefs;
      }
      const proxy4 = {};
      const keys = Object.keys(objectWithRefs);
      for (let i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap2(proxy4, objectWithRefs, keys[i]);
      }
      return proxy4;
    }
    function proxyWithRefUnwrap2(target3, source, key) {
      Object.defineProperty(target3, key, {
        enumerable: true,
        configurable: true,
        get: () => {
          const val = source[key];
          if (isRef3(val)) {
            return val.value;
          } else {
            const ob = val && val.__ob__;
            if (ob)
              ob.dep.depend();
            return val;
          }
        },
        set: (value) => {
          const oldValue = source[key];
          if (isRef3(oldValue) && !isRef3(value)) {
            oldValue.value = value;
          } else {
            source[key] = value;
          }
        }
      });
    }
    function customRef2(factory) {
      const dep = new Dep2();
      const { get: get2, set: set4 } = factory(() => {
        {
          dep.depend({
            target: ref4,
            type: "get",
            key: "value"
          });
        }
      }, () => {
        {
          dep.notify({
            target: ref4,
            type: "set",
            key: "value"
          });
        }
      });
      const ref4 = {
        get value() {
          return get2();
        },
        set value(newVal) {
          set4(newVal);
        }
      };
      def3(ref4, RefFlag, true);
      return ref4;
    }
    function toRefs2(object) {
      if (!isReactive2(object)) {
        warn3(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = isArray3(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = toRef2(object, key);
      }
      return ret;
    }
    function toRef2(object, key, defaultValue) {
      const val = object[key];
      if (isRef3(val)) {
        return val;
      }
      const ref4 = {
        get value() {
          const val2 = object[key];
          return val2 === void 0 ? defaultValue : val2;
        },
        set value(newVal) {
          object[key] = newVal;
        }
      };
      def3(ref4, RefFlag, true);
      return ref4;
    }
    var rawToReadonlyFlag = `__v_rawToReadonly`;
    var rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;
    function readonly2(target3) {
      return createReadonly(target3, false);
    }
    function createReadonly(target3, shallow) {
      if (!isPlainObject3(target3)) {
        {
          if (isArray3(target3)) {
            warn3(`Vue 2 does not support readonly arrays.`);
          } else if (isCollectionType2(target3)) {
            warn3(`Vue 2 does not support readonly collection types such as Map or Set.`);
          } else {
            warn3(`value cannot be made readonly: ${typeof target3}`);
          }
        }
        return target3;
      }
      if (isReadonly3(target3)) {
        return target3;
      }
      const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
      const existingProxy = target3[existingFlag];
      if (existingProxy) {
        return existingProxy;
      }
      const proxy4 = Object.create(Object.getPrototypeOf(target3));
      def3(target3, existingFlag, proxy4);
      def3(proxy4, "__v_isReadonly", true);
      def3(proxy4, "__v_raw", target3);
      if (isRef3(target3)) {
        def3(proxy4, RefFlag, true);
      }
      if (shallow || isShallow(target3)) {
        def3(proxy4, "__v_isShallow", true);
      }
      const keys = Object.keys(target3);
      for (let i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy4, target3, keys[i], shallow);
      }
      return proxy4;
    }
    function defineReadonlyProperty(proxy4, target3, key, shallow) {
      Object.defineProperty(proxy4, key, {
        enumerable: true,
        configurable: true,
        get() {
          const val = target3[key];
          return shallow || !isPlainObject3(val) ? val : readonly2(val);
        },
        set() {
          warn3(`Set operation on key "${key}" failed: target is readonly.`);
        }
      });
    }
    function shallowReadonly2(target3) {
      return createReadonly(target3, true);
    }
    function computed2(getterOrOptions, debugOptions) {
      let getter;
      let setter;
      const onlyGetter = isFunction3(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
          warn3("Write operation failed: computed value is readonly");
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const watcher = isServerRendering2() ? null : new Watcher2(currentInstance3, getter, noop2, { lazy: true });
      if (watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
      }
      const ref4 = {
        effect: watcher,
        get value() {
          if (watcher) {
            if (watcher.dirty) {
              watcher.evaluate();
            }
            if (Dep2.target) {
              if (Dep2.target.onTrack) {
                Dep2.target.onTrack({
                  effect: Dep2.target,
                  target: ref4,
                  type: "get",
                  key: "value"
                });
              }
              watcher.depend();
            }
            return watcher.value;
          } else {
            return getter();
          }
        },
        set value(newVal) {
          setter(newVal);
        }
      };
      def3(ref4, RefFlag, true);
      def3(ref4, "__v_isReadonly", onlyGetter);
      return ref4;
    }
    var WATCHER2 = `watcher`;
    var WATCHER_CB2 = `${WATCHER2} callback`;
    var WATCHER_GETTER2 = `${WATCHER2} getter`;
    var WATCHER_CLEANUP2 = `${WATCHER2} cleanup`;
    function watchEffect2(effect, options) {
      return doWatch(effect, null, options);
    }
    function watchPostEffect2(effect, options) {
      return doWatch(effect, null, Object.assign(Object.assign({}, options), { flush: "post" }));
    }
    function watchSyncEffect2(effect, options) {
      return doWatch(effect, null, Object.assign(Object.assign({}, options), { flush: "sync" }));
    }
    var INITIAL_WATCHER_VALUE = {};
    function watch2(source, cb, options) {
      if (typeof cb !== "function") {
        warn3(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush = "pre", onTrack, onTrigger } = emptyObject2) {
      if (!cb) {
        if (immediate !== void 0) {
          warn3(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        }
        if (deep !== void 0) {
          warn3(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
        }
      }
      const warnInvalidSource = (s) => {
        warn3(`Invalid watch source: ${s}. A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
      };
      const instance = currentInstance3;
      const call = (fn, type, args = null) => invokeWithErrorHandling2(fn, null, args, instance, type);
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef3(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive2(source)) {
        getter = () => {
          source.__ob__.dep.depend();
          return source;
        };
        deep = true;
      } else if (isArray3(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive2(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef3(s)) {
            return s.value;
          } else if (isReactive2(s)) {
            return traverse3(s);
          } else if (isFunction3(s)) {
            return call(s, WATCHER_GETTER2);
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (isFunction3(source)) {
        if (cb) {
          getter = () => call(source, WATCHER_GETTER2);
        } else {
          getter = () => {
            if (instance && instance._isDestroyed) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return call(source, WATCHER2, [onCleanup]);
          };
        }
      } else {
        getter = noop2;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse3(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = watcher.onStop = () => {
          call(fn, WATCHER_CLEANUP2);
        };
      };
      if (isServerRendering2()) {
        onCleanup = noop2;
        if (!cb) {
          getter();
        } else if (immediate) {
          call(cb, WATCHER_CB2, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        return noop2;
      }
      const watcher = new Watcher2(currentInstance3, getter, noop2, {
        lazy: true
      });
      watcher.noRecurse = !cb;
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
      watcher.run = () => {
        if (!watcher.active && !(flush === "pre" && instance && instance._isBeingDestroyed)) {
          return;
        }
        if (cb) {
          const newValue = watcher.get();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged2(v, oldValue[i])) : hasChanged2(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            call(cb, WATCHER_CB2, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          watcher.get();
        }
      };
      if (flush === "sync") {
        watcher.update = watcher.run;
      } else if (flush === "post") {
        watcher.post = true;
        watcher.update = () => queueWatcher2(watcher);
      } else {
        watcher.update = () => {
          if (instance && instance === currentInstance3 && !instance._isMounted) {
            const buffer = instance._preWatchers || (instance._preWatchers = []);
            if (buffer.indexOf(watcher) < 0)
              buffer.push(watcher);
          } else {
            queueWatcher2(watcher);
          }
        };
      }
      {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
      }
      if (cb) {
        if (immediate) {
          watcher.run();
        } else {
          oldValue = watcher.get();
        }
      } else if (flush === "post" && instance) {
        instance.$once("hook:mounted", () => watcher.get());
      } else {
        watcher.get();
      }
      return () => {
        watcher.teardown();
      };
    }
    var activeEffectScope3;
    var EffectScope3 = class {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope3) {
          this.parent = activeEffectScope3;
          this.index = (activeEffectScope3.scopes || (activeEffectScope3.scopes = [])).push(this) - 1;
        }
      }
      run(fn) {
        if (this.active) {
          const currentEffectScope = activeEffectScope3;
          try {
            activeEffectScope3 = this;
            return fn();
          } finally {
            activeEffectScope3 = currentEffectScope;
          }
        } else {
          warn3(`cannot run an inactive effect scope.`);
        }
      }
      on() {
        activeEffectScope3 = this;
      }
      off() {
        activeEffectScope3 = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].teardown();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    };
    function effectScope2(detached) {
      return new EffectScope3(detached);
    }
    function recordEffectScope3(effect, scope = activeEffectScope3) {
      if (scope && scope.active) {
        scope.effects.push(effect);
      }
    }
    function getCurrentScope2() {
      return activeEffectScope3;
    }
    function onScopeDispose2(fn) {
      if (activeEffectScope3) {
        activeEffectScope3.cleanups.push(fn);
      } else {
        warn3(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
      }
    }
    function provide2(key, value) {
      if (!currentInstance3) {
        {
          warn3(`provide() can only be used inside setup().`);
        }
      } else {
        resolveProvided2(currentInstance3)[key] = value;
      }
    }
    function resolveProvided2(vm) {
      const existing = vm._provided;
      const parentProvides = vm.$parent && vm.$parent._provided;
      if (parentProvides === existing) {
        return vm._provided = Object.create(parentProvides);
      } else {
        return existing;
      }
    }
    function inject2(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance3;
      if (instance) {
        const provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction3(defaultValue) ? defaultValue.call(instance) : defaultValue;
        } else {
          warn3(`injection "${String(key)}" not found.`);
        }
      } else {
        warn3(`inject() can only be used inside setup() or functional components.`);
      }
    }
    var normalizeEvent2 = cached2((name) => {
      const passive = name.charAt(0) === "&";
      name = passive ? name.slice(1) : name;
      const once3 = name.charAt(0) === "~";
      name = once3 ? name.slice(1) : name;
      const capture = name.charAt(0) === "!";
      name = capture ? name.slice(1) : name;
      return {
        name,
        once: once3,
        capture,
        passive
      };
    });
    function createFnInvoker2(fns, vm) {
      function invoker() {
        const fns2 = invoker.fns;
        if (isArray3(fns2)) {
          const cloned = fns2.slice();
          for (let i = 0; i < cloned.length; i++) {
            invokeWithErrorHandling2(cloned[i], null, arguments, vm, `v-on handler`);
          }
        } else {
          return invokeWithErrorHandling2(fns2, null, arguments, vm, `v-on handler`);
        }
      }
      invoker.fns = fns;
      return invoker;
    }
    function updateListeners2(on, oldOn, add3, remove3, createOnceHandler3, vm) {
      let name, cur, old, event;
      for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent2(name);
        if (isUndef3(cur)) {
          warn3(`Invalid handler for event "${event.name}": got ` + String(cur), vm);
        } else if (isUndef3(old)) {
          if (isUndef3(cur.fns)) {
            cur = on[name] = createFnInvoker2(cur, vm);
          }
          if (isTrue2(event.once)) {
            cur = on[name] = createOnceHandler3(event.name, cur, event.capture);
          }
          add3(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
          old.fns = cur;
          on[name] = old;
        }
      }
      for (name in oldOn) {
        if (isUndef3(on[name])) {
          event = normalizeEvent2(name);
          remove3(event.name, oldOn[name], event.capture);
        }
      }
    }
    function mergeVNodeHook2(def4, hookKey, hook) {
      if (def4 instanceof VNode2) {
        def4 = def4.data.hook || (def4.data.hook = {});
      }
      let invoker;
      const oldHook = def4[hookKey];
      function wrappedHook() {
        hook.apply(this, arguments);
        remove$22(invoker.fns, wrappedHook);
      }
      if (isUndef3(oldHook)) {
        invoker = createFnInvoker2([wrappedHook]);
      } else {
        if (isDef2(oldHook.fns) && isTrue2(oldHook.merged)) {
          invoker = oldHook;
          invoker.fns.push(wrappedHook);
        } else {
          invoker = createFnInvoker2([oldHook, wrappedHook]);
        }
      }
      invoker.merged = true;
      def4[hookKey] = invoker;
    }
    function extractPropsFromVNodeData2(data, Ctor, tag) {
      const propOptions = Ctor.options.props;
      if (isUndef3(propOptions)) {
        return;
      }
      const res = {};
      const { attrs: attrs3, props: props3 } = data;
      if (isDef2(attrs3) || isDef2(props3)) {
        for (const key in propOptions) {
          const altKey = hyphenate2(key);
          {
            const keyInLowerCase = key.toLowerCase();
            if (key !== keyInLowerCase && attrs3 && hasOwn3(attrs3, keyInLowerCase)) {
              tip2(`Prop "${keyInLowerCase}" is passed to component ${formatComponentName2(tag || Ctor)}, but the declared prop name is "${key}". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "${altKey}" instead of "${key}".`);
            }
          }
          checkProp2(res, props3, key, altKey, true) || checkProp2(res, attrs3, key, altKey, false);
        }
      }
      return res;
    }
    function checkProp2(res, hash, key, altKey, preserve) {
      if (isDef2(hash)) {
        if (hasOwn3(hash, key)) {
          res[key] = hash[key];
          if (!preserve) {
            delete hash[key];
          }
          return true;
        } else if (hasOwn3(hash, altKey)) {
          res[key] = hash[altKey];
          if (!preserve) {
            delete hash[altKey];
          }
          return true;
        }
      }
      return false;
    }
    function simpleNormalizeChildren2(children) {
      for (let i = 0; i < children.length; i++) {
        if (isArray3(children[i])) {
          return Array.prototype.concat.apply([], children);
        }
      }
      return children;
    }
    function normalizeChildren2(children) {
      return isPrimitive3(children) ? [createTextVNode2(children)] : isArray3(children) ? normalizeArrayChildren2(children) : void 0;
    }
    function isTextNode2(node) {
      return isDef2(node) && isDef2(node.text) && isFalse2(node.isComment);
    }
    function normalizeArrayChildren2(children, nestedIndex) {
      const res = [];
      let i, c, lastIndex, last;
      for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef3(c) || typeof c === "boolean")
          continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        if (isArray3(c)) {
          if (c.length > 0) {
            c = normalizeArrayChildren2(c, `${nestedIndex || ""}_${i}`);
            if (isTextNode2(c[0]) && isTextNode2(last)) {
              res[lastIndex] = createTextVNode2(last.text + c[0].text);
              c.shift();
            }
            res.push.apply(res, c);
          }
        } else if (isPrimitive3(c)) {
          if (isTextNode2(last)) {
            res[lastIndex] = createTextVNode2(last.text + c);
          } else if (c !== "") {
            res.push(createTextVNode2(c));
          }
        } else {
          if (isTextNode2(c) && isTextNode2(last)) {
            res[lastIndex] = createTextVNode2(last.text + c.text);
          } else {
            if (isTrue2(children._isVList) && isDef2(c.tag) && isUndef3(c.key) && isDef2(nestedIndex)) {
              c.key = `__vlist${nestedIndex}_${i}__`;
            }
            res.push(c);
          }
        }
      }
      return res;
    }
    function renderList2(val, render) {
      let ret = null, i, l, keys, key;
      if (isArray3(val) || typeof val === "string") {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
          ret[i] = render(val[i], i);
        }
      } else if (typeof val === "number") {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
          ret[i] = render(i + 1, i);
        }
      } else if (isObject3(val)) {
        if (hasSymbol3 && val[Symbol.iterator]) {
          ret = [];
          const iterator = val[Symbol.iterator]();
          let result = iterator.next();
          while (!result.done) {
            ret.push(render(result.value, ret.length));
            result = iterator.next();
          }
        } else {
          keys = Object.keys(val);
          ret = new Array(keys.length);
          for (i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            ret[i] = render(val[key], key, i);
          }
        }
      }
      if (!isDef2(ret)) {
        ret = [];
      }
      ret._isVList = true;
      return ret;
    }
    function renderSlot2(name, fallbackRender, props3, bindObject) {
      const scopedSlotFn = this.$scopedSlots[name];
      let nodes;
      if (scopedSlotFn) {
        props3 = props3 || {};
        if (bindObject) {
          if (!isObject3(bindObject)) {
            warn3("slot v-bind without argument expects an Object", this);
          }
          props3 = extend2(extend2({}, bindObject), props3);
        }
        nodes = scopedSlotFn(props3) || (isFunction3(fallbackRender) ? fallbackRender() : fallbackRender);
      } else {
        nodes = this.$slots[name] || (isFunction3(fallbackRender) ? fallbackRender() : fallbackRender);
      }
      const target3 = props3 && props3.slot;
      if (target3) {
        return this.$createElement("template", { slot: target3 }, nodes);
      } else {
        return nodes;
      }
    }
    function resolveFilter2(id) {
      return resolveAsset2(this.$options, "filters", id, true) || identity2;
    }
    function isKeyNotMatch2(expect, actual) {
      if (isArray3(expect)) {
        return expect.indexOf(actual) === -1;
      } else {
        return expect !== actual;
      }
    }
    function checkKeyCodes2(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
      const mappedKeyCode = config2.keyCodes[key] || builtInKeyCode;
      if (builtInKeyName && eventKeyName && !config2.keyCodes[key]) {
        return isKeyNotMatch2(builtInKeyName, eventKeyName);
      } else if (mappedKeyCode) {
        return isKeyNotMatch2(mappedKeyCode, eventKeyCode);
      } else if (eventKeyName) {
        return hyphenate2(eventKeyName) !== key;
      }
      return eventKeyCode === void 0;
    }
    function bindObjectProps2(data, tag, value, asProp, isSync) {
      if (value) {
        if (!isObject3(value)) {
          warn3("v-bind without argument expects an Object or Array value", this);
        } else {
          if (isArray3(value)) {
            value = toObject2(value);
          }
          let hash;
          for (const key in value) {
            if (key === "class" || key === "style" || isReservedAttribute2(key)) {
              hash = data;
            } else {
              const type = data.attrs && data.attrs.type;
              hash = asProp || config2.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
            }
            const camelizedKey = camelize2(key);
            const hyphenatedKey = hyphenate2(key);
            if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
              hash[key] = value[key];
              if (isSync) {
                const on = data.on || (data.on = {});
                on[`update:${key}`] = function($event) {
                  value[key] = $event;
                };
              }
            }
          }
        }
      }
      return data;
    }
    function renderStatic2(index3, isInFor) {
      const cached3 = this._staticTrees || (this._staticTrees = []);
      let tree = cached3[index3];
      if (tree && !isInFor) {
        return tree;
      }
      tree = cached3[index3] = this.$options.staticRenderFns[index3].call(this._renderProxy, this._c, this);
      markStatic2(tree, `__static__${index3}`, false);
      return tree;
    }
    function markOnce2(tree, index3, key) {
      markStatic2(tree, `__once__${index3}${key ? `_${key}` : ``}`, true);
      return tree;
    }
    function markStatic2(tree, key, isOnce) {
      if (isArray3(tree)) {
        for (let i = 0; i < tree.length; i++) {
          if (tree[i] && typeof tree[i] !== "string") {
            markStaticNode2(tree[i], `${key}_${i}`, isOnce);
          }
        }
      } else {
        markStaticNode2(tree, key, isOnce);
      }
    }
    function markStaticNode2(node, key, isOnce) {
      node.isStatic = true;
      node.key = key;
      node.isOnce = isOnce;
    }
    function bindObjectListeners2(data, value) {
      if (value) {
        if (!isPlainObject3(value)) {
          warn3("v-on without argument expects an Object value", this);
        } else {
          const on = data.on = data.on ? extend2({}, data.on) : {};
          for (const key in value) {
            const existing = on[key];
            const ours = value[key];
            on[key] = existing ? [].concat(existing, ours) : ours;
          }
        }
      }
      return data;
    }
    function resolveScopedSlots3(fns, res, hasDynamicKeys, contentHashKey) {
      res = res || { $stable: !hasDynamicKeys };
      for (let i = 0; i < fns.length; i++) {
        const slot = fns[i];
        if (isArray3(slot)) {
          resolveScopedSlots3(slot, res, hasDynamicKeys);
        } else if (slot) {
          if (slot.proxy) {
            slot.fn.proxy = true;
          }
          res[slot.key] = slot.fn;
        }
      }
      if (contentHashKey) {
        res.$key = contentHashKey;
      }
      return res;
    }
    function bindDynamicKeys2(baseObj, values) {
      for (let i = 0; i < values.length; i += 2) {
        const key = values[i];
        if (typeof key === "string" && key) {
          baseObj[values[i]] = values[i + 1];
        } else if (key !== "" && key !== null) {
          warn3(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);
        }
      }
      return baseObj;
    }
    function prependModifier2(value, symbol) {
      return typeof value === "string" ? symbol + value : value;
    }
    function installRenderHelpers2(target3) {
      target3._o = markOnce2;
      target3._n = toNumber2;
      target3._s = toString3;
      target3._l = renderList2;
      target3._t = renderSlot2;
      target3._q = looseEqual2;
      target3._i = looseIndexOf2;
      target3._m = renderStatic2;
      target3._f = resolveFilter2;
      target3._k = checkKeyCodes2;
      target3._b = bindObjectProps2;
      target3._v = createTextVNode2;
      target3._e = createEmptyVNode2;
      target3._u = resolveScopedSlots3;
      target3._g = bindObjectListeners2;
      target3._d = bindDynamicKeys2;
      target3._p = prependModifier2;
    }
    function resolveSlots3(children, context) {
      if (!children || !children.length) {
        return {};
      }
      const slots = {};
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        const data = child.data;
        if (data && data.attrs && data.attrs.slot) {
          delete data.attrs.slot;
        }
        if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
          const name = data.slot;
          const slot = slots[name] || (slots[name] = []);
          if (child.tag === "template") {
            slot.push.apply(slot, child.children || []);
          } else {
            slot.push(child);
          }
        } else {
          (slots.default || (slots.default = [])).push(child);
        }
      }
      for (const name in slots) {
        if (slots[name].every(isWhitespace2)) {
          delete slots[name];
        }
      }
      return slots;
    }
    function isWhitespace2(node) {
      return node.isComment && !node.asyncFactory || node.text === " ";
    }
    function isAsyncPlaceholder2(node) {
      return node.isComment && node.asyncFactory;
    }
    function normalizeScopedSlots2(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
      let res;
      const hasNormalSlots = Object.keys(normalSlots).length > 0;
      const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
      const key = scopedSlots && scopedSlots.$key;
      if (!scopedSlots) {
        res = {};
      } else if (scopedSlots._normalized) {
        return scopedSlots._normalized;
      } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject2 && key === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {
        return prevScopedSlots;
      } else {
        res = {};
        for (const key2 in scopedSlots) {
          if (scopedSlots[key2] && key2[0] !== "$") {
            res[key2] = normalizeScopedSlot2(ownerVm, normalSlots, key2, scopedSlots[key2]);
          }
        }
      }
      for (const key2 in normalSlots) {
        if (!(key2 in res)) {
          res[key2] = proxyNormalSlot2(normalSlots, key2);
        }
      }
      if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
      }
      def3(res, "$stable", isStable);
      def3(res, "$key", key);
      def3(res, "$hasNormal", hasNormalSlots);
      return res;
    }
    function normalizeScopedSlot2(vm, normalSlots, key, fn) {
      const normalized = function() {
        const cur = currentInstance3;
        setCurrentInstance3(vm);
        let res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === "object" && !isArray3(res) ? [res] : normalizeChildren2(res);
        const vnode = res && res[0];
        setCurrentInstance3(cur);
        return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder2(vnode)) ? void 0 : res;
      };
      if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
          get: normalized,
          enumerable: true,
          configurable: true
        });
      }
      return normalized;
    }
    function proxyNormalSlot2(slots, key) {
      return () => slots[key];
    }
    function initSetup2(vm) {
      const options = vm.$options;
      const setup = options.setup;
      if (setup) {
        const ctx = vm._setupContext = createSetupContext2(vm);
        setCurrentInstance3(vm);
        pushTarget2();
        const setupResult = invokeWithErrorHandling2(setup, null, [vm._props || shallowReactive3({}), ctx], vm, `setup`);
        popTarget2();
        setCurrentInstance3();
        if (isFunction3(setupResult)) {
          options.render = setupResult;
        } else if (isObject3(setupResult)) {
          if (setupResult instanceof VNode2) {
            warn3(`setup() should not return VNodes directly - return a render function instead.`);
          }
          vm._setupState = setupResult;
          if (!setupResult.__sfc) {
            for (const key in setupResult) {
              if (!isReserved2(key)) {
                proxyWithRefUnwrap2(vm, setupResult, key);
              } else {
                warn3(`Avoid using variables that start with _ or $ in setup().`);
              }
            }
          } else {
            const proxy4 = vm._setupProxy = {};
            for (const key in setupResult) {
              if (key !== "__sfc") {
                proxyWithRefUnwrap2(proxy4, setupResult, key);
              }
            }
          }
        } else if (setupResult !== void 0) {
          warn3(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
        }
      }
    }
    function createSetupContext2(vm) {
      let exposeCalled = false;
      return {
        get attrs() {
          return initAttrsProxy(vm);
        },
        get slots() {
          return initSlotsProxy2(vm);
        },
        emit: bind2(vm.$emit, vm),
        expose(exposed) {
          {
            if (exposeCalled) {
              warn3(`expose() should be called only once per setup().`, vm);
            }
            exposeCalled = true;
          }
          if (exposed) {
            Object.keys(exposed).forEach((key) => proxyWithRefUnwrap2(vm, exposed, key));
          }
        }
      };
    }
    function initAttrsProxy(vm) {
      if (!vm._attrsProxy) {
        const proxy4 = vm._attrsProxy = {};
        def3(proxy4, "_v_attr_proxy", true);
        syncSetupAttrs(proxy4, vm.$attrs, emptyObject2, vm);
      }
      return vm._attrsProxy;
    }
    function syncSetupAttrs(to, from, prev, instance) {
      let changed = false;
      for (const key in from) {
        if (!(key in to)) {
          changed = true;
          defineProxyAttr2(to, key, instance);
        } else if (from[key] !== prev[key]) {
          changed = true;
        }
      }
      for (const key in to) {
        if (!(key in from)) {
          changed = true;
          delete to[key];
        }
      }
      return changed;
    }
    function defineProxyAttr2(proxy4, key, instance) {
      Object.defineProperty(proxy4, key, {
        enumerable: true,
        configurable: true,
        get() {
          return instance.$attrs[key];
        }
      });
    }
    function initSlotsProxy2(vm) {
      if (!vm._slotsProxy) {
        syncSetupSlots2(vm._slotsProxy = {}, vm.$scopedSlots);
      }
      return vm._slotsProxy;
    }
    function syncSetupSlots2(to, from) {
      for (const key in from) {
        to[key] = from[key];
      }
      for (const key in to) {
        if (!(key in from)) {
          delete to[key];
        }
      }
    }
    function useSlots2() {
      return getContext2().slots;
    }
    function useAttrs2() {
      return getContext2().attrs;
    }
    function getContext2() {
      if (!currentInstance3) {
        warn3(`useContext() called without active instance.`);
      }
      const vm = currentInstance3;
      return vm._setupContext || (vm._setupContext = createSetupContext2(vm));
    }
    function mergeDefaults(raw, defaults) {
      const props3 = isArray3(raw) ? raw.reduce((normalized, p) => (normalized[p] = {}, normalized), {}) : raw;
      for (const key in defaults) {
        const opt = props3[key];
        if (opt) {
          if (isArray3(opt) || isFunction3(opt)) {
            props3[key] = { type: opt, default: defaults[key] };
          } else {
            opt.default = defaults[key];
          }
        } else if (opt === null) {
          props3[key] = { default: defaults[key] };
        } else {
          warn3(`props default key "${key}" has no corresponding declaration.`);
        }
      }
      return props3;
    }
    function initRender2(vm) {
      vm._vnode = null;
      vm._staticTrees = null;
      const options = vm.$options;
      const parentVnode = vm.$vnode = options._parentVnode;
      const renderContext = parentVnode && parentVnode.context;
      vm.$slots = resolveSlots3(options._renderChildren, renderContext);
      vm.$scopedSlots = parentVnode ? normalizeScopedSlots2(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject2;
      vm._c = (a, b, c, d) => createElement$12(vm, a, b, c, d, false);
      vm.$createElement = (a, b, c, d) => createElement$12(vm, a, b, c, d, true);
      const parentData = parentVnode && parentVnode.data;
      {
        defineReactive2(vm, "$attrs", parentData && parentData.attrs || emptyObject2, () => {
          !isUpdatingChildComponent2 && warn3(`$attrs is readonly.`, vm);
        }, true);
        defineReactive2(vm, "$listeners", options._parentListeners || emptyObject2, () => {
          !isUpdatingChildComponent2 && warn3(`$listeners is readonly.`, vm);
        }, true);
      }
    }
    var currentRenderingInstance2 = null;
    function renderMixin2(Vue4) {
      installRenderHelpers2(Vue4.prototype);
      Vue4.prototype.$nextTick = function(fn) {
        return nextTick4(fn, this);
      };
      Vue4.prototype._render = function() {
        const vm = this;
        const { render, _parentVnode } = vm.$options;
        if (_parentVnode && vm._isMounted) {
          vm.$scopedSlots = normalizeScopedSlots2(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
          if (vm._slotsProxy) {
            syncSetupSlots2(vm._slotsProxy, vm.$scopedSlots);
          }
        }
        vm.$vnode = _parentVnode;
        let vnode;
        try {
          setCurrentInstance3(vm);
          currentRenderingInstance2 = vm;
          vnode = render.call(vm._renderProxy, vm.$createElement);
        } catch (e) {
          handleError2(e, vm, `render`);
          if (vm.$options.renderError) {
            try {
              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
            } catch (e2) {
              handleError2(e2, vm, `renderError`);
              vnode = vm._vnode;
            }
          } else {
            vnode = vm._vnode;
          }
        } finally {
          currentRenderingInstance2 = null;
          setCurrentInstance3();
        }
        if (isArray3(vnode) && vnode.length === 1) {
          vnode = vnode[0];
        }
        if (!(vnode instanceof VNode2)) {
          if (isArray3(vnode)) {
            warn3("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
          }
          vnode = createEmptyVNode2();
        }
        vnode.parent = _parentVnode;
        return vnode;
      };
    }
    function ensureCtor2(comp, base) {
      if (comp.__esModule || hasSymbol3 && comp[Symbol.toStringTag] === "Module") {
        comp = comp.default;
      }
      return isObject3(comp) ? base.extend(comp) : comp;
    }
    function createAsyncPlaceholder2(factory, data, context, children, tag) {
      const node = createEmptyVNode2();
      node.asyncFactory = factory;
      node.asyncMeta = { data, context, children, tag };
      return node;
    }
    function resolveAsyncComponent2(factory, baseCtor) {
      if (isTrue2(factory.error) && isDef2(factory.errorComp)) {
        return factory.errorComp;
      }
      if (isDef2(factory.resolved)) {
        return factory.resolved;
      }
      const owner = currentRenderingInstance2;
      if (owner && isDef2(factory.owners) && factory.owners.indexOf(owner) === -1) {
        factory.owners.push(owner);
      }
      if (isTrue2(factory.loading) && isDef2(factory.loadingComp)) {
        return factory.loadingComp;
      }
      if (owner && !isDef2(factory.owners)) {
        const owners = factory.owners = [owner];
        let sync = true;
        let timerLoading = null;
        let timerTimeout = null;
        owner.$on("hook:destroyed", () => remove$22(owners, owner));
        const forceRender = (renderCompleted) => {
          for (let i = 0, l = owners.length; i < l; i++) {
            owners[i].$forceUpdate();
          }
          if (renderCompleted) {
            owners.length = 0;
            if (timerLoading !== null) {
              clearTimeout(timerLoading);
              timerLoading = null;
            }
            if (timerTimeout !== null) {
              clearTimeout(timerTimeout);
              timerTimeout = null;
            }
          }
        };
        const resolve = once2((res2) => {
          factory.resolved = ensureCtor2(res2, baseCtor);
          if (!sync) {
            forceRender(true);
          } else {
            owners.length = 0;
          }
        });
        const reject = once2((reason) => {
          warn3(`Failed to resolve async component: ${String(factory)}` + (reason ? `
Reason: ${reason}` : ""));
          if (isDef2(factory.errorComp)) {
            factory.error = true;
            forceRender(true);
          }
        });
        const res = factory(resolve, reject);
        if (isObject3(res)) {
          if (isPromise2(res)) {
            if (isUndef3(factory.resolved)) {
              res.then(resolve, reject);
            }
          } else if (isPromise2(res.component)) {
            res.component.then(resolve, reject);
            if (isDef2(res.error)) {
              factory.errorComp = ensureCtor2(res.error, baseCtor);
            }
            if (isDef2(res.loading)) {
              factory.loadingComp = ensureCtor2(res.loading, baseCtor);
              if (res.delay === 0) {
                factory.loading = true;
              } else {
                timerLoading = setTimeout(() => {
                  timerLoading = null;
                  if (isUndef3(factory.resolved) && isUndef3(factory.error)) {
                    factory.loading = true;
                    forceRender(false);
                  }
                }, res.delay || 200);
              }
            }
            if (isDef2(res.timeout)) {
              timerTimeout = setTimeout(() => {
                timerTimeout = null;
                if (isUndef3(factory.resolved)) {
                  reject(`timeout (${res.timeout}ms)`);
                }
              }, res.timeout);
            }
          }
        }
        sync = false;
        return factory.loading ? factory.loadingComp : factory.resolved;
      }
    }
    function getFirstComponentChild2(children) {
      if (isArray3(children)) {
        for (let i = 0; i < children.length; i++) {
          const c = children[i];
          if (isDef2(c) && (isDef2(c.componentOptions) || isAsyncPlaceholder2(c))) {
            return c;
          }
        }
      }
    }
    var SIMPLE_NORMALIZE2 = 1;
    var ALWAYS_NORMALIZE2 = 2;
    function createElement$12(context, tag, data, children, normalizationType, alwaysNormalize) {
      if (isArray3(data) || isPrimitive3(data)) {
        normalizationType = children;
        children = data;
        data = void 0;
      }
      if (isTrue2(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE2;
      }
      return _createElement2(context, tag, data, children, normalizationType);
    }
    function _createElement2(context, tag, data, children, normalizationType) {
      if (isDef2(data) && isDef2(data.__ob__)) {
        warn3(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}
Always create fresh vnode data objects in each render!`, context);
        return createEmptyVNode2();
      }
      if (isDef2(data) && isDef2(data.is)) {
        tag = data.is;
      }
      if (!tag) {
        return createEmptyVNode2();
      }
      if (isDef2(data) && isDef2(data.key) && !isPrimitive3(data.key)) {
        warn3("Avoid using non-primitive value as key, use string/number value instead.", context);
      }
      if (isArray3(children) && isFunction3(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
      }
      if (normalizationType === ALWAYS_NORMALIZE2) {
        children = normalizeChildren2(children);
      } else if (normalizationType === SIMPLE_NORMALIZE2) {
        children = simpleNormalizeChildren2(children);
      }
      let vnode, ns;
      if (typeof tag === "string") {
        let Ctor;
        ns = context.$vnode && context.$vnode.ns || config2.getTagNamespace(tag);
        if (config2.isReservedTag(tag)) {
          if (isDef2(data) && isDef2(data.nativeOn) && data.tag !== "component") {
            warn3(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);
          }
          vnode = new VNode2(config2.parsePlatformTagName(tag), data, children, void 0, void 0, context);
        } else if ((!data || !data.pre) && isDef2(Ctor = resolveAsset2(context.$options, "components", tag))) {
          vnode = createComponent2(Ctor, data, context, children, tag);
        } else {
          vnode = new VNode2(tag, data, children, void 0, void 0, context);
        }
      } else {
        vnode = createComponent2(tag, data, context, children);
      }
      if (isArray3(vnode)) {
        return vnode;
      } else if (isDef2(vnode)) {
        if (isDef2(ns))
          applyNS2(vnode, ns);
        if (isDef2(data))
          registerDeepBindings2(data);
        return vnode;
      } else {
        return createEmptyVNode2();
      }
    }
    function applyNS2(vnode, ns, force) {
      vnode.ns = ns;
      if (vnode.tag === "foreignObject") {
        ns = void 0;
        force = true;
      }
      if (isDef2(vnode.children)) {
        for (let i = 0, l = vnode.children.length; i < l; i++) {
          const child = vnode.children[i];
          if (isDef2(child.tag) && (isUndef3(child.ns) || isTrue2(force) && child.tag !== "svg")) {
            applyNS2(child, ns, force);
          }
        }
      }
    }
    function registerDeepBindings2(data) {
      if (isObject3(data.style)) {
        traverse3(data.style);
      }
      if (isObject3(data.class)) {
        traverse3(data.class);
      }
    }
    function h(type, props3, children) {
      if (!currentInstance3) {
        warn3(`globally imported h() can only be invoked when there is an active component instance, e.g. synchronously in a component's render or setup function.`);
      }
      return createElement$12(currentInstance3, type, props3, children, 2, true);
    }
    function handleError2(err, vm, info) {
      pushTarget2();
      try {
        if (vm) {
          let cur = vm;
          while (cur = cur.$parent) {
            const hooks3 = cur.$options.errorCaptured;
            if (hooks3) {
              for (let i = 0; i < hooks3.length; i++) {
                try {
                  const capture = hooks3[i].call(cur, err, vm, info) === false;
                  if (capture)
                    return;
                } catch (e) {
                  globalHandleError2(e, cur, "errorCaptured hook");
                }
              }
            }
          }
        }
        globalHandleError2(err, vm, info);
      } finally {
        popTarget2();
      }
    }
    function invokeWithErrorHandling2(handler, context, args, vm, info) {
      let res;
      try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise2(res) && !res._handled) {
          res.catch((e) => handleError2(e, vm, info + ` (Promise/async)`));
          res._handled = true;
        }
      } catch (e) {
        handleError2(e, vm, info);
      }
      return res;
    }
    function globalHandleError2(err, vm, info) {
      if (config2.errorHandler) {
        try {
          return config2.errorHandler.call(null, err, vm, info);
        } catch (e) {
          if (e !== err) {
            logError3(e, null, "config.errorHandler");
          }
        }
      }
      logError3(err, vm, info);
    }
    function logError3(err, vm, info) {
      {
        warn3(`Error in ${info}: "${err.toString()}"`, vm);
      }
      if (inBrowser2 && typeof console !== "undefined") {
        console.error(err);
      } else {
        throw err;
      }
    }
    var isUsingMicroTask2 = false;
    var callbacks2 = [];
    var pending2 = false;
    function flushCallbacks2() {
      pending2 = false;
      const copies = callbacks2.slice(0);
      callbacks2.length = 0;
      for (let i = 0; i < copies.length; i++) {
        copies[i]();
      }
    }
    var timerFunc2;
    if (typeof Promise !== "undefined" && isNative3(Promise)) {
      const p = Promise.resolve();
      timerFunc2 = () => {
        p.then(flushCallbacks2);
        if (isIOS2)
          setTimeout(noop2);
      };
      isUsingMicroTask2 = true;
    } else if (!isIE2 && typeof MutationObserver !== "undefined" && (isNative3(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
      let counter = 1;
      const observer = new MutationObserver(flushCallbacks2);
      const textNode = document.createTextNode(String(counter));
      observer.observe(textNode, {
        characterData: true
      });
      timerFunc2 = () => {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
      };
      isUsingMicroTask2 = true;
    } else if (typeof setImmediate !== "undefined" && isNative3(setImmediate)) {
      timerFunc2 = () => {
        setImmediate(flushCallbacks2);
      };
    } else {
      timerFunc2 = () => {
        setTimeout(flushCallbacks2, 0);
      };
    }
    function nextTick4(cb, ctx) {
      let _resolve;
      callbacks2.push(() => {
        if (cb) {
          try {
            cb.call(ctx);
          } catch (e) {
            handleError2(e, ctx, "nextTick");
          }
        } else if (_resolve) {
          _resolve(ctx);
        }
      });
      if (!pending2) {
        pending2 = true;
        timerFunc2();
      }
      if (!cb && typeof Promise !== "undefined") {
        return new Promise((resolve) => {
          _resolve = resolve;
        });
      }
    }
    function useCssModule2(name = "$style") {
      {
        if (!currentInstance3) {
          warn3(`useCssModule must be called inside setup()`);
          return emptyObject2;
        }
        const mod = currentInstance3[name];
        if (!mod) {
          warn3(`Current instance does not have CSS module named "${name}".`);
          return emptyObject2;
        }
        return mod;
      }
    }
    function useCssVars(getter) {
      if (!inBrowser2 && true)
        return;
      const instance = currentInstance3;
      if (!instance) {
        warn3(`useCssVars is called without current active component instance.`);
        return;
      }
      watchPostEffect2(() => {
        const el = instance.$el;
        const vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
          const style3 = el.style;
          for (const key in vars) {
            style3.setProperty(`--${key}`, vars[key]);
          }
        }
      });
    }
    function defineAsyncComponent2(source) {
      if (isFunction3(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay = 200,
        timeout,
        suspensible = false,
        onError: userOnError
      } = source;
      if (suspensible) {
        warn3(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);
      }
      let pendingRequest = null;
      let retries = 0;
      const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve, reject) => {
              const userRetry = () => resolve(retry());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (!comp) {
            warn3(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          if (comp && !isObject3(comp) && !isFunction3(comp)) {
            throw new Error(`Invalid async component load result: ${comp}`);
          }
          return comp;
        }));
      };
      return () => {
        const component = load();
        return {
          component,
          delay,
          timeout,
          error: errorComponent,
          loading: loadingComponent
        };
      };
    }
    function createLifeCycle3(hookName) {
      return (fn, target3 = currentInstance3) => {
        if (!target3) {
          warn3(`${formatName2(hookName)} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`);
          return;
        }
        return injectHook2(target3, hookName, fn);
      };
    }
    function formatName2(name) {
      if (name === "beforeDestroy") {
        name = "beforeUnmount";
      } else if (name === "destroyed") {
        name = "unmounted";
      }
      return `on${name[0].toUpperCase() + name.slice(1)}`;
    }
    function injectHook2(instance, hookName, fn) {
      const options = instance.$options;
      options[hookName] = mergeLifecycleHook2(options[hookName], fn);
    }
    var onBeforeMount3 = createLifeCycle3("beforeMount");
    var onMounted3 = createLifeCycle3("mounted");
    var onBeforeUpdate3 = createLifeCycle3("beforeUpdate");
    var onUpdated3 = createLifeCycle3("updated");
    var onBeforeUnmount3 = createLifeCycle3("beforeDestroy");
    var onUnmounted3 = createLifeCycle3("destroyed");
    var onErrorCaptured3 = createLifeCycle3("errorCaptured");
    var onActivated3 = createLifeCycle3("activated");
    var onDeactivated3 = createLifeCycle3("deactivated");
    var onServerPrefetch3 = createLifeCycle3("serverPrefetch");
    var onRenderTracked2 = createLifeCycle3("renderTracked");
    var onRenderTriggered2 = createLifeCycle3("renderTriggered");
    var version3 = "2.7.7";
    function defineComponent2(options) {
      return options;
    }
    var vca = Object.freeze({
      __proto__: null,
      version: version3,
      defineComponent: defineComponent2,
      ref: ref$1,
      shallowRef: shallowRef2,
      isRef: isRef3,
      toRef: toRef2,
      toRefs: toRefs2,
      unref: unref2,
      proxyRefs: proxyRefs2,
      customRef: customRef2,
      triggerRef: triggerRef2,
      reactive: reactive2,
      isReactive: isReactive2,
      isReadonly: isReadonly3,
      isShallow,
      isProxy,
      shallowReactive: shallowReactive3,
      markRaw: markRaw2,
      toRaw: toRaw2,
      readonly: readonly2,
      shallowReadonly: shallowReadonly2,
      computed: computed2,
      watch: watch2,
      watchEffect: watchEffect2,
      watchPostEffect: watchPostEffect2,
      watchSyncEffect: watchSyncEffect2,
      EffectScope: EffectScope3,
      effectScope: effectScope2,
      onScopeDispose: onScopeDispose2,
      getCurrentScope: getCurrentScope2,
      provide: provide2,
      inject: inject2,
      h,
      getCurrentInstance: getCurrentInstance2,
      useSlots: useSlots2,
      useAttrs: useAttrs2,
      mergeDefaults,
      nextTick: nextTick4,
      set: set3,
      del: del3,
      useCssModule: useCssModule2,
      useCssVars,
      defineAsyncComponent: defineAsyncComponent2,
      onBeforeMount: onBeforeMount3,
      onMounted: onMounted3,
      onBeforeUpdate: onBeforeUpdate3,
      onUpdated: onUpdated3,
      onBeforeUnmount: onBeforeUnmount3,
      onUnmounted: onUnmounted3,
      onErrorCaptured: onErrorCaptured3,
      onActivated: onActivated3,
      onDeactivated: onDeactivated3,
      onServerPrefetch: onServerPrefetch3,
      onRenderTracked: onRenderTracked2,
      onRenderTriggered: onRenderTriggered2
    });
    var seenObjects2 = new _Set2();
    function traverse3(val) {
      _traverse2(val, seenObjects2);
      seenObjects2.clear();
      return val;
    }
    function _traverse2(val, seen) {
      let i, keys;
      const isA = isArray3(val);
      if (!isA && !isObject3(val) || Object.isFrozen(val) || val instanceof VNode2) {
        return;
      }
      if (val.__ob__) {
        const depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
          return;
        }
        seen.add(depId);
      }
      if (isA) {
        i = val.length;
        while (i--)
          _traverse2(val[i], seen);
      } else if (isRef3(val)) {
        _traverse2(val.value, seen);
      } else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
          _traverse2(val[keys[i]], seen);
      }
    }
    var uid$12 = 0;
    var Watcher2 = class {
      constructor(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope3(this, activeEffectScope3 || (vm ? vm._scope : void 0));
        if (this.vm = vm) {
          if (isRenderWatcher) {
            vm._watcher = this;
          }
        }
        if (options) {
          this.deep = !!options.deep;
          this.user = !!options.user;
          this.lazy = !!options.lazy;
          this.sync = !!options.sync;
          this.before = options.before;
          {
            this.onTrack = options.onTrack;
            this.onTrigger = options.onTrigger;
          }
        } else {
          this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$12;
        this.active = true;
        this.post = false;
        this.dirty = this.lazy;
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set2();
        this.newDepIds = new _Set2();
        this.expression = expOrFn.toString();
        if (isFunction3(expOrFn)) {
          this.getter = expOrFn;
        } else {
          this.getter = parsePath2(expOrFn);
          if (!this.getter) {
            this.getter = noop2;
            warn3(`Failed watching path: "${expOrFn}" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.`, vm);
          }
        }
        this.value = this.lazy ? void 0 : this.get();
      }
      get() {
        pushTarget2(this);
        let value;
        const vm = this.vm;
        try {
          value = this.getter.call(vm, vm);
        } catch (e) {
          if (this.user) {
            handleError2(e, vm, `getter for watcher "${this.expression}"`);
          } else {
            throw e;
          }
        } finally {
          if (this.deep) {
            traverse3(value);
          }
          popTarget2();
          this.cleanupDeps();
        }
        return value;
      }
      addDep(dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
          this.newDepIds.add(id);
          this.newDeps.push(dep);
          if (!this.depIds.has(id)) {
            dep.addSub(this);
          }
        }
      }
      cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
          const dep = this.deps[i];
          if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
          }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
      }
      update() {
        if (this.lazy) {
          this.dirty = true;
        } else if (this.sync) {
          this.run();
        } else {
          queueWatcher2(this);
        }
      }
      run() {
        if (this.active) {
          const value = this.get();
          if (value !== this.value || isObject3(value) || this.deep) {
            const oldValue = this.value;
            this.value = value;
            if (this.user) {
              const info = `callback for watcher "${this.expression}"`;
              invokeWithErrorHandling2(this.cb, this.vm, [value, oldValue], this.vm, info);
            } else {
              this.cb.call(this.vm, value, oldValue);
            }
          }
        }
      }
      evaluate() {
        this.value = this.get();
        this.dirty = false;
      }
      depend() {
        let i = this.deps.length;
        while (i--) {
          this.deps[i].depend();
        }
      }
      teardown() {
        if (this.vm && !this.vm._isBeingDestroyed) {
          remove$22(this.vm._scope.effects, this);
        }
        if (this.active) {
          let i = this.deps.length;
          while (i--) {
            this.deps[i].removeSub(this);
          }
          this.active = false;
          if (this.onStop) {
            this.onStop();
          }
        }
      }
    };
    var mark2;
    var measure2;
    {
      const perf = inBrowser2 && window.performance;
      if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
        mark2 = (tag) => perf.mark(tag);
        measure2 = (name, startTag, endTag) => {
          perf.measure(name, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        };
      }
    }
    function initEvents2(vm) {
      vm._events = /* @__PURE__ */ Object.create(null);
      vm._hasHookEvent = false;
      const listeners = vm.$options._parentListeners;
      if (listeners) {
        updateComponentListeners2(vm, listeners);
      }
    }
    var target$12;
    function add$12(event, fn) {
      target$12.$on(event, fn);
    }
    function remove$12(event, fn) {
      target$12.$off(event, fn);
    }
    function createOnceHandler$12(event, fn) {
      const _target = target$12;
      return function onceHandler() {
        const res = fn.apply(null, arguments);
        if (res !== null) {
          _target.$off(event, onceHandler);
        }
      };
    }
    function updateComponentListeners2(vm, listeners, oldListeners) {
      target$12 = vm;
      updateListeners2(listeners, oldListeners || {}, add$12, remove$12, createOnceHandler$12, vm);
      target$12 = void 0;
    }
    function eventsMixin2(Vue4) {
      const hookRE = /^hook:/;
      Vue4.prototype.$on = function(event, fn) {
        const vm = this;
        if (isArray3(event)) {
          for (let i = 0, l = event.length; i < l; i++) {
            vm.$on(event[i], fn);
          }
        } else {
          (vm._events[event] || (vm._events[event] = [])).push(fn);
          if (hookRE.test(event)) {
            vm._hasHookEvent = true;
          }
        }
        return vm;
      };
      Vue4.prototype.$once = function(event, fn) {
        const vm = this;
        function on() {
          vm.$off(event, on);
          fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
      };
      Vue4.prototype.$off = function(event, fn) {
        const vm = this;
        if (!arguments.length) {
          vm._events = /* @__PURE__ */ Object.create(null);
          return vm;
        }
        if (isArray3(event)) {
          for (let i2 = 0, l = event.length; i2 < l; i2++) {
            vm.$off(event[i2], fn);
          }
          return vm;
        }
        const cbs = vm._events[event];
        if (!cbs) {
          return vm;
        }
        if (!fn) {
          vm._events[event] = null;
          return vm;
        }
        let cb;
        let i = cbs.length;
        while (i--) {
          cb = cbs[i];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1);
            break;
          }
        }
        return vm;
      };
      Vue4.prototype.$emit = function(event) {
        const vm = this;
        {
          const lowerCaseEvent = event.toLowerCase();
          if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
            tip2(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName2(vm)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate2(event)}" instead of "${event}".`);
          }
        }
        let cbs = vm._events[event];
        if (cbs) {
          cbs = cbs.length > 1 ? toArray2(cbs) : cbs;
          const args = toArray2(arguments, 1);
          const info = `event handler for "${event}"`;
          for (let i = 0, l = cbs.length; i < l; i++) {
            invokeWithErrorHandling2(cbs[i], vm, args, vm, info);
          }
        }
        return vm;
      };
    }
    var activeInstance2 = null;
    var isUpdatingChildComponent2 = false;
    function setActiveInstance2(vm) {
      const prevActiveInstance = activeInstance2;
      activeInstance2 = vm;
      return () => {
        activeInstance2 = prevActiveInstance;
      };
    }
    function initLifecycle2(vm) {
      const options = vm.$options;
      let parent = options.parent;
      if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
          parent = parent.$parent;
        }
        parent.$children.push(vm);
      }
      vm.$parent = parent;
      vm.$root = parent ? parent.$root : vm;
      vm.$children = [];
      vm.$refs = {};
      vm._provided = parent ? parent._provided : /* @__PURE__ */ Object.create(null);
      vm._watcher = null;
      vm._inactive = null;
      vm._directInactive = false;
      vm._isMounted = false;
      vm._isDestroyed = false;
      vm._isBeingDestroyed = false;
    }
    function lifecycleMixin2(Vue4) {
      Vue4.prototype._update = function(vnode, hydrating) {
        const vm = this;
        const prevEl = vm.$el;
        const prevVnode = vm._vnode;
        const restoreActiveInstance = setActiveInstance2(vm);
        vm._vnode = vnode;
        if (!prevVnode) {
          vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
        } else {
          vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        if (prevEl) {
          prevEl.__vue__ = null;
        }
        if (vm.$el) {
          vm.$el.__vue__ = vm;
        }
        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
          vm.$parent.$el = vm.$el;
        }
      };
      Vue4.prototype.$forceUpdate = function() {
        const vm = this;
        if (vm._watcher) {
          vm._watcher.update();
        }
      };
      Vue4.prototype.$destroy = function() {
        const vm = this;
        if (vm._isBeingDestroyed) {
          return;
        }
        callHook$12(vm, "beforeDestroy");
        vm._isBeingDestroyed = true;
        const parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
          remove$22(parent.$children, vm);
        }
        vm._scope.stop();
        if (vm._data.__ob__) {
          vm._data.__ob__.vmCount--;
        }
        vm._isDestroyed = true;
        vm.__patch__(vm._vnode, null);
        callHook$12(vm, "destroyed");
        vm.$off();
        if (vm.$el) {
          vm.$el.__vue__ = null;
        }
        if (vm.$vnode) {
          vm.$vnode.parent = null;
        }
      };
    }
    function mountComponent2(vm, el, hydrating) {
      vm.$el = el;
      if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode2;
        {
          if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
            warn3("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
          } else {
            warn3("Failed to mount component: template or render function not defined.", vm);
          }
        }
      }
      callHook$12(vm, "beforeMount");
      let updateComponent;
      if (config2.performance && mark2) {
        updateComponent = () => {
          const name = vm._name;
          const id = vm._uid;
          const startTag = `vue-perf-start:${id}`;
          const endTag = `vue-perf-end:${id}`;
          mark2(startTag);
          const vnode = vm._render();
          mark2(endTag);
          measure2(`vue ${name} render`, startTag, endTag);
          mark2(startTag);
          vm._update(vnode, hydrating);
          mark2(endTag);
          measure2(`vue ${name} patch`, startTag, endTag);
        };
      } else {
        updateComponent = () => {
          vm._update(vm._render(), hydrating);
        };
      }
      const watcherOptions = {
        before() {
          if (vm._isMounted && !vm._isDestroyed) {
            callHook$12(vm, "beforeUpdate");
          }
        }
      };
      {
        watcherOptions.onTrack = (e) => callHook$12(vm, "renderTracked", [e]);
        watcherOptions.onTrigger = (e) => callHook$12(vm, "renderTriggered", [e]);
      }
      new Watcher2(vm, updateComponent, noop2, watcherOptions, true);
      hydrating = false;
      const preWatchers = vm._preWatchers;
      if (preWatchers) {
        for (let i = 0; i < preWatchers.length; i++) {
          preWatchers[i].run();
        }
      }
      if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$12(vm, "mounted");
      }
      return vm;
    }
    function updateChildComponent2(vm, propsData, listeners, parentVnode, renderChildren) {
      {
        isUpdatingChildComponent2 = true;
      }
      const newScopedSlots = parentVnode.data.scopedSlots;
      const oldScopedSlots = vm.$scopedSlots;
      const hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject2 && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
      let needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
      const prevVNode = vm.$vnode;
      vm.$options._parentVnode = parentVnode;
      vm.$vnode = parentVnode;
      if (vm._vnode) {
        vm._vnode.parent = parentVnode;
      }
      vm.$options._renderChildren = renderChildren;
      const attrs3 = parentVnode.data.attrs || emptyObject2;
      if (vm._attrsProxy) {
        if (syncSetupAttrs(vm._attrsProxy, attrs3, prevVNode.data && prevVNode.data.attrs || emptyObject2, vm)) {
          needsForceUpdate = true;
        }
      }
      vm.$attrs = attrs3;
      vm.$listeners = listeners || emptyObject2;
      if (propsData && vm.$options.props) {
        toggleObserving2(false);
        const props3 = vm._props;
        const propKeys = vm.$options._propKeys || [];
        for (let i = 0; i < propKeys.length; i++) {
          const key = propKeys[i];
          const propOptions = vm.$options.props;
          props3[key] = validateProp2(key, propOptions, propsData, vm);
        }
        toggleObserving2(true);
        vm.$options.propsData = propsData;
      }
      listeners = listeners || emptyObject2;
      const oldListeners = vm.$options._parentListeners;
      vm.$options._parentListeners = listeners;
      updateComponentListeners2(vm, listeners, oldListeners);
      if (needsForceUpdate) {
        vm.$slots = resolveSlots3(renderChildren, parentVnode.context);
        vm.$forceUpdate();
      }
      {
        isUpdatingChildComponent2 = false;
      }
    }
    function isInInactiveTree2(vm) {
      while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
          return true;
      }
      return false;
    }
    function activateChildComponent2(vm, direct) {
      if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree2(vm)) {
          return;
        }
      } else if (vm._directInactive) {
        return;
      }
      if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (let i = 0; i < vm.$children.length; i++) {
          activateChildComponent2(vm.$children[i]);
        }
        callHook$12(vm, "activated");
      }
    }
    function deactivateChildComponent2(vm, direct) {
      if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree2(vm)) {
          return;
        }
      }
      if (!vm._inactive) {
        vm._inactive = true;
        for (let i = 0; i < vm.$children.length; i++) {
          deactivateChildComponent2(vm.$children[i]);
        }
        callHook$12(vm, "deactivated");
      }
    }
    function callHook$12(vm, hook, args, setContext = true) {
      pushTarget2();
      const prev = currentInstance3;
      setContext && setCurrentInstance3(vm);
      const handlers = vm.$options[hook];
      const info = `${hook} hook`;
      if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
          invokeWithErrorHandling2(handlers[i], vm, args || null, vm, info);
        }
      }
      if (vm._hasHookEvent) {
        vm.$emit("hook:" + hook);
      }
      setContext && setCurrentInstance3(prev);
      popTarget2();
    }
    var MAX_UPDATE_COUNT2 = 100;
    var queue2 = [];
    var activatedChildren2 = [];
    var has2 = {};
    var circular2 = {};
    var waiting2 = false;
    var flushing2 = false;
    var index2 = 0;
    function resetSchedulerState2() {
      index2 = queue2.length = activatedChildren2.length = 0;
      has2 = {};
      {
        circular2 = {};
      }
      waiting2 = flushing2 = false;
    }
    var currentFlushTimestamp2 = 0;
    var getNow2 = Date.now;
    if (inBrowser2 && !isIE2) {
      const performance = window.performance;
      if (performance && typeof performance.now === "function" && getNow2() > document.createEvent("Event").timeStamp) {
        getNow2 = () => performance.now();
      }
    }
    var sortCompareFn2 = (a, b) => {
      if (a.post) {
        if (!b.post)
          return 1;
      } else if (b.post) {
        return -1;
      }
      return a.id - b.id;
    };
    function flushSchedulerQueue2() {
      currentFlushTimestamp2 = getNow2();
      flushing2 = true;
      let watcher, id;
      queue2.sort(sortCompareFn2);
      for (index2 = 0; index2 < queue2.length; index2++) {
        watcher = queue2[index2];
        if (watcher.before) {
          watcher.before();
        }
        id = watcher.id;
        has2[id] = null;
        watcher.run();
        if (has2[id] != null) {
          circular2[id] = (circular2[id] || 0) + 1;
          if (circular2[id] > MAX_UPDATE_COUNT2) {
            warn3("You may have an infinite update loop " + (watcher.user ? `in watcher with expression "${watcher.expression}"` : `in a component render function.`), watcher.vm);
            break;
          }
        }
      }
      const activatedQueue = activatedChildren2.slice();
      const updatedQueue = queue2.slice();
      resetSchedulerState2();
      callActivatedHooks2(activatedQueue);
      callUpdatedHooks2(updatedQueue);
      if (devtools2 && config2.devtools) {
        devtools2.emit("flush");
      }
    }
    function callUpdatedHooks2(queue3) {
      let i = queue3.length;
      while (i--) {
        const watcher = queue3[i];
        const vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
          callHook$12(vm, "updated");
        }
      }
    }
    function queueActivatedComponent2(vm) {
      vm._inactive = false;
      activatedChildren2.push(vm);
    }
    function callActivatedHooks2(queue3) {
      for (let i = 0; i < queue3.length; i++) {
        queue3[i]._inactive = true;
        activateChildComponent2(queue3[i], true);
      }
    }
    function queueWatcher2(watcher) {
      const id = watcher.id;
      if (has2[id] != null) {
        return;
      }
      if (watcher === Dep2.target && watcher.noRecurse) {
        return;
      }
      has2[id] = true;
      if (!flushing2) {
        queue2.push(watcher);
      } else {
        let i = queue2.length - 1;
        while (i > index2 && queue2[i].id > watcher.id) {
          i--;
        }
        queue2.splice(i + 1, 0, watcher);
      }
      if (!waiting2) {
        waiting2 = true;
        if (!config2.async) {
          flushSchedulerQueue2();
          return;
        }
        nextTick4(flushSchedulerQueue2);
      }
    }
    function initProvide2(vm) {
      const provideOption = vm.$options.provide;
      if (provideOption) {
        const provided = isFunction3(provideOption) ? provideOption.call(vm) : provideOption;
        if (!isObject3(provided)) {
          return;
        }
        const source = resolveProvided2(vm);
        const keys = hasSymbol3 ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
      }
    }
    function initInjections2(vm) {
      const result = resolveInject3(vm.$options.inject, vm);
      if (result) {
        toggleObserving2(false);
        Object.keys(result).forEach((key) => {
          {
            defineReactive2(vm, key, result[key], () => {
              warn3(`Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "${key}"`, vm);
            });
          }
        });
        toggleObserving2(true);
      }
    }
    function resolveInject3(inject3, vm) {
      if (inject3) {
        const result = /* @__PURE__ */ Object.create(null);
        const keys = hasSymbol3 ? Reflect.ownKeys(inject3) : Object.keys(inject3);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key === "__ob__")
            continue;
          const provideKey = inject3[key].from;
          if (provideKey in vm._provided) {
            result[key] = vm._provided[provideKey];
          } else if ("default" in inject3[key]) {
            const provideDefault = inject3[key].default;
            result[key] = isFunction3(provideDefault) ? provideDefault.call(vm) : provideDefault;
          } else {
            warn3(`Injection "${key}" not found`, vm);
          }
        }
        return result;
      }
    }
    function FunctionalRenderContext2(data, props3, children, parent, Ctor) {
      const options = Ctor.options;
      let contextVm;
      if (hasOwn3(parent, "_uid")) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
      } else {
        contextVm = parent;
        parent = parent._original;
      }
      const isCompiled = isTrue2(options._compiled);
      const needNormalization = !isCompiled;
      this.data = data;
      this.props = props3;
      this.children = children;
      this.parent = parent;
      this.listeners = data.on || emptyObject2;
      this.injections = resolveInject3(options.inject, parent);
      this.slots = () => {
        if (!this.$slots) {
          normalizeScopedSlots2(parent, data.scopedSlots, this.$slots = resolveSlots3(children, parent));
        }
        return this.$slots;
      };
      Object.defineProperty(this, "scopedSlots", {
        enumerable: true,
        get() {
          return normalizeScopedSlots2(parent, data.scopedSlots, this.slots());
        }
      });
      if (isCompiled) {
        this.$options = options;
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots2(parent, data.scopedSlots, this.$slots);
      }
      if (options._scopeId) {
        this._c = (a, b, c, d) => {
          const vnode = createElement$12(contextVm, a, b, c, d, needNormalization);
          if (vnode && !isArray3(vnode)) {
            vnode.fnScopeId = options._scopeId;
            vnode.fnContext = parent;
          }
          return vnode;
        };
      } else {
        this._c = (a, b, c, d) => createElement$12(contextVm, a, b, c, d, needNormalization);
      }
    }
    installRenderHelpers2(FunctionalRenderContext2.prototype);
    function createFunctionalComponent2(Ctor, propsData, data, contextVm, children) {
      const options = Ctor.options;
      const props3 = {};
      const propOptions = options.props;
      if (isDef2(propOptions)) {
        for (const key in propOptions) {
          props3[key] = validateProp2(key, propOptions, propsData || emptyObject2);
        }
      } else {
        if (isDef2(data.attrs))
          mergeProps2(props3, data.attrs);
        if (isDef2(data.props))
          mergeProps2(props3, data.props);
      }
      const renderContext = new FunctionalRenderContext2(data, props3, children, contextVm, Ctor);
      const vnode = options.render.call(null, renderContext._c, renderContext);
      if (vnode instanceof VNode2) {
        return cloneAndMarkFunctionalResult2(vnode, data, renderContext.parent, options, renderContext);
      } else if (isArray3(vnode)) {
        const vnodes = normalizeChildren2(vnode) || [];
        const res = new Array(vnodes.length);
        for (let i = 0; i < vnodes.length; i++) {
          res[i] = cloneAndMarkFunctionalResult2(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
      }
    }
    function cloneAndMarkFunctionalResult2(vnode, data, contextVm, options, renderContext) {
      const clone = cloneVNode2(vnode);
      clone.fnContext = contextVm;
      clone.fnOptions = options;
      {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
      }
      if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
      }
      return clone;
    }
    function mergeProps2(to, from) {
      for (const key in from) {
        to[camelize2(key)] = from[key];
      }
    }
    function getComponentName2(options) {
      return options.name || options.__name || options._componentTag;
    }
    var componentVNodeHooks2 = {
      init(vnode, hydrating) {
        if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
          const mountedNode = vnode;
          componentVNodeHooks2.prepatch(mountedNode, mountedNode);
        } else {
          const child = vnode.componentInstance = createComponentInstanceForVnode2(vnode, activeInstance2);
          child.$mount(hydrating ? vnode.elm : void 0, hydrating);
        }
      },
      prepatch(oldVnode, vnode) {
        const options = vnode.componentOptions;
        const child = vnode.componentInstance = oldVnode.componentInstance;
        updateChildComponent2(child, options.propsData, options.listeners, vnode, options.children);
      },
      insert(vnode) {
        const { context, componentInstance } = vnode;
        if (!componentInstance._isMounted) {
          componentInstance._isMounted = true;
          callHook$12(componentInstance, "mounted");
        }
        if (vnode.data.keepAlive) {
          if (context._isMounted) {
            queueActivatedComponent2(componentInstance);
          } else {
            activateChildComponent2(componentInstance, true);
          }
        }
      },
      destroy(vnode) {
        const { componentInstance } = vnode;
        if (!componentInstance._isDestroyed) {
          if (!vnode.data.keepAlive) {
            componentInstance.$destroy();
          } else {
            deactivateChildComponent2(componentInstance, true);
          }
        }
      }
    };
    var hooksToMerge2 = Object.keys(componentVNodeHooks2);
    function createComponent2(Ctor, data, context, children, tag) {
      if (isUndef3(Ctor)) {
        return;
      }
      const baseCtor = context.$options._base;
      if (isObject3(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
      }
      if (typeof Ctor !== "function") {
        {
          warn3(`Invalid Component definition: ${String(Ctor)}`, context);
        }
        return;
      }
      let asyncFactory;
      if (isUndef3(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent2(asyncFactory, baseCtor);
        if (Ctor === void 0) {
          return createAsyncPlaceholder2(asyncFactory, data, context, children, tag);
        }
      }
      data = data || {};
      resolveConstructorOptions2(Ctor);
      if (isDef2(data.model)) {
        transformModel2(Ctor.options, data);
      }
      const propsData = extractPropsFromVNodeData2(data, Ctor, tag);
      if (isTrue2(Ctor.options.functional)) {
        return createFunctionalComponent2(Ctor, propsData, data, context, children);
      }
      const listeners = data.on;
      data.on = data.nativeOn;
      if (isTrue2(Ctor.options.abstract)) {
        const slot = data.slot;
        data = {};
        if (slot) {
          data.slot = slot;
        }
      }
      installComponentHooks2(data);
      const name = getComponentName2(Ctor.options) || tag;
      const vnode = new VNode2(`vue-component-${Ctor.cid}${name ? `-${name}` : ""}`, data, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
      return vnode;
    }
    function createComponentInstanceForVnode2(vnode, parent) {
      const options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent
      };
      const inlineTemplate = vnode.data.inlineTemplate;
      if (isDef2(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
      }
      return new vnode.componentOptions.Ctor(options);
    }
    function installComponentHooks2(data) {
      const hooks3 = data.hook || (data.hook = {});
      for (let i = 0; i < hooksToMerge2.length; i++) {
        const key = hooksToMerge2[i];
        const existing = hooks3[key];
        const toMerge = componentVNodeHooks2[key];
        if (existing !== toMerge && !(existing && existing._merged)) {
          hooks3[key] = existing ? mergeHook2(toMerge, existing) : toMerge;
        }
      }
    }
    function mergeHook2(f1, f2) {
      const merged = (a, b) => {
        f1(a, b);
        f2(a, b);
      };
      merged._merged = true;
      return merged;
    }
    function transformModel2(options, data) {
      const prop = options.model && options.model.prop || "value";
      const event = options.model && options.model.event || "input";
      (data.attrs || (data.attrs = {}))[prop] = data.model.value;
      const on = data.on || (data.on = {});
      const existing = on[event];
      const callback = data.model.callback;
      if (isDef2(existing)) {
        if (isArray3(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
          on[event] = [callback].concat(existing);
        }
      } else {
        on[event] = callback;
      }
    }
    var warn3 = noop2;
    var tip2 = noop2;
    var generateComponentTrace2;
    var formatComponentName2;
    {
      const hasConsole = typeof console !== "undefined";
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      warn3 = (msg, vm = currentInstance3) => {
        const trace = vm ? generateComponentTrace2(vm) : "";
        if (config2.warnHandler) {
          config2.warnHandler.call(null, msg, vm, trace);
        } else if (hasConsole && !config2.silent) {
          console.error(`[Vue warn]: ${msg}${trace}`);
        }
      };
      tip2 = (msg, vm) => {
        if (hasConsole && !config2.silent) {
          console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace2(vm) : ""));
        }
      };
      formatComponentName2 = (vm, includeFile) => {
        if (vm.$root === vm) {
          return "<Root>";
        }
        const options = isFunction3(vm) && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
        let name = getComponentName2(options);
        const file = options.__file;
        if (!name && file) {
          const match = file.match(/([^/\\]+)\.vue$/);
          name = match && match[1];
        }
        return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
      };
      const repeat = (str, n) => {
        let res = "";
        while (n) {
          if (n % 2 === 1)
            res += str;
          if (n > 1)
            str += str;
          n >>= 1;
        }
        return res;
      };
      generateComponentTrace2 = (vm) => {
        if (vm._isVue && vm.$parent) {
          const tree = [];
          let currentRecursiveSequence = 0;
          while (vm) {
            if (tree.length > 0) {
              const last = tree[tree.length - 1];
              if (last.constructor === vm.constructor) {
                currentRecursiveSequence++;
                vm = vm.$parent;
                continue;
              } else if (currentRecursiveSequence > 0) {
                tree[tree.length - 1] = [last, currentRecursiveSequence];
                currentRecursiveSequence = 0;
              }
            }
            tree.push(vm);
            vm = vm.$parent;
          }
          return "\n\nfound in\n\n" + tree.map((vm2, i) => `${i === 0 ? "---> " : repeat(" ", 5 + i * 2)}${isArray3(vm2) ? `${formatComponentName2(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName2(vm2)}`).join("\n");
        } else {
          return `

(found in ${formatComponentName2(vm)})`;
        }
      };
    }
    var strats2 = config2.optionMergeStrategies;
    {
      strats2.el = strats2.propsData = function(parent, child, vm, key) {
        if (!vm) {
          warn3(`option "${key}" can only be used during instance creation with the \`new\` keyword.`);
        }
        return defaultStrat2(parent, child);
      };
    }
    function mergeData3(to, from) {
      if (!from)
        return to;
      let key, toVal, fromVal;
      const keys = hasSymbol3 ? Reflect.ownKeys(from) : Object.keys(from);
      for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        if (key === "__ob__")
          continue;
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn3(to, key)) {
          set3(to, key, fromVal);
        } else if (toVal !== fromVal && isPlainObject3(toVal) && isPlainObject3(fromVal)) {
          mergeData3(toVal, fromVal);
        }
      }
      return to;
    }
    function mergeDataOrFn2(parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        return function mergedDataFn() {
          return mergeData3(isFunction3(childVal) ? childVal.call(this, this) : childVal, isFunction3(parentVal) ? parentVal.call(this, this) : parentVal);
        };
      } else {
        return function mergedInstanceDataFn() {
          const instanceData = isFunction3(childVal) ? childVal.call(vm, vm) : childVal;
          const defaultData = isFunction3(parentVal) ? parentVal.call(vm, vm) : parentVal;
          if (instanceData) {
            return mergeData3(instanceData, defaultData);
          } else {
            return defaultData;
          }
        };
      }
    }
    strats2.data = function(parentVal, childVal, vm) {
      if (!vm) {
        if (childVal && typeof childVal !== "function") {
          warn3('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
          return parentVal;
        }
        return mergeDataOrFn2(parentVal, childVal);
      }
      return mergeDataOrFn2(parentVal, childVal, vm);
    };
    function mergeLifecycleHook2(parentVal, childVal) {
      const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray3(childVal) ? childVal : [childVal] : parentVal;
      return res ? dedupeHooks2(res) : res;
    }
    function dedupeHooks2(hooks3) {
      const res = [];
      for (let i = 0; i < hooks3.length; i++) {
        if (res.indexOf(hooks3[i]) === -1) {
          res.push(hooks3[i]);
        }
      }
      return res;
    }
    LIFECYCLE_HOOKS2.forEach((hook) => {
      strats2[hook] = mergeLifecycleHook2;
    });
    function mergeAssets2(parentVal, childVal, vm, key) {
      const res = Object.create(parentVal || null);
      if (childVal) {
        assertObjectType2(key, childVal, vm);
        return extend2(res, childVal);
      } else {
        return res;
      }
    }
    ASSET_TYPES2.forEach(function(type) {
      strats2[type + "s"] = mergeAssets2;
    });
    strats2.watch = function(parentVal, childVal, vm, key) {
      if (parentVal === nativeWatch2)
        parentVal = void 0;
      if (childVal === nativeWatch2)
        childVal = void 0;
      if (!childVal)
        return Object.create(parentVal || null);
      {
        assertObjectType2(key, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = {};
      extend2(ret, parentVal);
      for (const key2 in childVal) {
        let parent = ret[key2];
        const child = childVal[key2];
        if (parent && !isArray3(parent)) {
          parent = [parent];
        }
        ret[key2] = parent ? parent.concat(child) : isArray3(child) ? child : [child];
      }
      return ret;
    };
    strats2.props = strats2.methods = strats2.inject = strats2.computed = function(parentVal, childVal, vm, key) {
      if (childVal && true) {
        assertObjectType2(key, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = /* @__PURE__ */ Object.create(null);
      extend2(ret, parentVal);
      if (childVal)
        extend2(ret, childVal);
      return ret;
    };
    strats2.provide = mergeDataOrFn2;
    var defaultStrat2 = function(parentVal, childVal) {
      return childVal === void 0 ? parentVal : childVal;
    };
    function checkComponents2(options) {
      for (const key in options.components) {
        validateComponentName2(key);
      }
    }
    function validateComponentName2(name) {
      if (!new RegExp(`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp2.source}]*$`).test(name)) {
        warn3('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
      }
      if (isBuiltInTag2(name) || config2.isReservedTag(name)) {
        warn3("Do not use built-in or reserved HTML elements as component id: " + name);
      }
    }
    function normalizeProps2(options, vm) {
      const props3 = options.props;
      if (!props3)
        return;
      const res = {};
      let i, val, name;
      if (isArray3(props3)) {
        i = props3.length;
        while (i--) {
          val = props3[i];
          if (typeof val === "string") {
            name = camelize2(val);
            res[name] = { type: null };
          } else {
            warn3("props must be strings when using array syntax.");
          }
        }
      } else if (isPlainObject3(props3)) {
        for (const key in props3) {
          val = props3[key];
          name = camelize2(key);
          res[name] = isPlainObject3(val) ? val : { type: val };
        }
      } else {
        warn3(`Invalid value for option "props": expected an Array or an Object, but got ${toRawType2(props3)}.`, vm);
      }
      options.props = res;
    }
    function normalizeInject2(options, vm) {
      const inject3 = options.inject;
      if (!inject3)
        return;
      const normalized = options.inject = {};
      if (isArray3(inject3)) {
        for (let i = 0; i < inject3.length; i++) {
          normalized[inject3[i]] = { from: inject3[i] };
        }
      } else if (isPlainObject3(inject3)) {
        for (const key in inject3) {
          const val = inject3[key];
          normalized[key] = isPlainObject3(val) ? extend2({ from: key }, val) : { from: val };
        }
      } else {
        warn3(`Invalid value for option "inject": expected an Array or an Object, but got ${toRawType2(inject3)}.`, vm);
      }
    }
    function normalizeDirectives$12(options) {
      const dirs = options.directives;
      if (dirs) {
        for (const key in dirs) {
          const def4 = dirs[key];
          if (isFunction3(def4)) {
            dirs[key] = { bind: def4, update: def4 };
          }
        }
      }
    }
    function assertObjectType2(name, value, vm) {
      if (!isPlainObject3(value)) {
        warn3(`Invalid value for option "${name}": expected an Object, but got ${toRawType2(value)}.`, vm);
      }
    }
    function mergeOptions2(parent, child, vm) {
      {
        checkComponents2(child);
      }
      if (isFunction3(child)) {
        child = child.options;
      }
      normalizeProps2(child, vm);
      normalizeInject2(child, vm);
      normalizeDirectives$12(child);
      if (!child._base) {
        if (child.extends) {
          parent = mergeOptions2(parent, child.extends, vm);
        }
        if (child.mixins) {
          for (let i = 0, l = child.mixins.length; i < l; i++) {
            parent = mergeOptions2(parent, child.mixins[i], vm);
          }
        }
      }
      const options = {};
      let key;
      for (key in parent) {
        mergeField(key);
      }
      for (key in child) {
        if (!hasOwn3(parent, key)) {
          mergeField(key);
        }
      }
      function mergeField(key2) {
        const strat = strats2[key2] || defaultStrat2;
        options[key2] = strat(parent[key2], child[key2], vm, key2);
      }
      return options;
    }
    function resolveAsset2(options, type, id, warnMissing) {
      if (typeof id !== "string") {
        return;
      }
      const assets = options[type];
      if (hasOwn3(assets, id))
        return assets[id];
      const camelizedId = camelize2(id);
      if (hasOwn3(assets, camelizedId))
        return assets[camelizedId];
      const PascalCaseId = capitalize2(camelizedId);
      if (hasOwn3(assets, PascalCaseId))
        return assets[PascalCaseId];
      const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
      if (warnMissing && !res) {
        warn3("Failed to resolve " + type.slice(0, -1) + ": " + id);
      }
      return res;
    }
    function validateProp2(key, propOptions, propsData, vm) {
      const prop = propOptions[key];
      const absent = !hasOwn3(propsData, key);
      let value = propsData[key];
      const booleanIndex = getTypeIndex2(Boolean, prop.type);
      if (booleanIndex > -1) {
        if (absent && !hasOwn3(prop, "default")) {
          value = false;
        } else if (value === "" || value === hyphenate2(key)) {
          const stringIndex = getTypeIndex2(String, prop.type);
          if (stringIndex < 0 || booleanIndex < stringIndex) {
            value = true;
          }
        }
      }
      if (value === void 0) {
        value = getPropDefaultValue2(vm, prop, key);
        const prevShouldObserve = shouldObserve2;
        toggleObserving2(true);
        observe3(value);
        toggleObserving2(prevShouldObserve);
      }
      {
        assertProp2(prop, key, value, vm, absent);
      }
      return value;
    }
    function getPropDefaultValue2(vm, prop, key) {
      if (!hasOwn3(prop, "default")) {
        return void 0;
      }
      const def4 = prop.default;
      if (isObject3(def4)) {
        warn3('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
      }
      if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
        return vm._props[key];
      }
      return isFunction3(def4) && getType2(prop.type) !== "Function" ? def4.call(vm) : def4;
    }
    function assertProp2(prop, name, value, vm, absent) {
      if (prop.required && absent) {
        warn3('Missing required prop: "' + name + '"', vm);
        return;
      }
      if (value == null && !prop.required) {
        return;
      }
      let type = prop.type;
      let valid = !type || type === true;
      const expectedTypes = [];
      if (type) {
        if (!isArray3(type)) {
          type = [type];
        }
        for (let i = 0; i < type.length && !valid; i++) {
          const assertedType = assertType2(value, type[i], vm);
          expectedTypes.push(assertedType.expectedType || "");
          valid = assertedType.valid;
        }
      }
      const haveExpectedTypes = expectedTypes.some((t) => t);
      if (!valid && haveExpectedTypes) {
        warn3(getInvalidTypeMessage2(name, value, expectedTypes), vm);
        return;
      }
      const validator = prop.validator;
      if (validator) {
        if (!validator(value)) {
          warn3('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
      }
    }
    var simpleCheckRE2 = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
    function assertType2(value, type, vm) {
      let valid;
      const expectedType = getType2(type);
      if (simpleCheckRE2.test(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type;
        }
      } else if (expectedType === "Object") {
        valid = isPlainObject3(value);
      } else if (expectedType === "Array") {
        valid = isArray3(value);
      } else {
        try {
          valid = value instanceof type;
        } catch (e) {
          warn3('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
          valid = false;
        }
      }
      return {
        valid,
        expectedType
      };
    }
    var functionTypeCheckRE2 = /^\s*function (\w+)/;
    function getType2(fn) {
      const match = fn && fn.toString().match(functionTypeCheckRE2);
      return match ? match[1] : "";
    }
    function isSameType2(a, b) {
      return getType2(a) === getType2(b);
    }
    function getTypeIndex2(type, expectedTypes) {
      if (!isArray3(expectedTypes)) {
        return isSameType2(expectedTypes, type) ? 0 : -1;
      }
      for (let i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType2(expectedTypes[i], type)) {
          return i;
        }
      }
      return -1;
    }
    function getInvalidTypeMessage2(name, value, expectedTypes) {
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize2).join(", ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType2(value);
      if (expectedTypes.length === 1 && isExplicable2(expectedType) && isExplicable2(typeof value) && !isBoolean2(expectedType, receivedType)) {
        message += ` with value ${styleValue2(value, expectedType)}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable2(receivedType)) {
        message += `with value ${styleValue2(value, receivedType)}.`;
      }
      return message;
    }
    function styleValue2(value, type) {
      if (type === "String") {
        return `"${value}"`;
      } else if (type === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    var EXPLICABLE_TYPES2 = ["string", "number", "boolean"];
    function isExplicable2(value) {
      return EXPLICABLE_TYPES2.some((elem) => value.toLowerCase() === elem);
    }
    function isBoolean2(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    var initProxy2;
    {
      const allowedGlobals = makeMap2("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
      const warnNonPresent = (target3, key) => {
        warn3(`Property or method "${key}" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.`, target3);
      };
      const warnReservedPrefix = (target3, key) => {
        warn3(`Property "${key}" must be accessed with "$data.${key}" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data`, target3);
      };
      const hasProxy = typeof Proxy !== "undefined" && isNative3(Proxy);
      if (hasProxy) {
        const isBuiltInModifier = makeMap2("stop,prevent,self,ctrl,shift,alt,meta,exact");
        config2.keyCodes = new Proxy(config2.keyCodes, {
          set(target3, key, value) {
            if (isBuiltInModifier(key)) {
              warn3(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);
              return false;
            } else {
              target3[key] = value;
              return true;
            }
          }
        });
      }
      const hasHandler = {
        has(target3, key) {
          const has3 = key in target3;
          const isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target3.$data);
          if (!has3 && !isAllowed) {
            if (key in target3.$data)
              warnReservedPrefix(target3, key);
            else
              warnNonPresent(target3, key);
          }
          return has3 || !isAllowed;
        }
      };
      const getHandler = {
        get(target3, key) {
          if (typeof key === "string" && !(key in target3)) {
            if (key in target3.$data)
              warnReservedPrefix(target3, key);
            else
              warnNonPresent(target3, key);
          }
          return target3[key];
        }
      };
      initProxy2 = function initProxy3(vm) {
        if (hasProxy) {
          const options = vm.$options;
          const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
          vm._renderProxy = new Proxy(vm, handlers);
        } else {
          vm._renderProxy = vm;
        }
      };
    }
    var sharedPropertyDefinition2 = {
      enumerable: true,
      configurable: true,
      get: noop2,
      set: noop2
    };
    function proxy3(target3, sourceKey, key) {
      sharedPropertyDefinition2.get = function proxyGetter() {
        return this[sourceKey][key];
      };
      sharedPropertyDefinition2.set = function proxySetter(val) {
        this[sourceKey][key] = val;
      };
      Object.defineProperty(target3, key, sharedPropertyDefinition2);
    }
    function initState2(vm) {
      const opts = vm.$options;
      if (opts.props)
        initProps$12(vm, opts.props);
      initSetup2(vm);
      if (opts.methods)
        initMethods2(vm, opts.methods);
      if (opts.data) {
        initData2(vm);
      } else {
        const ob = observe3(vm._data = {});
        ob && ob.vmCount++;
      }
      if (opts.computed)
        initComputed$12(vm, opts.computed);
      if (opts.watch && opts.watch !== nativeWatch2) {
        initWatch2(vm, opts.watch);
      }
    }
    function initProps$12(vm, propsOptions) {
      const propsData = vm.$options.propsData || {};
      const props3 = vm._props = shallowReactive3({});
      const keys = vm.$options._propKeys = [];
      const isRoot = !vm.$parent;
      if (!isRoot) {
        toggleObserving2(false);
      }
      for (const key in propsOptions) {
        keys.push(key);
        const value = validateProp2(key, propsOptions, propsData, vm);
        {
          const hyphenatedKey = hyphenate2(key);
          if (isReservedAttribute2(hyphenatedKey) || config2.isReservedAttr(hyphenatedKey)) {
            warn3(`"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`, vm);
          }
          defineReactive2(props3, key, value, () => {
            if (!isRoot && !isUpdatingChildComponent2) {
              warn3(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "${key}"`, vm);
            }
          });
        }
        if (!(key in vm)) {
          proxy3(vm, `_props`, key);
        }
      }
      toggleObserving2(true);
    }
    function initData2(vm) {
      let data = vm.$options.data;
      data = vm._data = isFunction3(data) ? getData2(data, vm) : data || {};
      if (!isPlainObject3(data)) {
        data = {};
        warn3("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
      }
      const keys = Object.keys(data);
      const props3 = vm.$options.props;
      const methods = vm.$options.methods;
      let i = keys.length;
      while (i--) {
        const key = keys[i];
        {
          if (methods && hasOwn3(methods, key)) {
            warn3(`Method "${key}" has already been defined as a data property.`, vm);
          }
        }
        if (props3 && hasOwn3(props3, key)) {
          warn3(`The data property "${key}" is already declared as a prop. Use prop default value instead.`, vm);
        } else if (!isReserved2(key)) {
          proxy3(vm, `_data`, key);
        }
      }
      const ob = observe3(data);
      ob && ob.vmCount++;
    }
    function getData2(data, vm) {
      pushTarget2();
      try {
        return data.call(vm, vm);
      } catch (e) {
        handleError2(e, vm, `data()`);
        return {};
      } finally {
        popTarget2();
      }
    }
    var computedWatcherOptions2 = { lazy: true };
    function initComputed$12(vm, computed3) {
      const watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
      const isSSR = isServerRendering2();
      for (const key in computed3) {
        const userDef = computed3[key];
        const getter = isFunction3(userDef) ? userDef : userDef.get;
        if (getter == null) {
          warn3(`Getter is missing for computed property "${key}".`, vm);
        }
        if (!isSSR) {
          watchers[key] = new Watcher2(vm, getter || noop2, noop2, computedWatcherOptions2);
        }
        if (!(key in vm)) {
          defineComputed2(vm, key, userDef);
        } else {
          if (key in vm.$data) {
            warn3(`The computed property "${key}" is already defined in data.`, vm);
          } else if (vm.$options.props && key in vm.$options.props) {
            warn3(`The computed property "${key}" is already defined as a prop.`, vm);
          } else if (vm.$options.methods && key in vm.$options.methods) {
            warn3(`The computed property "${key}" is already defined as a method.`, vm);
          }
        }
      }
    }
    function defineComputed2(target3, key, userDef) {
      const shouldCache = !isServerRendering2();
      if (isFunction3(userDef)) {
        sharedPropertyDefinition2.get = shouldCache ? createComputedGetter2(key) : createGetterInvoker2(userDef);
        sharedPropertyDefinition2.set = noop2;
      } else {
        sharedPropertyDefinition2.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter2(key) : createGetterInvoker2(userDef.get) : noop2;
        sharedPropertyDefinition2.set = userDef.set || noop2;
      }
      if (sharedPropertyDefinition2.set === noop2) {
        sharedPropertyDefinition2.set = function() {
          warn3(`Computed property "${key}" was assigned to but it has no setter.`, this);
        };
      }
      Object.defineProperty(target3, key, sharedPropertyDefinition2);
    }
    function createComputedGetter2(key) {
      return function computedGetter() {
        const watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
          if (watcher.dirty) {
            watcher.evaluate();
          }
          if (Dep2.target) {
            if (Dep2.target.onTrack) {
              Dep2.target.onTrack({
                effect: Dep2.target,
                target: this,
                type: "get",
                key
              });
            }
            watcher.depend();
          }
          return watcher.value;
        }
      };
    }
    function createGetterInvoker2(fn) {
      return function computedGetter() {
        return fn.call(this, this);
      };
    }
    function initMethods2(vm, methods) {
      const props3 = vm.$options.props;
      for (const key in methods) {
        {
          if (typeof methods[key] !== "function") {
            warn3(`Method "${key}" has type "${typeof methods[key]}" in the component definition. Did you reference the function correctly?`, vm);
          }
          if (props3 && hasOwn3(props3, key)) {
            warn3(`Method "${key}" has already been defined as a prop.`, vm);
          }
          if (key in vm && isReserved2(key)) {
            warn3(`Method "${key}" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.`);
          }
        }
        vm[key] = typeof methods[key] !== "function" ? noop2 : bind2(methods[key], vm);
      }
    }
    function initWatch2(vm, watch3) {
      for (const key in watch3) {
        const handler = watch3[key];
        if (isArray3(handler)) {
          for (let i = 0; i < handler.length; i++) {
            createWatcher3(vm, key, handler[i]);
          }
        } else {
          createWatcher3(vm, key, handler);
        }
      }
    }
    function createWatcher3(vm, expOrFn, handler, options) {
      if (isPlainObject3(handler)) {
        options = handler;
        handler = handler.handler;
      }
      if (typeof handler === "string") {
        handler = vm[handler];
      }
      return vm.$watch(expOrFn, handler, options);
    }
    function stateMixin2(Vue4) {
      const dataDef = {};
      dataDef.get = function() {
        return this._data;
      };
      const propsDef = {};
      propsDef.get = function() {
        return this._props;
      };
      {
        dataDef.set = function() {
          warn3("Avoid replacing instance root $data. Use nested data properties instead.", this);
        };
        propsDef.set = function() {
          warn3(`$props is readonly.`, this);
        };
      }
      Object.defineProperty(Vue4.prototype, "$data", dataDef);
      Object.defineProperty(Vue4.prototype, "$props", propsDef);
      Vue4.prototype.$set = set3;
      Vue4.prototype.$delete = del3;
      Vue4.prototype.$watch = function(expOrFn, cb, options) {
        const vm = this;
        if (isPlainObject3(cb)) {
          return createWatcher3(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        const watcher = new Watcher2(vm, expOrFn, cb, options);
        if (options.immediate) {
          const info = `callback for immediate watcher "${watcher.expression}"`;
          pushTarget2();
          invokeWithErrorHandling2(cb, vm, [watcher.value], vm, info);
          popTarget2();
        }
        return function unwatchFn() {
          watcher.teardown();
        };
      };
    }
    var uid2 = 0;
    function initMixin$12(Vue4) {
      Vue4.prototype._init = function(options) {
        const vm = this;
        vm._uid = uid2++;
        let startTag, endTag;
        if (config2.performance && mark2) {
          startTag = `vue-perf-start:${vm._uid}`;
          endTag = `vue-perf-end:${vm._uid}`;
          mark2(startTag);
        }
        vm._isVue = true;
        vm.__v_skip = true;
        vm._scope = new EffectScope3(true);
        if (options && options._isComponent) {
          initInternalComponent2(vm, options);
        } else {
          vm.$options = mergeOptions2(resolveConstructorOptions2(vm.constructor), options || {}, vm);
        }
        {
          initProxy2(vm);
        }
        vm._self = vm;
        initLifecycle2(vm);
        initEvents2(vm);
        initRender2(vm);
        callHook$12(vm, "beforeCreate", void 0, false);
        initInjections2(vm);
        initState2(vm);
        initProvide2(vm);
        callHook$12(vm, "created");
        if (config2.performance && mark2) {
          vm._name = formatComponentName2(vm, false);
          mark2(endTag);
          measure2(`vue ${vm._name} init`, startTag, endTag);
        }
        if (vm.$options.el) {
          vm.$mount(vm.$options.el);
        }
      };
    }
    function initInternalComponent2(vm, options) {
      const opts = vm.$options = Object.create(vm.constructor.options);
      const parentVnode = options._parentVnode;
      opts.parent = options.parent;
      opts._parentVnode = parentVnode;
      const vnodeComponentOptions = parentVnode.componentOptions;
      opts.propsData = vnodeComponentOptions.propsData;
      opts._parentListeners = vnodeComponentOptions.listeners;
      opts._renderChildren = vnodeComponentOptions.children;
      opts._componentTag = vnodeComponentOptions.tag;
      if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
      }
    }
    function resolveConstructorOptions2(Ctor) {
      let options = Ctor.options;
      if (Ctor.super) {
        const superOptions = resolveConstructorOptions2(Ctor.super);
        const cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
          Ctor.superOptions = superOptions;
          const modifiedOptions = resolveModifiedOptions2(Ctor);
          if (modifiedOptions) {
            extend2(Ctor.extendOptions, modifiedOptions);
          }
          options = Ctor.options = mergeOptions2(superOptions, Ctor.extendOptions);
          if (options.name) {
            options.components[options.name] = Ctor;
          }
        }
      }
      return options;
    }
    function resolveModifiedOptions2(Ctor) {
      let modified;
      const latest = Ctor.options;
      const sealed = Ctor.sealedOptions;
      for (const key in latest) {
        if (latest[key] !== sealed[key]) {
          if (!modified)
            modified = {};
          modified[key] = latest[key];
        }
      }
      return modified;
    }
    function Vue3(options) {
      if (!(this instanceof Vue3)) {
        warn3("Vue is a constructor and should be called with the `new` keyword");
      }
      this._init(options);
    }
    initMixin$12(Vue3);
    stateMixin2(Vue3);
    eventsMixin2(Vue3);
    lifecycleMixin2(Vue3);
    renderMixin2(Vue3);
    function initUse2(Vue4) {
      Vue4.use = function(plugin) {
        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
          return this;
        }
        const args = toArray2(arguments, 1);
        args.unshift(this);
        if (isFunction3(plugin.install)) {
          plugin.install.apply(plugin, args);
        } else if (isFunction3(plugin)) {
          plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
      };
    }
    function initMixin2(Vue4) {
      Vue4.mixin = function(mixin2) {
        this.options = mergeOptions2(this.options, mixin2);
        return this;
      };
    }
    function initExtend2(Vue4) {
      Vue4.cid = 0;
      let cid = 1;
      Vue4.extend = function(extendOptions) {
        extendOptions = extendOptions || {};
        const Super = this;
        const SuperId = Super.cid;
        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
          return cachedCtors[SuperId];
        }
        const name = getComponentName2(extendOptions) || getComponentName2(Super.options);
        if (name) {
          validateComponentName2(name);
        }
        const Sub = function VueComponent(options) {
          this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions2(Super.options, extendOptions);
        Sub["super"] = Super;
        if (Sub.options.props) {
          initProps2(Sub);
        }
        if (Sub.options.computed) {
          initComputed2(Sub);
        }
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        ASSET_TYPES2.forEach(function(type) {
          Sub[type] = Super[type];
        });
        if (name) {
          Sub.options.components[name] = Sub;
        }
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend2({}, Sub.options);
        cachedCtors[SuperId] = Sub;
        return Sub;
      };
    }
    function initProps2(Comp) {
      const props3 = Comp.options.props;
      for (const key in props3) {
        proxy3(Comp.prototype, `_props`, key);
      }
    }
    function initComputed2(Comp) {
      const computed3 = Comp.options.computed;
      for (const key in computed3) {
        defineComputed2(Comp.prototype, key, computed3[key]);
      }
    }
    function initAssetRegisters2(Vue4) {
      ASSET_TYPES2.forEach((type) => {
        Vue4[type] = function(id, definition) {
          if (!definition) {
            return this.options[type + "s"][id];
          } else {
            if (type === "component") {
              validateComponentName2(id);
            }
            if (type === "component" && isPlainObject3(definition)) {
              definition.name = definition.name || id;
              definition = this.options._base.extend(definition);
            }
            if (type === "directive" && isFunction3(definition)) {
              definition = { bind: definition, update: definition };
            }
            this.options[type + "s"][id] = definition;
            return definition;
          }
        };
      });
    }
    function _getComponentName2(opts) {
      return opts && (getComponentName2(opts.Ctor.options) || opts.tag);
    }
    function matches2(pattern, name) {
      if (isArray3(pattern)) {
        return pattern.indexOf(name) > -1;
      } else if (typeof pattern === "string") {
        return pattern.split(",").indexOf(name) > -1;
      } else if (isRegExp2(pattern)) {
        return pattern.test(name);
      }
      return false;
    }
    function pruneCache2(keepAliveInstance, filter) {
      const { cache, keys, _vnode } = keepAliveInstance;
      for (const key in cache) {
        const entry = cache[key];
        if (entry) {
          const name = entry.name;
          if (name && !filter(name)) {
            pruneCacheEntry2(cache, key, keys, _vnode);
          }
        }
      }
    }
    function pruneCacheEntry2(cache, key, keys, current) {
      const entry = cache[key];
      if (entry && (!current || entry.tag !== current.tag)) {
        entry.componentInstance.$destroy();
      }
      cache[key] = null;
      remove$22(keys, key);
    }
    var patternTypes2 = [String, RegExp, Array];
    var KeepAlive2 = {
      name: "keep-alive",
      abstract: true,
      props: {
        include: patternTypes2,
        exclude: patternTypes2,
        max: [String, Number]
      },
      methods: {
        cacheVNode() {
          const { cache, keys, vnodeToCache, keyToCache } = this;
          if (vnodeToCache) {
            const { tag, componentInstance, componentOptions } = vnodeToCache;
            cache[keyToCache] = {
              name: _getComponentName2(componentOptions),
              tag,
              componentInstance
            };
            keys.push(keyToCache);
            if (this.max && keys.length > parseInt(this.max)) {
              pruneCacheEntry2(cache, keys[0], keys, this._vnode);
            }
            this.vnodeToCache = null;
          }
        }
      },
      created() {
        this.cache = /* @__PURE__ */ Object.create(null);
        this.keys = [];
      },
      destroyed() {
        for (const key in this.cache) {
          pruneCacheEntry2(this.cache, key, this.keys);
        }
      },
      mounted() {
        this.cacheVNode();
        this.$watch("include", (val) => {
          pruneCache2(this, (name) => matches2(val, name));
        });
        this.$watch("exclude", (val) => {
          pruneCache2(this, (name) => !matches2(val, name));
        });
      },
      updated() {
        this.cacheVNode();
      },
      render() {
        const slot = this.$slots.default;
        const vnode = getFirstComponentChild2(slot);
        const componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
          const name = _getComponentName2(componentOptions);
          const { include, exclude } = this;
          if (include && (!name || !matches2(include, name)) || exclude && name && matches2(exclude, name)) {
            return vnode;
          }
          const { cache, keys } = this;
          const key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : "") : vnode.key;
          if (cache[key]) {
            vnode.componentInstance = cache[key].componentInstance;
            remove$22(keys, key);
            keys.push(key);
          } else {
            this.vnodeToCache = vnode;
            this.keyToCache = key;
          }
          vnode.data.keepAlive = true;
        }
        return vnode || slot && slot[0];
      }
    };
    var builtInComponents2 = {
      KeepAlive: KeepAlive2
    };
    function initGlobalAPI2(Vue4) {
      const configDef = {};
      configDef.get = () => config2;
      {
        configDef.set = () => {
          warn3("Do not replace the Vue.config object, set individual fields instead.");
        };
      }
      Object.defineProperty(Vue4, "config", configDef);
      Vue4.util = {
        warn: warn3,
        extend: extend2,
        mergeOptions: mergeOptions2,
        defineReactive: defineReactive2
      };
      Vue4.set = set3;
      Vue4.delete = del3;
      Vue4.nextTick = nextTick4;
      Vue4.observable = (obj) => {
        observe3(obj);
        return obj;
      };
      Vue4.options = /* @__PURE__ */ Object.create(null);
      ASSET_TYPES2.forEach((type) => {
        Vue4.options[type + "s"] = /* @__PURE__ */ Object.create(null);
      });
      Vue4.options._base = Vue4;
      extend2(Vue4.options.components, builtInComponents2);
      initUse2(Vue4);
      initMixin2(Vue4);
      initExtend2(Vue4);
      initAssetRegisters2(Vue4);
    }
    initGlobalAPI2(Vue3);
    Object.defineProperty(Vue3.prototype, "$isServer", {
      get: isServerRendering2
    });
    Object.defineProperty(Vue3.prototype, "$ssrContext", {
      get() {
        return this.$vnode && this.$vnode.ssrContext;
      }
    });
    Object.defineProperty(Vue3, "FunctionalRenderContext", {
      value: FunctionalRenderContext2
    });
    Vue3.version = version3;
    var isReservedAttr2 = makeMap2("style,class");
    var acceptValue2 = makeMap2("input,textarea,option,select,progress");
    var mustUseProp2 = (tag, type, attr) => {
      return attr === "value" && acceptValue2(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
    };
    var isEnumeratedAttr2 = makeMap2("contenteditable,draggable,spellcheck");
    var isValidContentEditableValue2 = makeMap2("events,caret,typing,plaintext-only");
    var convertEnumeratedValue2 = (key, value) => {
      return isFalsyAttrValue2(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue2(value) ? value : "true";
    };
    var isBooleanAttr2 = makeMap2("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
    var xlinkNS2 = "http://www.w3.org/1999/xlink";
    var isXlink2 = (name) => {
      return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
    };
    var getXlinkProp2 = (name) => {
      return isXlink2(name) ? name.slice(6, name.length) : "";
    };
    var isFalsyAttrValue2 = (val) => {
      return val == null || val === false;
    };
    function genClassForVnode2(vnode) {
      let data = vnode.data;
      let parentNode3 = vnode;
      let childNode = vnode;
      while (isDef2(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
          data = mergeClassData2(childNode.data, data);
        }
      }
      while (isDef2(parentNode3 = parentNode3.parent)) {
        if (parentNode3 && parentNode3.data) {
          data = mergeClassData2(data, parentNode3.data);
        }
      }
      return renderClass2(data.staticClass, data.class);
    }
    function mergeClassData2(child, parent) {
      return {
        staticClass: concat2(child.staticClass, parent.staticClass),
        class: isDef2(child.class) ? [child.class, parent.class] : parent.class
      };
    }
    function renderClass2(staticClass, dynamicClass) {
      if (isDef2(staticClass) || isDef2(dynamicClass)) {
        return concat2(staticClass, stringifyClass2(dynamicClass));
      }
      return "";
    }
    function concat2(a, b) {
      return a ? b ? a + " " + b : a : b || "";
    }
    function stringifyClass2(value) {
      if (Array.isArray(value)) {
        return stringifyArray2(value);
      }
      if (isObject3(value)) {
        return stringifyObject2(value);
      }
      if (typeof value === "string") {
        return value;
      }
      return "";
    }
    function stringifyArray2(value) {
      let res = "";
      let stringified;
      for (let i = 0, l = value.length; i < l; i++) {
        if (isDef2(stringified = stringifyClass2(value[i])) && stringified !== "") {
          if (res)
            res += " ";
          res += stringified;
        }
      }
      return res;
    }
    function stringifyObject2(value) {
      let res = "";
      for (const key in value) {
        if (value[key]) {
          if (res)
            res += " ";
          res += key;
        }
      }
      return res;
    }
    var namespaceMap2 = {
      svg: "http://www.w3.org/2000/svg",
      math: "http://www.w3.org/1998/Math/MathML"
    };
    var isHTMLTag2 = makeMap2("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
    var isSVG2 = makeMap2("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
    var isReservedTag2 = (tag) => {
      return isHTMLTag2(tag) || isSVG2(tag);
    };
    function getTagNamespace2(tag) {
      if (isSVG2(tag)) {
        return "svg";
      }
      if (tag === "math") {
        return "math";
      }
    }
    var unknownElementCache2 = /* @__PURE__ */ Object.create(null);
    function isUnknownElement2(tag) {
      if (!inBrowser2) {
        return true;
      }
      if (isReservedTag2(tag)) {
        return false;
      }
      tag = tag.toLowerCase();
      if (unknownElementCache2[tag] != null) {
        return unknownElementCache2[tag];
      }
      const el = document.createElement(tag);
      if (tag.indexOf("-") > -1) {
        return unknownElementCache2[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
      } else {
        return unknownElementCache2[tag] = /HTMLUnknownElement/.test(el.toString());
      }
    }
    var isTextInputType2 = makeMap2("text,number,password,search,email,tel,url");
    function query2(el) {
      if (typeof el === "string") {
        const selected = document.querySelector(el);
        if (!selected) {
          warn3("Cannot find element: " + el);
          return document.createElement("div");
        }
        return selected;
      } else {
        return el;
      }
    }
    function createElement4(tagName3, vnode) {
      const elm = document.createElement(tagName3);
      if (tagName3 !== "select") {
        return elm;
      }
      if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
        elm.setAttribute("multiple", "multiple");
      }
      return elm;
    }
    function createElementNS2(namespace, tagName3) {
      return document.createElementNS(namespaceMap2[namespace], tagName3);
    }
    function createTextNode2(text) {
      return document.createTextNode(text);
    }
    function createComment2(text) {
      return document.createComment(text);
    }
    function insertBefore2(parentNode3, newNode, referenceNode) {
      parentNode3.insertBefore(newNode, referenceNode);
    }
    function removeChild2(node, child) {
      node.removeChild(child);
    }
    function appendChild2(node, child) {
      node.appendChild(child);
    }
    function parentNode2(node) {
      return node.parentNode;
    }
    function nextSibling2(node) {
      return node.nextSibling;
    }
    function tagName2(node) {
      return node.tagName;
    }
    function setTextContent2(node, text) {
      node.textContent = text;
    }
    function setStyleScope2(node, scopeId) {
      node.setAttribute(scopeId, "");
    }
    var nodeOps2 = Object.freeze({
      __proto__: null,
      createElement: createElement4,
      createElementNS: createElementNS2,
      createTextNode: createTextNode2,
      createComment: createComment2,
      insertBefore: insertBefore2,
      removeChild: removeChild2,
      appendChild: appendChild2,
      parentNode: parentNode2,
      nextSibling: nextSibling2,
      tagName: tagName2,
      setTextContent: setTextContent2,
      setStyleScope: setStyleScope2
    });
    var ref3 = {
      create(_, vnode) {
        registerRef2(vnode);
      },
      update(oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
          registerRef2(oldVnode, true);
          registerRef2(vnode);
        }
      },
      destroy(vnode) {
        registerRef2(vnode, true);
      }
    };
    function registerRef2(vnode, isRemoval) {
      const ref4 = vnode.data.ref;
      if (!isDef2(ref4))
        return;
      const vm = vnode.context;
      const refValue = vnode.componentInstance || vnode.elm;
      const value = isRemoval ? null : refValue;
      const $refsValue = isRemoval ? void 0 : refValue;
      if (isFunction3(ref4)) {
        invokeWithErrorHandling2(ref4, vm, [value], vm, `template ref function`);
        return;
      }
      const isFor = vnode.data.refInFor;
      const _isString = typeof ref4 === "string" || typeof ref4 === "number";
      const _isRef = isRef3(ref4);
      const refs = vm.$refs;
      if (_isString || _isRef) {
        if (isFor) {
          const existing = _isString ? refs[ref4] : ref4.value;
          if (isRemoval) {
            isArray3(existing) && remove$22(existing, refValue);
          } else {
            if (!isArray3(existing)) {
              if (_isString) {
                refs[ref4] = [refValue];
                setSetupRef2(vm, ref4, refs[ref4]);
              } else {
                ref4.value = [refValue];
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          if (isRemoval && refs[ref4] !== refValue) {
            return;
          }
          refs[ref4] = $refsValue;
          setSetupRef2(vm, ref4, value);
        } else if (_isRef) {
          if (isRemoval && ref4.value !== refValue) {
            return;
          }
          ref4.value = value;
        } else {
          warn3(`Invalid template ref type: ${typeof ref4}`);
        }
      }
    }
    function setSetupRef2({ _setupState }, key, val) {
      if (_setupState && hasOwn3(_setupState, key)) {
        if (isRef3(_setupState[key])) {
          _setupState[key].value = val;
        } else {
          _setupState[key] = val;
        }
      }
    }
    var emptyNode2 = new VNode2("", {}, []);
    var hooks2 = ["create", "activate", "update", "remove", "destroy"];
    function sameVnode2(a, b) {
      return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef2(a.data) === isDef2(b.data) && sameInputType2(a, b) || isTrue2(a.isAsyncPlaceholder) && isUndef3(b.asyncFactory.error));
    }
    function sameInputType2(a, b) {
      if (a.tag !== "input")
        return true;
      let i;
      const typeA = isDef2(i = a.data) && isDef2(i = i.attrs) && i.type;
      const typeB = isDef2(i = b.data) && isDef2(i = i.attrs) && i.type;
      return typeA === typeB || isTextInputType2(typeA) && isTextInputType2(typeB);
    }
    function createKeyToOldIdx2(children, beginIdx, endIdx) {
      let i, key;
      const map = {};
      for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef2(key))
          map[key] = i;
      }
      return map;
    }
    function createPatchFunction2(backend) {
      let i, j;
      const cbs = {};
      const { modules: modules3, nodeOps: nodeOps3 } = backend;
      for (i = 0; i < hooks2.length; ++i) {
        cbs[hooks2[i]] = [];
        for (j = 0; j < modules3.length; ++j) {
          if (isDef2(modules3[j][hooks2[i]])) {
            cbs[hooks2[i]].push(modules3[j][hooks2[i]]);
          }
        }
      }
      function emptyNodeAt(elm) {
        return new VNode2(nodeOps3.tagName(elm).toLowerCase(), {}, [], void 0, elm);
      }
      function createRmCb(childElm, listeners) {
        function remove3() {
          if (--remove3.listeners === 0) {
            removeNode(childElm);
          }
        }
        remove3.listeners = listeners;
        return remove3;
      }
      function removeNode(el) {
        const parent = nodeOps3.parentNode(el);
        if (isDef2(parent)) {
          nodeOps3.removeChild(parent, el);
        }
      }
      function isUnknownElement3(vnode, inVPre) {
        return !inVPre && !vnode.ns && !(config2.ignoredElements.length && config2.ignoredElements.some((ignore) => {
          return isRegExp2(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
        })) && config2.isUnknownElement(vnode.tag);
      }
      let creatingElmInVPre = 0;
      function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index3) {
        if (isDef2(vnode.elm) && isDef2(ownerArray)) {
          vnode = ownerArray[index3] = cloneVNode2(vnode);
        }
        vnode.isRootInsert = !nested;
        if (createComponent3(vnode, insertedVnodeQueue, parentElm, refElm)) {
          return;
        }
        const data = vnode.data;
        const children = vnode.children;
        const tag = vnode.tag;
        if (isDef2(tag)) {
          {
            if (data && data.pre) {
              creatingElmInVPre++;
            }
            if (isUnknownElement3(vnode, creatingElmInVPre)) {
              warn3("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
            }
          }
          vnode.elm = vnode.ns ? nodeOps3.createElementNS(vnode.ns, tag) : nodeOps3.createElement(tag, vnode);
          setScope(vnode);
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef2(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
          if (data && data.pre) {
            creatingElmInVPre--;
          }
        } else if (isTrue2(vnode.isComment)) {
          vnode.elm = nodeOps3.createComment(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        } else {
          vnode.elm = nodeOps3.createTextNode(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        }
      }
      function createComponent3(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i2 = vnode.data;
        if (isDef2(i2)) {
          const isReactivated = isDef2(vnode.componentInstance) && i2.keepAlive;
          if (isDef2(i2 = i2.hook) && isDef2(i2 = i2.init)) {
            i2(vnode, false);
          }
          if (isDef2(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            insert(parentElm, vnode.elm, refElm);
            if (isTrue2(isReactivated)) {
              reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
            }
            return true;
          }
        }
      }
      function initComponent(vnode, insertedVnodeQueue) {
        if (isDef2(vnode.data.pendingInsert)) {
          insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
          vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
          setScope(vnode);
        } else {
          registerRef2(vnode);
          insertedVnodeQueue.push(vnode);
        }
      }
      function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i2;
        let innerNode = vnode;
        while (innerNode.componentInstance) {
          innerNode = innerNode.componentInstance._vnode;
          if (isDef2(i2 = innerNode.data) && isDef2(i2 = i2.transition)) {
            for (i2 = 0; i2 < cbs.activate.length; ++i2) {
              cbs.activate[i2](emptyNode2, innerNode);
            }
            insertedVnodeQueue.push(innerNode);
            break;
          }
        }
        insert(parentElm, vnode.elm, refElm);
      }
      function insert(parent, elm, ref4) {
        if (isDef2(parent)) {
          if (isDef2(ref4)) {
            if (nodeOps3.parentNode(ref4) === parent) {
              nodeOps3.insertBefore(parent, elm, ref4);
            }
          } else {
            nodeOps3.appendChild(parent, elm);
          }
        }
      }
      function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray3(children)) {
          {
            checkDuplicateKeys(children);
          }
          for (let i2 = 0; i2 < children.length; ++i2) {
            createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
          }
        } else if (isPrimitive3(vnode.text)) {
          nodeOps3.appendChild(vnode.elm, nodeOps3.createTextNode(String(vnode.text)));
        }
      }
      function isPatchable(vnode) {
        while (vnode.componentInstance) {
          vnode = vnode.componentInstance._vnode;
        }
        return isDef2(vnode.tag);
      }
      function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (let i2 = 0; i2 < cbs.create.length; ++i2) {
          cbs.create[i2](emptyNode2, vnode);
        }
        i = vnode.data.hook;
        if (isDef2(i)) {
          if (isDef2(i.create))
            i.create(emptyNode2, vnode);
          if (isDef2(i.insert))
            insertedVnodeQueue.push(vnode);
        }
      }
      function setScope(vnode) {
        let i2;
        if (isDef2(i2 = vnode.fnScopeId)) {
          nodeOps3.setStyleScope(vnode.elm, i2);
        } else {
          let ancestor = vnode;
          while (ancestor) {
            if (isDef2(i2 = ancestor.context) && isDef2(i2 = i2.$options._scopeId)) {
              nodeOps3.setStyleScope(vnode.elm, i2);
            }
            ancestor = ancestor.parent;
          }
        }
        if (isDef2(i2 = activeInstance2) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef2(i2 = i2.$options._scopeId)) {
          nodeOps3.setStyleScope(vnode.elm, i2);
        }
      }
      function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
          createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
      }
      function invokeDestroyHook(vnode) {
        let i2, j2;
        const data = vnode.data;
        if (isDef2(data)) {
          if (isDef2(i2 = data.hook) && isDef2(i2 = i2.destroy))
            i2(vnode);
          for (i2 = 0; i2 < cbs.destroy.length; ++i2)
            cbs.destroy[i2](vnode);
        }
        if (isDef2(i2 = vnode.children)) {
          for (j2 = 0; j2 < vnode.children.length; ++j2) {
            invokeDestroyHook(vnode.children[j2]);
          }
        }
      }
      function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
          const ch = vnodes[startIdx];
          if (isDef2(ch)) {
            if (isDef2(ch.tag)) {
              removeAndInvokeRemoveHook(ch);
              invokeDestroyHook(ch);
            } else {
              removeNode(ch.elm);
            }
          }
        }
      }
      function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef2(rm) || isDef2(vnode.data)) {
          let i2;
          const listeners = cbs.remove.length + 1;
          if (isDef2(rm)) {
            rm.listeners += listeners;
          } else {
            rm = createRmCb(vnode.elm, listeners);
          }
          if (isDef2(i2 = vnode.componentInstance) && isDef2(i2 = i2._vnode) && isDef2(i2.data)) {
            removeAndInvokeRemoveHook(i2, rm);
          }
          for (i2 = 0; i2 < cbs.remove.length; ++i2) {
            cbs.remove[i2](vnode, rm);
          }
          if (isDef2(i2 = vnode.data.hook) && isDef2(i2 = i2.remove)) {
            i2(vnode, rm);
          } else {
            rm();
          }
        } else {
          removeNode(vnode.elm);
        }
      }
      function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        const canMove = !removeOnly;
        {
          checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (isUndef3(oldStartVnode)) {
            oldStartVnode = oldCh[++oldStartIdx];
          } else if (isUndef3(oldEndVnode)) {
            oldEndVnode = oldCh[--oldEndIdx];
          } else if (sameVnode2(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
          } else if (sameVnode2(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode2(oldStartVnode, newEndVnode)) {
            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            canMove && nodeOps3.insertBefore(parentElm, oldStartVnode.elm, nodeOps3.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode2(oldEndVnode, newStartVnode)) {
            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            canMove && nodeOps3.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
          } else {
            if (isUndef3(oldKeyToIdx))
              oldKeyToIdx = createKeyToOldIdx2(oldCh, oldStartIdx, oldEndIdx);
            idxInOld = isDef2(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
            if (isUndef3(idxInOld)) {
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            } else {
              vnodeToMove = oldCh[idxInOld];
              if (sameVnode2(vnodeToMove, newStartVnode)) {
                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldCh[idxInOld] = void 0;
                canMove && nodeOps3.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
              } else {
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
              }
            }
            newStartVnode = newCh[++newStartIdx];
          }
        }
        if (oldStartIdx > oldEndIdx) {
          refElm = isUndef3(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
          addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
          removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
      }
      function checkDuplicateKeys(children) {
        const seenKeys = {};
        for (let i2 = 0; i2 < children.length; i2++) {
          const vnode = children[i2];
          const key = vnode.key;
          if (isDef2(key)) {
            if (seenKeys[key]) {
              warn3(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);
            } else {
              seenKeys[key] = true;
            }
          }
        }
      }
      function findIdxInOld(node, oldCh, start, end) {
        for (let i2 = start; i2 < end; i2++) {
          const c = oldCh[i2];
          if (isDef2(c) && sameVnode2(node, c))
            return i2;
        }
      }
      function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index3, removeOnly) {
        if (oldVnode === vnode) {
          return;
        }
        if (isDef2(vnode.elm) && isDef2(ownerArray)) {
          vnode = ownerArray[index3] = cloneVNode2(vnode);
        }
        const elm = vnode.elm = oldVnode.elm;
        if (isTrue2(oldVnode.isAsyncPlaceholder)) {
          if (isDef2(vnode.asyncFactory.resolved)) {
            hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
          } else {
            vnode.isAsyncPlaceholder = true;
          }
          return;
        }
        if (isTrue2(vnode.isStatic) && isTrue2(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue2(vnode.isCloned) || isTrue2(vnode.isOnce))) {
          vnode.componentInstance = oldVnode.componentInstance;
          return;
        }
        let i2;
        const data = vnode.data;
        if (isDef2(data) && isDef2(i2 = data.hook) && isDef2(i2 = i2.prepatch)) {
          i2(oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (isDef2(data) && isPatchable(vnode)) {
          for (i2 = 0; i2 < cbs.update.length; ++i2)
            cbs.update[i2](oldVnode, vnode);
          if (isDef2(i2 = data.hook) && isDef2(i2 = i2.update))
            i2(oldVnode, vnode);
        }
        if (isUndef3(vnode.text)) {
          if (isDef2(oldCh) && isDef2(ch)) {
            if (oldCh !== ch)
              updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          } else if (isDef2(ch)) {
            {
              checkDuplicateKeys(ch);
            }
            if (isDef2(oldVnode.text))
              nodeOps3.setTextContent(elm, "");
            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
          } else if (isDef2(oldCh)) {
            removeVnodes(oldCh, 0, oldCh.length - 1);
          } else if (isDef2(oldVnode.text)) {
            nodeOps3.setTextContent(elm, "");
          }
        } else if (oldVnode.text !== vnode.text) {
          nodeOps3.setTextContent(elm, vnode.text);
        }
        if (isDef2(data)) {
          if (isDef2(i2 = data.hook) && isDef2(i2 = i2.postpatch))
            i2(oldVnode, vnode);
        }
      }
      function invokeInsertHook(vnode, queue3, initial) {
        if (isTrue2(initial) && isDef2(vnode.parent)) {
          vnode.parent.data.pendingInsert = queue3;
        } else {
          for (let i2 = 0; i2 < queue3.length; ++i2) {
            queue3[i2].data.hook.insert(queue3[i2]);
          }
        }
      }
      let hydrationBailed = false;
      const isRenderedModule = makeMap2("attrs,class,staticClass,staticStyle,key");
      function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        let i2;
        const { tag, data, children } = vnode;
        inVPre = inVPre || data && data.pre;
        vnode.elm = elm;
        if (isTrue2(vnode.isComment) && isDef2(vnode.asyncFactory)) {
          vnode.isAsyncPlaceholder = true;
          return true;
        }
        {
          if (!assertNodeMatch(elm, vnode, inVPre)) {
            return false;
          }
        }
        if (isDef2(data)) {
          if (isDef2(i2 = data.hook) && isDef2(i2 = i2.init))
            i2(vnode, true);
          if (isDef2(i2 = vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            return true;
          }
        }
        if (isDef2(tag)) {
          if (isDef2(children)) {
            if (!elm.hasChildNodes()) {
              createChildren(vnode, children, insertedVnodeQueue);
            } else {
              if (isDef2(i2 = data) && isDef2(i2 = i2.domProps) && isDef2(i2 = i2.innerHTML)) {
                if (i2 !== elm.innerHTML) {
                  if (typeof console !== "undefined" && !hydrationBailed) {
                    hydrationBailed = true;
                    console.warn("Parent: ", elm);
                    console.warn("server innerHTML: ", i2);
                    console.warn("client innerHTML: ", elm.innerHTML);
                  }
                  return false;
                }
              } else {
                let childrenMatch = true;
                let childNode = elm.firstChild;
                for (let i3 = 0; i3 < children.length; i3++) {
                  if (!childNode || !hydrate(childNode, children[i3], insertedVnodeQueue, inVPre)) {
                    childrenMatch = false;
                    break;
                  }
                  childNode = childNode.nextSibling;
                }
                if (!childrenMatch || childNode) {
                  if (typeof console !== "undefined" && !hydrationBailed) {
                    hydrationBailed = true;
                    console.warn("Parent: ", elm);
                    console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                  }
                  return false;
                }
              }
            }
          }
          if (isDef2(data)) {
            let fullInvoke = false;
            for (const key in data) {
              if (!isRenderedModule(key)) {
                fullInvoke = true;
                invokeCreateHooks(vnode, insertedVnodeQueue);
                break;
              }
            }
            if (!fullInvoke && data["class"]) {
              traverse3(data["class"]);
            }
          }
        } else if (elm.data !== vnode.text) {
          elm.data = vnode.text;
        }
        return true;
      }
      function assertNodeMatch(node, vnode, inVPre) {
        if (isDef2(vnode.tag)) {
          return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement3(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
        } else {
          return node.nodeType === (vnode.isComment ? 8 : 3);
        }
      }
      return function patch3(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef3(vnode)) {
          if (isDef2(oldVnode))
            invokeDestroyHook(oldVnode);
          return;
        }
        let isInitialPatch = false;
        const insertedVnodeQueue = [];
        if (isUndef3(oldVnode)) {
          isInitialPatch = true;
          createElm(vnode, insertedVnodeQueue);
        } else {
          const isRealElement = isDef2(oldVnode.nodeType);
          if (!isRealElement && sameVnode2(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
          } else {
            if (isRealElement) {
              if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR2)) {
                oldVnode.removeAttribute(SSR_ATTR2);
                hydrating = true;
              }
              if (isTrue2(hydrating)) {
                if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                  invokeInsertHook(vnode, insertedVnodeQueue, true);
                  return oldVnode;
                } else {
                  warn3("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
                }
              }
              oldVnode = emptyNodeAt(oldVnode);
            }
            const oldElm = oldVnode.elm;
            const parentElm = nodeOps3.parentNode(oldElm);
            createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps3.nextSibling(oldElm));
            if (isDef2(vnode.parent)) {
              let ancestor = vnode.parent;
              const patchable = isPatchable(vnode);
              while (ancestor) {
                for (let i2 = 0; i2 < cbs.destroy.length; ++i2) {
                  cbs.destroy[i2](ancestor);
                }
                ancestor.elm = vnode.elm;
                if (patchable) {
                  for (let i2 = 0; i2 < cbs.create.length; ++i2) {
                    cbs.create[i2](emptyNode2, ancestor);
                  }
                  const insert2 = ancestor.data.hook.insert;
                  if (insert2.merged) {
                    for (let i2 = 1; i2 < insert2.fns.length; i2++) {
                      insert2.fns[i2]();
                    }
                  }
                } else {
                  registerRef2(ancestor);
                }
                ancestor = ancestor.parent;
              }
            }
            if (isDef2(parentElm)) {
              removeVnodes([oldVnode], 0, 0);
            } else if (isDef2(oldVnode.tag)) {
              invokeDestroyHook(oldVnode);
            }
          }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
      };
    }
    var directives2 = {
      create: updateDirectives2,
      update: updateDirectives2,
      destroy: function unbindDirectives2(vnode) {
        updateDirectives2(vnode, emptyNode2);
      }
    };
    function updateDirectives2(oldVnode, vnode) {
      if (oldVnode.data.directives || vnode.data.directives) {
        _update2(oldVnode, vnode);
      }
    }
    function _update2(oldVnode, vnode) {
      const isCreate = oldVnode === emptyNode2;
      const isDestroy = vnode === emptyNode2;
      const oldDirs = normalizeDirectives2(oldVnode.data.directives, oldVnode.context);
      const newDirs = normalizeDirectives2(vnode.data.directives, vnode.context);
      const dirsWithInsert = [];
      const dirsWithPostpatch = [];
      let key, oldDir, dir;
      for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
          callHook2(dir, "bind", vnode, oldVnode);
          if (dir.def && dir.def.inserted) {
            dirsWithInsert.push(dir);
          }
        } else {
          dir.oldValue = oldDir.value;
          dir.oldArg = oldDir.arg;
          callHook2(dir, "update", vnode, oldVnode);
          if (dir.def && dir.def.componentUpdated) {
            dirsWithPostpatch.push(dir);
          }
        }
      }
      if (dirsWithInsert.length) {
        const callInsert = () => {
          for (let i = 0; i < dirsWithInsert.length; i++) {
            callHook2(dirsWithInsert[i], "inserted", vnode, oldVnode);
          }
        };
        if (isCreate) {
          mergeVNodeHook2(vnode, "insert", callInsert);
        } else {
          callInsert();
        }
      }
      if (dirsWithPostpatch.length) {
        mergeVNodeHook2(vnode, "postpatch", () => {
          for (let i = 0; i < dirsWithPostpatch.length; i++) {
            callHook2(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
          }
        });
      }
      if (!isCreate) {
        for (key in oldDirs) {
          if (!newDirs[key]) {
            callHook2(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
          }
        }
      }
    }
    var emptyModifiers2 = /* @__PURE__ */ Object.create(null);
    function normalizeDirectives2(dirs, vm) {
      const res = /* @__PURE__ */ Object.create(null);
      if (!dirs) {
        return res;
      }
      let i, dir;
      for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
          dir.modifiers = emptyModifiers2;
        }
        res[getRawDirName2(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
          dir.def = dir.def || resolveAsset2(vm, "_setupState", "v-" + dir.name);
        }
        dir.def = dir.def || resolveAsset2(vm.$options, "directives", dir.name, true);
      }
      return res;
    }
    function getRawDirName2(dir) {
      return dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join(".")}`;
    }
    function callHook2(dir, hook, vnode, oldVnode, isDestroy) {
      const fn = dir.def && dir.def[hook];
      if (fn) {
        try {
          fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        } catch (e) {
          handleError2(e, vnode.context, `directive ${dir.name} ${hook} hook`);
        }
      }
    }
    var baseModules2 = [ref3, directives2];
    function updateAttrs2(oldVnode, vnode) {
      const opts = vnode.componentOptions;
      if (isDef2(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
      }
      if (isUndef3(oldVnode.data.attrs) && isUndef3(vnode.data.attrs)) {
        return;
      }
      let key, cur, old;
      const elm = vnode.elm;
      const oldAttrs = oldVnode.data.attrs || {};
      let attrs3 = vnode.data.attrs || {};
      if (isDef2(attrs3.__ob__) || isTrue2(attrs3._v_attr_proxy)) {
        attrs3 = vnode.data.attrs = extend2({}, attrs3);
      }
      for (key in attrs3) {
        cur = attrs3[key];
        old = oldAttrs[key];
        if (old !== cur) {
          setAttr2(elm, key, cur, vnode.data.pre);
        }
      }
      if ((isIE2 || isEdge2) && attrs3.value !== oldAttrs.value) {
        setAttr2(elm, "value", attrs3.value);
      }
      for (key in oldAttrs) {
        if (isUndef3(attrs3[key])) {
          if (isXlink2(key)) {
            elm.removeAttributeNS(xlinkNS2, getXlinkProp2(key));
          } else if (!isEnumeratedAttr2(key)) {
            elm.removeAttribute(key);
          }
        }
      }
    }
    function setAttr2(el, key, value, isInPre) {
      if (isInPre || el.tagName.indexOf("-") > -1) {
        baseSetAttr2(el, key, value);
      } else if (isBooleanAttr2(key)) {
        if (isFalsyAttrValue2(value)) {
          el.removeAttribute(key);
        } else {
          value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
          el.setAttribute(key, value);
        }
      } else if (isEnumeratedAttr2(key)) {
        el.setAttribute(key, convertEnumeratedValue2(key, value));
      } else if (isXlink2(key)) {
        if (isFalsyAttrValue2(value)) {
          el.removeAttributeNS(xlinkNS2, getXlinkProp2(key));
        } else {
          el.setAttributeNS(xlinkNS2, key, value);
        }
      } else {
        baseSetAttr2(el, key, value);
      }
    }
    function baseSetAttr2(el, key, value) {
      if (isFalsyAttrValue2(value)) {
        el.removeAttribute(key);
      } else {
        if (isIE2 && !isIE92 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
          const blocker = (e) => {
            e.stopImmediatePropagation();
            el.removeEventListener("input", blocker);
          };
          el.addEventListener("input", blocker);
          el.__ieph = true;
        }
        el.setAttribute(key, value);
      }
    }
    var attrs2 = {
      create: updateAttrs2,
      update: updateAttrs2
    };
    function updateClass2(oldVnode, vnode) {
      const el = vnode.elm;
      const data = vnode.data;
      const oldData = oldVnode.data;
      if (isUndef3(data.staticClass) && isUndef3(data.class) && (isUndef3(oldData) || isUndef3(oldData.staticClass) && isUndef3(oldData.class))) {
        return;
      }
      let cls = genClassForVnode2(vnode);
      const transitionClass = el._transitionClasses;
      if (isDef2(transitionClass)) {
        cls = concat2(cls, stringifyClass2(transitionClass));
      }
      if (cls !== el._prevClass) {
        el.setAttribute("class", cls);
        el._prevClass = cls;
      }
    }
    var klass2 = {
      create: updateClass2,
      update: updateClass2
    };
    var RANGE_TOKEN2 = "__r";
    var CHECKBOX_RADIO_TOKEN2 = "__c";
    function normalizeEvents2(on) {
      if (isDef2(on[RANGE_TOKEN2])) {
        const event = isIE2 ? "change" : "input";
        on[event] = [].concat(on[RANGE_TOKEN2], on[event] || []);
        delete on[RANGE_TOKEN2];
      }
      if (isDef2(on[CHECKBOX_RADIO_TOKEN2])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN2], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN2];
      }
    }
    var target2;
    function createOnceHandler2(event, handler, capture) {
      const _target = target2;
      return function onceHandler() {
        const res = handler.apply(null, arguments);
        if (res !== null) {
          remove2(event, onceHandler, capture, _target);
        }
      };
    }
    var useMicrotaskFix2 = isUsingMicroTask2 && !(isFF2 && Number(isFF2[1]) <= 53);
    function add2(name, handler, capture, passive) {
      if (useMicrotaskFix2) {
        const attachedTimestamp = currentFlushTimestamp2;
        const original = handler;
        handler = original._wrapper = function(e) {
          if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
            return original.apply(this, arguments);
          }
        };
      }
      target2.addEventListener(name, handler, supportsPassive2 ? { capture, passive } : capture);
    }
    function remove2(name, handler, capture, _target) {
      (_target || target2).removeEventListener(name, handler._wrapper || handler, capture);
    }
    function updateDOMListeners2(oldVnode, vnode) {
      if (isUndef3(oldVnode.data.on) && isUndef3(vnode.data.on)) {
        return;
      }
      const on = vnode.data.on || {};
      const oldOn = oldVnode.data.on || {};
      target2 = vnode.elm || oldVnode.elm;
      normalizeEvents2(on);
      updateListeners2(on, oldOn, add2, remove2, createOnceHandler2, vnode.context);
      target2 = void 0;
    }
    var events2 = {
      create: updateDOMListeners2,
      update: updateDOMListeners2,
      destroy: (vnode) => updateDOMListeners2(vnode, emptyNode2)
    };
    var svgContainer2;
    function updateDOMProps2(oldVnode, vnode) {
      if (isUndef3(oldVnode.data.domProps) && isUndef3(vnode.data.domProps)) {
        return;
      }
      let key, cur;
      const elm = vnode.elm;
      const oldProps = oldVnode.data.domProps || {};
      let props3 = vnode.data.domProps || {};
      if (isDef2(props3.__ob__) || isTrue2(props3._v_attr_proxy)) {
        props3 = vnode.data.domProps = extend2({}, props3);
      }
      for (key in oldProps) {
        if (!(key in props3)) {
          elm[key] = "";
        }
      }
      for (key in props3) {
        cur = props3[key];
        if (key === "textContent" || key === "innerHTML") {
          if (vnode.children)
            vnode.children.length = 0;
          if (cur === oldProps[key])
            continue;
          if (elm.childNodes.length === 1) {
            elm.removeChild(elm.childNodes[0]);
          }
        }
        if (key === "value" && elm.tagName !== "PROGRESS") {
          elm._value = cur;
          const strCur = isUndef3(cur) ? "" : String(cur);
          if (shouldUpdateValue2(elm, strCur)) {
            elm.value = strCur;
          }
        } else if (key === "innerHTML" && isSVG2(elm.tagName) && isUndef3(elm.innerHTML)) {
          svgContainer2 = svgContainer2 || document.createElement("div");
          svgContainer2.innerHTML = `<svg>${cur}</svg>`;
          const svg = svgContainer2.firstChild;
          while (elm.firstChild) {
            elm.removeChild(elm.firstChild);
          }
          while (svg.firstChild) {
            elm.appendChild(svg.firstChild);
          }
        } else if (cur !== oldProps[key]) {
          try {
            elm[key] = cur;
          } catch (e) {
          }
        }
      }
    }
    function shouldUpdateValue2(elm, checkVal) {
      return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty2(elm, checkVal) || isDirtyWithModifiers2(elm, checkVal));
    }
    function isNotInFocusAndDirty2(elm, checkVal) {
      let notInFocus = true;
      try {
        notInFocus = document.activeElement !== elm;
      } catch (e) {
      }
      return notInFocus && elm.value !== checkVal;
    }
    function isDirtyWithModifiers2(elm, newVal) {
      const value = elm.value;
      const modifiers = elm._vModifiers;
      if (isDef2(modifiers)) {
        if (modifiers.number) {
          return toNumber2(value) !== toNumber2(newVal);
        }
        if (modifiers.trim) {
          return value.trim() !== newVal.trim();
        }
      }
      return value !== newVal;
    }
    var domProps2 = {
      create: updateDOMProps2,
      update: updateDOMProps2
    };
    var parseStyleText2 = cached2(function(cssText) {
      const res = {};
      const listDelimiter = /;(?![^(]*\))/g;
      const propertyDelimiter = /:(.+)/;
      cssText.split(listDelimiter).forEach(function(item) {
        if (item) {
          const tmp = item.split(propertyDelimiter);
          tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return res;
    });
    function normalizeStyleData2(data) {
      const style3 = normalizeStyleBinding2(data.style);
      return data.staticStyle ? extend2(data.staticStyle, style3) : style3;
    }
    function normalizeStyleBinding2(bindingStyle) {
      if (Array.isArray(bindingStyle)) {
        return toObject2(bindingStyle);
      }
      if (typeof bindingStyle === "string") {
        return parseStyleText2(bindingStyle);
      }
      return bindingStyle;
    }
    function getStyle2(vnode, checkChild) {
      const res = {};
      let styleData;
      if (checkChild) {
        let childNode = vnode;
        while (childNode.componentInstance) {
          childNode = childNode.componentInstance._vnode;
          if (childNode && childNode.data && (styleData = normalizeStyleData2(childNode.data))) {
            extend2(res, styleData);
          }
        }
      }
      if (styleData = normalizeStyleData2(vnode.data)) {
        extend2(res, styleData);
      }
      let parentNode3 = vnode;
      while (parentNode3 = parentNode3.parent) {
        if (parentNode3.data && (styleData = normalizeStyleData2(parentNode3.data))) {
          extend2(res, styleData);
        }
      }
      return res;
    }
    var cssVarRE2 = /^--/;
    var importantRE2 = /\s*!important$/;
    var setProp2 = (el, name, val) => {
      if (cssVarRE2.test(name)) {
        el.style.setProperty(name, val);
      } else if (importantRE2.test(val)) {
        el.style.setProperty(hyphenate2(name), val.replace(importantRE2, ""), "important");
      } else {
        const normalizedName = normalize2(name);
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; i++) {
            el.style[normalizedName] = val[i];
          }
        } else {
          el.style[normalizedName] = val;
        }
      }
    };
    var vendorNames2 = ["Webkit", "Moz", "ms"];
    var emptyStyle2;
    var normalize2 = cached2(function(prop) {
      emptyStyle2 = emptyStyle2 || document.createElement("div").style;
      prop = camelize2(prop);
      if (prop !== "filter" && prop in emptyStyle2) {
        return prop;
      }
      const capName = prop.charAt(0).toUpperCase() + prop.slice(1);
      for (let i = 0; i < vendorNames2.length; i++) {
        const name = vendorNames2[i] + capName;
        if (name in emptyStyle2) {
          return name;
        }
      }
    });
    function updateStyle2(oldVnode, vnode) {
      const data = vnode.data;
      const oldData = oldVnode.data;
      if (isUndef3(data.staticStyle) && isUndef3(data.style) && isUndef3(oldData.staticStyle) && isUndef3(oldData.style)) {
        return;
      }
      let cur, name;
      const el = vnode.elm;
      const oldStaticStyle = oldData.staticStyle;
      const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
      const oldStyle = oldStaticStyle || oldStyleBinding;
      const style3 = normalizeStyleBinding2(vnode.data.style) || {};
      vnode.data.normalizedStyle = isDef2(style3.__ob__) ? extend2({}, style3) : style3;
      const newStyle = getStyle2(vnode, true);
      for (name in oldStyle) {
        if (isUndef3(newStyle[name])) {
          setProp2(el, name, "");
        }
      }
      for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
          setProp2(el, name, cur == null ? "" : cur);
        }
      }
    }
    var style2 = {
      create: updateStyle2,
      update: updateStyle2
    };
    var whitespaceRE2 = /\s+/;
    function addClass2(el, cls) {
      if (!cls || !(cls = cls.trim())) {
        return;
      }
      if (el.classList) {
        if (cls.indexOf(" ") > -1) {
          cls.split(whitespaceRE2).forEach((c) => el.classList.add(c));
        } else {
          el.classList.add(cls);
        }
      } else {
        const cur = ` ${el.getAttribute("class") || ""} `;
        if (cur.indexOf(" " + cls + " ") < 0) {
          el.setAttribute("class", (cur + cls).trim());
        }
      }
    }
    function removeClass2(el, cls) {
      if (!cls || !(cls = cls.trim())) {
        return;
      }
      if (el.classList) {
        if (cls.indexOf(" ") > -1) {
          cls.split(whitespaceRE2).forEach((c) => el.classList.remove(c));
        } else {
          el.classList.remove(cls);
        }
        if (!el.classList.length) {
          el.removeAttribute("class");
        }
      } else {
        let cur = ` ${el.getAttribute("class") || ""} `;
        const tar = " " + cls + " ";
        while (cur.indexOf(tar) >= 0) {
          cur = cur.replace(tar, " ");
        }
        cur = cur.trim();
        if (cur) {
          el.setAttribute("class", cur);
        } else {
          el.removeAttribute("class");
        }
      }
    }
    function resolveTransition2(def4) {
      if (!def4) {
        return;
      }
      if (typeof def4 === "object") {
        const res = {};
        if (def4.css !== false) {
          extend2(res, autoCssTransition2(def4.name || "v"));
        }
        extend2(res, def4);
        return res;
      } else if (typeof def4 === "string") {
        return autoCssTransition2(def4);
      }
    }
    var autoCssTransition2 = cached2((name) => {
      return {
        enterClass: `${name}-enter`,
        enterToClass: `${name}-enter-to`,
        enterActiveClass: `${name}-enter-active`,
        leaveClass: `${name}-leave`,
        leaveToClass: `${name}-leave-to`,
        leaveActiveClass: `${name}-leave-active`
      };
    });
    var hasTransition2 = inBrowser2 && !isIE92;
    var TRANSITION2 = "transition";
    var ANIMATION2 = "animation";
    var transitionProp2 = "transition";
    var transitionEndEvent2 = "transitionend";
    var animationProp2 = "animation";
    var animationEndEvent2 = "animationend";
    if (hasTransition2) {
      if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
        transitionProp2 = "WebkitTransition";
        transitionEndEvent2 = "webkitTransitionEnd";
      }
      if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
        animationProp2 = "WebkitAnimation";
        animationEndEvent2 = "webkitAnimationEnd";
      }
    }
    var raf2 = inBrowser2 ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (fn) => fn();
    function nextFrame2(fn) {
      raf2(() => {
        raf2(fn);
      });
    }
    function addTransitionClass2(el, cls) {
      const transitionClasses = el._transitionClasses || (el._transitionClasses = []);
      if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass2(el, cls);
      }
    }
    function removeTransitionClass2(el, cls) {
      if (el._transitionClasses) {
        remove$22(el._transitionClasses, cls);
      }
      removeClass2(el, cls);
    }
    function whenTransitionEnds2(el, expectedType, cb) {
      const { type, timeout, propCount } = getTransitionInfo2(el, expectedType);
      if (!type)
        return cb();
      const event = type === TRANSITION2 ? transitionEndEvent2 : animationEndEvent2;
      let ended = 0;
      const end = () => {
        el.removeEventListener(event, onEnd);
        cb();
      };
      const onEnd = (e) => {
        if (e.target === el) {
          if (++ended >= propCount) {
            end();
          }
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(event, onEnd);
    }
    var transformRE2 = /\b(transform|all)(,|$)/;
    function getTransitionInfo2(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const transitionDelays = (styles[transitionProp2 + "Delay"] || "").split(", ");
      const transitionDurations = (styles[transitionProp2 + "Duration"] || "").split(", ");
      const transitionTimeout = getTimeout2(transitionDelays, transitionDurations);
      const animationDelays = (styles[animationProp2 + "Delay"] || "").split(", ");
      const animationDurations = (styles[animationProp2 + "Duration"] || "").split(", ");
      const animationTimeout = getTimeout2(animationDelays, animationDurations);
      let type;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION2) {
        if (transitionTimeout > 0) {
          type = TRANSITION2;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION2) {
        if (animationTimeout > 0) {
          type = ANIMATION2;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION2 : ANIMATION2 : null;
        propCount = type ? type === TRANSITION2 ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION2 && transformRE2.test(styles[transitionProp2 + "Property"]);
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout2(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max.apply(null, durations.map((d, i) => {
        return toMs2(d) + toMs2(delays[i]);
      }));
    }
    function toMs2(s) {
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function enter2(vnode, toggleDisplay) {
      const el = vnode.elm;
      if (isDef2(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
      }
      const data = resolveTransition2(vnode.data.transition);
      if (isUndef3(data)) {
        return;
      }
      if (isDef2(el._enterCb) || el.nodeType !== 1) {
        return;
      }
      const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter: enter3, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;
      let context = activeInstance2;
      let transitionNode = activeInstance2.$vnode;
      while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
      }
      const isAppear = !context._isMounted || !vnode.isRootInsert;
      if (isAppear && !appear && appear !== "") {
        return;
      }
      const startClass = isAppear && appearClass ? appearClass : enterClass;
      const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
      const toClass = isAppear && appearToClass ? appearToClass : enterToClass;
      const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
      const enterHook = isAppear ? isFunction3(appear) ? appear : enter3 : enter3;
      const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
      const enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
      const explicitEnterDuration = toNumber2(isObject3(duration) ? duration.enter : duration);
      if (explicitEnterDuration != null) {
        checkDuration2(explicitEnterDuration, "enter", vnode);
      }
      const expectsCSS = css !== false && !isIE92;
      const userWantsControl = getHookArgumentsLength2(enterHook);
      const cb = el._enterCb = once2(() => {
        if (expectsCSS) {
          removeTransitionClass2(el, toClass);
          removeTransitionClass2(el, activeClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass2(el, startClass);
          }
          enterCancelledHook && enterCancelledHook(el);
        } else {
          afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
      });
      if (!vnode.data.show) {
        mergeVNodeHook2(vnode, "insert", () => {
          const parent = el.parentNode;
          const pendingNode = parent && parent._pending && parent._pending[vnode.key];
          if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
            pendingNode.elm._leaveCb();
          }
          enterHook && enterHook(el, cb);
        });
      }
      beforeEnterHook && beforeEnterHook(el);
      if (expectsCSS) {
        addTransitionClass2(el, startClass);
        addTransitionClass2(el, activeClass);
        nextFrame2(() => {
          removeTransitionClass2(el, startClass);
          if (!cb.cancelled) {
            addTransitionClass2(el, toClass);
            if (!userWantsControl) {
              if (isValidDuration2(explicitEnterDuration)) {
                setTimeout(cb, explicitEnterDuration);
              } else {
                whenTransitionEnds2(el, type, cb);
              }
            }
          }
        });
      }
      if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
      }
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
    function leave2(vnode, rm) {
      const el = vnode.elm;
      if (isDef2(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
      }
      const data = resolveTransition2(vnode.data.transition);
      if (isUndef3(data) || el.nodeType !== 1) {
        return rm();
      }
      if (isDef2(el._leaveCb)) {
        return;
      }
      const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave: leave3, afterLeave, leaveCancelled, delayLeave, duration } = data;
      const expectsCSS = css !== false && !isIE92;
      const userWantsControl = getHookArgumentsLength2(leave3);
      const explicitLeaveDuration = toNumber2(isObject3(duration) ? duration.leave : duration);
      if (isDef2(explicitLeaveDuration)) {
        checkDuration2(explicitLeaveDuration, "leave", vnode);
      }
      const cb = el._leaveCb = once2(() => {
        if (el.parentNode && el.parentNode._pending) {
          el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
          removeTransitionClass2(el, leaveToClass);
          removeTransitionClass2(el, leaveActiveClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass2(el, leaveClass);
          }
          leaveCancelled && leaveCancelled(el);
        } else {
          rm();
          afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
      });
      if (delayLeave) {
        delayLeave(performLeave);
      } else {
        performLeave();
      }
      function performLeave() {
        if (cb.cancelled) {
          return;
        }
        if (!vnode.data.show && el.parentNode) {
          (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
          addTransitionClass2(el, leaveClass);
          addTransitionClass2(el, leaveActiveClass);
          nextFrame2(() => {
            removeTransitionClass2(el, leaveClass);
            if (!cb.cancelled) {
              addTransitionClass2(el, leaveToClass);
              if (!userWantsControl) {
                if (isValidDuration2(explicitLeaveDuration)) {
                  setTimeout(cb, explicitLeaveDuration);
                } else {
                  whenTransitionEnds2(el, type, cb);
                }
              }
            }
          });
        }
        leave3 && leave3(el, cb);
        if (!expectsCSS && !userWantsControl) {
          cb();
        }
      }
    }
    function checkDuration2(val, name, vnode) {
      if (typeof val !== "number") {
        warn3(`<transition> explicit ${name} duration is not a valid number - got ${JSON.stringify(val)}.`, vnode.context);
      } else if (isNaN(val)) {
        warn3(`<transition> explicit ${name} duration is NaN - the duration expression might be incorrect.`, vnode.context);
      }
    }
    function isValidDuration2(val) {
      return typeof val === "number" && !isNaN(val);
    }
    function getHookArgumentsLength2(fn) {
      if (isUndef3(fn)) {
        return false;
      }
      const invokerFns = fn.fns;
      if (isDef2(invokerFns)) {
        return getHookArgumentsLength2(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
      } else {
        return (fn._length || fn.length) > 1;
      }
    }
    function _enter2(_, vnode) {
      if (vnode.data.show !== true) {
        enter2(vnode);
      }
    }
    var transition2 = inBrowser2 ? {
      create: _enter2,
      activate: _enter2,
      remove(vnode, rm) {
        if (vnode.data.show !== true) {
          leave2(vnode, rm);
        } else {
          rm();
        }
      }
    } : {};
    var platformModules2 = [attrs2, klass2, events2, domProps2, style2, transition2];
    var modules2 = platformModules2.concat(baseModules2);
    var patch2 = createPatchFunction2({ nodeOps: nodeOps2, modules: modules2 });
    if (isIE92) {
      document.addEventListener("selectionchange", () => {
        const el = document.activeElement;
        if (el && el.vmodel) {
          trigger2(el, "input");
        }
      });
    }
    var directive2 = {
      inserted(el, binding, vnode, oldVnode) {
        if (vnode.tag === "select") {
          if (oldVnode.elm && !oldVnode.elm._vOptions) {
            mergeVNodeHook2(vnode, "postpatch", () => {
              directive2.componentUpdated(el, binding, vnode);
            });
          } else {
            setSelected2(el, binding, vnode.context);
          }
          el._vOptions = [].map.call(el.options, getValue2);
        } else if (vnode.tag === "textarea" || isTextInputType2(el.type)) {
          el._vModifiers = binding.modifiers;
          if (!binding.modifiers.lazy) {
            el.addEventListener("compositionstart", onCompositionStart2);
            el.addEventListener("compositionend", onCompositionEnd2);
            el.addEventListener("change", onCompositionEnd2);
            if (isIE92) {
              el.vmodel = true;
            }
          }
        }
      },
      componentUpdated(el, binding, vnode) {
        if (vnode.tag === "select") {
          setSelected2(el, binding, vnode.context);
          const prevOptions = el._vOptions;
          const curOptions = el._vOptions = [].map.call(el.options, getValue2);
          if (curOptions.some((o, i) => !looseEqual2(o, prevOptions[i]))) {
            const needReset = el.multiple ? binding.value.some((v) => hasNoMatchingOption2(v, curOptions)) : binding.value !== binding.oldValue && hasNoMatchingOption2(binding.value, curOptions);
            if (needReset) {
              trigger2(el, "change");
            }
          }
        }
      }
    };
    function setSelected2(el, binding, vm) {
      actuallySetSelected2(el, binding, vm);
      if (isIE2 || isEdge2) {
        setTimeout(() => {
          actuallySetSelected2(el, binding, vm);
        }, 0);
      }
    }
    function actuallySetSelected2(el, binding, vm) {
      const value = binding.value;
      const isMultiple = el.multiple;
      if (isMultiple && !Array.isArray(value)) {
        warn3(`<select multiple v-model="${binding.expression}"> expects an Array value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}`, vm);
        return;
      }
      let selected, option;
      for (let i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
          selected = looseIndexOf2(value, getValue2(option)) > -1;
          if (option.selected !== selected) {
            option.selected = selected;
          }
        } else {
          if (looseEqual2(getValue2(option), value)) {
            if (el.selectedIndex !== i) {
              el.selectedIndex = i;
            }
            return;
          }
        }
      }
      if (!isMultiple) {
        el.selectedIndex = -1;
      }
    }
    function hasNoMatchingOption2(value, options) {
      return options.every((o) => !looseEqual2(o, value));
    }
    function getValue2(option) {
      return "_value" in option ? option._value : option.value;
    }
    function onCompositionStart2(e) {
      e.target.composing = true;
    }
    function onCompositionEnd2(e) {
      if (!e.target.composing)
        return;
      e.target.composing = false;
      trigger2(e.target, "input");
    }
    function trigger2(el, type) {
      const e = document.createEvent("HTMLEvents");
      e.initEvent(type, true, true);
      el.dispatchEvent(e);
    }
    function locateNode2(vnode) {
      return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode2(vnode.componentInstance._vnode) : vnode;
    }
    var show2 = {
      bind(el, { value }, vnode) {
        vnode = locateNode2(vnode);
        const transition3 = vnode.data && vnode.data.transition;
        const originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
        if (value && transition3) {
          vnode.data.show = true;
          enter2(vnode, () => {
            el.style.display = originalDisplay;
          });
        } else {
          el.style.display = value ? originalDisplay : "none";
        }
      },
      update(el, { value, oldValue }, vnode) {
        if (!value === !oldValue)
          return;
        vnode = locateNode2(vnode);
        const transition3 = vnode.data && vnode.data.transition;
        if (transition3) {
          vnode.data.show = true;
          if (value) {
            enter2(vnode, () => {
              el.style.display = el.__vOriginalDisplay;
            });
          } else {
            leave2(vnode, () => {
              el.style.display = "none";
            });
          }
        } else {
          el.style.display = value ? el.__vOriginalDisplay : "none";
        }
      },
      unbind(el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
          el.style.display = el.__vOriginalDisplay;
        }
      }
    };
    var platformDirectives2 = {
      model: directive2,
      show: show2
    };
    var transitionProps2 = {
      name: String,
      appear: Boolean,
      css: Boolean,
      mode: String,
      type: String,
      enterClass: String,
      leaveClass: String,
      enterToClass: String,
      leaveToClass: String,
      enterActiveClass: String,
      leaveActiveClass: String,
      appearClass: String,
      appearActiveClass: String,
      appearToClass: String,
      duration: [Number, String, Object]
    };
    function getRealChild2(vnode) {
      const compOptions = vnode && vnode.componentOptions;
      if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild2(getFirstComponentChild2(compOptions.children));
      } else {
        return vnode;
      }
    }
    function extractTransitionData2(comp) {
      const data = {};
      const options = comp.$options;
      for (const key in options.propsData) {
        data[key] = comp[key];
      }
      const listeners = options._parentListeners;
      for (const key in listeners) {
        data[camelize2(key)] = listeners[key];
      }
      return data;
    }
    function placeholder2(h2, rawChild) {
      if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h2("keep-alive", {
          props: rawChild.componentOptions.propsData
        });
      }
    }
    function hasParentTransition2(vnode) {
      while (vnode = vnode.parent) {
        if (vnode.data.transition) {
          return true;
        }
      }
    }
    function isSameChild2(child, oldChild) {
      return oldChild.key === child.key && oldChild.tag === child.tag;
    }
    var isNotTextNode2 = (c) => c.tag || isAsyncPlaceholder2(c);
    var isVShowDirective2 = (d) => d.name === "show";
    var Transition2 = {
      name: "transition",
      props: transitionProps2,
      abstract: true,
      render(h2) {
        let children = this.$slots.default;
        if (!children) {
          return;
        }
        children = children.filter(isNotTextNode2);
        if (!children.length) {
          return;
        }
        if (children.length > 1) {
          warn3("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
        }
        const mode = this.mode;
        if (mode && mode !== "in-out" && mode !== "out-in") {
          warn3("invalid <transition> mode: " + mode, this.$parent);
        }
        const rawChild = children[0];
        if (hasParentTransition2(this.$vnode)) {
          return rawChild;
        }
        const child = getRealChild2(rawChild);
        if (!child) {
          return rawChild;
        }
        if (this._leaving) {
          return placeholder2(h2, rawChild);
        }
        const id = `__transition-${this._uid}-`;
        child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive3(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
        const data = (child.data || (child.data = {})).transition = extractTransitionData2(this);
        const oldRawChild = this._vnode;
        const oldChild = getRealChild2(oldRawChild);
        if (child.data.directives && child.data.directives.some(isVShowDirective2)) {
          child.data.show = true;
        }
        if (oldChild && oldChild.data && !isSameChild2(child, oldChild) && !isAsyncPlaceholder2(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
          const oldData = oldChild.data.transition = extend2({}, data);
          if (mode === "out-in") {
            this._leaving = true;
            mergeVNodeHook2(oldData, "afterLeave", () => {
              this._leaving = false;
              this.$forceUpdate();
            });
            return placeholder2(h2, rawChild);
          } else if (mode === "in-out") {
            if (isAsyncPlaceholder2(child)) {
              return oldRawChild;
            }
            let delayedLeave;
            const performLeave = () => {
              delayedLeave();
            };
            mergeVNodeHook2(data, "afterEnter", performLeave);
            mergeVNodeHook2(data, "enterCancelled", performLeave);
            mergeVNodeHook2(oldData, "delayLeave", (leave3) => {
              delayedLeave = leave3;
            });
          }
        }
        return rawChild;
      }
    };
    var props2 = extend2({
      tag: String,
      moveClass: String
    }, transitionProps2);
    delete props2.mode;
    var TransitionGroup2 = {
      props: props2,
      beforeMount() {
        const update = this._update;
        this._update = (vnode, hydrating) => {
          const restoreActiveInstance = setActiveInstance2(this);
          this.__patch__(this._vnode, this.kept, false, true);
          this._vnode = this.kept;
          restoreActiveInstance();
          update.call(this, vnode, hydrating);
        };
      },
      render(h2) {
        const tag = this.tag || this.$vnode.data.tag || "span";
        const map = /* @__PURE__ */ Object.create(null);
        const prevChildren = this.prevChildren = this.children;
        const rawChildren = this.$slots.default || [];
        const children = this.children = [];
        const transitionData = extractTransitionData2(this);
        for (let i = 0; i < rawChildren.length; i++) {
          const c = rawChildren[i];
          if (c.tag) {
            if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
              children.push(c);
              map[c.key] = c;
              (c.data || (c.data = {})).transition = transitionData;
            } else {
              const opts = c.componentOptions;
              const name = opts ? getComponentName2(opts.Ctor.options) || opts.tag || "" : c.tag;
              warn3(`<transition-group> children must be keyed: <${name}>`);
            }
          }
        }
        if (prevChildren) {
          const kept = [];
          const removed = [];
          for (let i = 0; i < prevChildren.length; i++) {
            const c = prevChildren[i];
            c.data.transition = transitionData;
            c.data.pos = c.elm.getBoundingClientRect();
            if (map[c.key]) {
              kept.push(c);
            } else {
              removed.push(c);
            }
          }
          this.kept = h2(tag, null, kept);
          this.removed = removed;
        }
        return h2(tag, null, children);
      },
      updated() {
        const children = this.prevChildren;
        const moveClass = this.moveClass || (this.name || "v") + "-move";
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
          return;
        }
        children.forEach(callPendingCbs2);
        children.forEach(recordPosition2);
        children.forEach(applyTranslation2);
        this._reflow = document.body.offsetHeight;
        children.forEach((c) => {
          if (c.data.moved) {
            const el = c.elm;
            const s = el.style;
            addTransitionClass2(el, moveClass);
            s.transform = s.WebkitTransform = s.transitionDuration = "";
            el.addEventListener(transitionEndEvent2, el._moveCb = function cb(e) {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener(transitionEndEvent2, cb);
                el._moveCb = null;
                removeTransitionClass2(el, moveClass);
              }
            });
          }
        });
      },
      methods: {
        hasMove(el, moveClass) {
          if (!hasTransition2) {
            return false;
          }
          if (this._hasMove) {
            return this._hasMove;
          }
          const clone = el.cloneNode();
          if (el._transitionClasses) {
            el._transitionClasses.forEach((cls) => {
              removeClass2(clone, cls);
            });
          }
          addClass2(clone, moveClass);
          clone.style.display = "none";
          this.$el.appendChild(clone);
          const info = getTransitionInfo2(clone);
          this.$el.removeChild(clone);
          return this._hasMove = info.hasTransform;
        }
      }
    };
    function callPendingCbs2(c) {
      if (c.elm._moveCb) {
        c.elm._moveCb();
      }
      if (c.elm._enterCb) {
        c.elm._enterCb();
      }
    }
    function recordPosition2(c) {
      c.data.newPos = c.elm.getBoundingClientRect();
    }
    function applyTranslation2(c) {
      const oldPos = c.data.pos;
      const newPos = c.data.newPos;
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        c.data.moved = true;
        const s = c.elm.style;
        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
      }
    }
    var platformComponents2 = {
      Transition: Transition2,
      TransitionGroup: TransitionGroup2
    };
    Vue3.config.mustUseProp = mustUseProp2;
    Vue3.config.isReservedTag = isReservedTag2;
    Vue3.config.isReservedAttr = isReservedAttr2;
    Vue3.config.getTagNamespace = getTagNamespace2;
    Vue3.config.isUnknownElement = isUnknownElement2;
    extend2(Vue3.options.directives, platformDirectives2);
    extend2(Vue3.options.components, platformComponents2);
    Vue3.prototype.__patch__ = inBrowser2 ? patch2 : noop2;
    Vue3.prototype.$mount = function(el, hydrating) {
      el = el && inBrowser2 ? query2(el) : void 0;
      return mountComponent2(this, el, hydrating);
    };
    if (inBrowser2) {
      setTimeout(() => {
        if (config2.devtools) {
          if (devtools2) {
            devtools2.emit("init", Vue3);
          } else {
            console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
          }
        }
        if (config2.productionTip !== false && typeof console !== "undefined") {
          console[console.info ? "info" : "log"](`You are running Vue in development mode.
Make sure to turn on production mode when deploying for production.
See more tips at https://vuejs.org/guide/deployment.html`);
        }
      }, 0);
    }
    extend2(Vue3, vca);
    module.exports = Vue3;
  }
});

// src/vue2/node_modules/vue/dist/vue.runtime.common.js
var require_vue_runtime_common = __commonJS({
  "src/vue2/node_modules/vue/dist/vue.runtime.common.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_runtime_common_dev();
    }
  }
});

// node_modules/vue2/dist/vue.runtime.esm.js
var emptyObject = Object.freeze({});
var isArray = Array.isArray;
function isUndef(v) {
  return v === void 0 || v === null;
}
function isDef(v) {
  return v !== void 0 && v !== null;
}
function isTrue(v) {
  return v === true;
}
function isFalse(v) {
  return v === false;
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
var _toString = Object.prototype.toString;
function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
function isPlainObject(obj) {
  return _toString.call(obj) === "[object Object]";
}
function isRegExp(v) {
  return _toString.call(v) === "[object RegExp]";
}
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
  return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
}
function toString(val) {
  return val == null ? "" : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
function makeMap(str, expectsLowerCase) {
  var map = /* @__PURE__ */ Object.create(null);
  var list = str.split(",");
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function(val) {
    return map[val.toLowerCase()];
  } : function(val) {
    return map[val];
  };
}
var isBuiltInTag = makeMap("slot,component", true);
var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
function remove$2(arr, item) {
  if (arr.length) {
    var index2 = arr.indexOf(item);
    if (index2 > -1) {
      return arr.splice(index2, 1);
    }
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function cached(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var camelizeRE = /-(\w)/g;
var camelize = cached(function(str) {
  return str.replace(camelizeRE, function(_, c) {
    return c ? c.toUpperCase() : "";
  });
});
var capitalize = cached(function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  boundFn._length = fn.length;
  return boundFn;
}
function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}
var bind = Function.prototype.bind ? nativeBind : polyfillBind;
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
function noop(a, b, c) {
}
var no = function(a, b, c) {
  return false;
};
var identity = function(_) {
  return _;
};
function looseEqual(a, b) {
  if (a === b)
    return true;
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function(e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function(key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val))
      return i;
  }
  return -1;
}
function once(fn) {
  var called = false;
  return function() {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}
function hasChanged(x, y) {
  if (x === y) {
    return x === 0 && 1 / x !== 1 / y;
  } else {
    return x === x || y === y;
  }
}
var SSR_ATTR = "data-server-rendered";
var ASSET_TYPES = ["component", "directive", "filter"];
var LIFECYCLE_HOOKS = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch",
  "renderTracked",
  "renderTriggered"
];
var config = {
  optionMergeStrategies: /* @__PURE__ */ Object.create(null),
  silent: false,
  productionTip: true,
  devtools: true,
  performance: false,
  errorHandler: null,
  warnHandler: null,
  ignoredElements: [],
  keyCodes: /* @__PURE__ */ Object.create(null),
  isReservedTag: no,
  isReservedAttr: no,
  isUnknownElement: no,
  getTagNamespace: noop,
  parsePlatformTagName: identity,
  mustUseProp: no,
  async: true,
  _lifecycleHooks: LIFECYCLE_HOOKS
};
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function isReserved(str) {
  var c = (str + "").charCodeAt(0);
  return c === 36 || c === 95;
}
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split(".");
  return function(obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj)
        return;
      obj = obj[segments[i]];
    }
    return obj;
  };
}
var hasProto = "__proto__" in {};
var inBrowser = typeof window !== "undefined";
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
var isEdge = UA && UA.indexOf("edge/") > 0;
UA && UA.indexOf("android") > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
var nativeWatch = {}.watch;
var supportsPassive = false;
if (inBrowser) {
  try {
    opts = {};
    Object.defineProperty(opts, "passive", {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test-passive", null, opts);
  } catch (e) {
  }
}
var opts;
var _isServer;
var isServerRendering = function() {
  if (_isServer === void 0) {
    if (!inBrowser && typeof global !== "undefined") {
      _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function isNative(Ctor) {
  return typeof Ctor === "function" && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
var _Set;
if (typeof Set !== "undefined" && isNative(Set)) {
  _Set = Set;
} else {
  _Set = function() {
    function Set2() {
      this.set = /* @__PURE__ */ Object.create(null);
    }
    Set2.prototype.has = function(key) {
      return this.set[key] === true;
    };
    Set2.prototype.add = function(key) {
      this.set[key] = true;
    };
    Set2.prototype.clear = function() {
      this.set = /* @__PURE__ */ Object.create(null);
    };
    return Set2;
  }();
}
var currentInstance = null;
function setCurrentInstance(vm) {
  if (vm === void 0) {
    vm = null;
  }
  if (!vm)
    currentInstance && currentInstance._scope.off();
  currentInstance = vm;
  vm && vm._scope.on();
}
var VNode = function() {
  function VNode2(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = void 0;
    this.context = context;
    this.fnContext = void 0;
    this.fnOptions = void 0;
    this.fnScopeId = void 0;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = void 0;
    this.parent = void 0;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = void 0;
    this.isAsyncPlaceholder = false;
  }
  Object.defineProperty(VNode2.prototype, "child", {
    get: function() {
      return this.componentInstance;
    },
    enumerable: false,
    configurable: true
  });
  return VNode2;
}();
var createEmptyVNode = function(text) {
  if (text === void 0) {
    text = "";
  }
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};
function createTextVNode(val) {
  return new VNode(void 0, void 0, void 0, String(val));
}
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var uid$2 = 0;
var Dep = function() {
  function Dep2() {
    this.id = uid$2++;
    this.subs = [];
  }
  Dep2.prototype.addSub = function(sub) {
    this.subs.push(sub);
  };
  Dep2.prototype.removeSub = function(sub) {
    remove$2(this.subs, sub);
  };
  Dep2.prototype.depend = function(info) {
    if (Dep2.target) {
      Dep2.target.addDep(this);
      if (info && Dep2.target.onTrack) {
        Dep2.target.onTrack(__assign({ effect: Dep2.target }, info));
      }
    }
  };
  Dep2.prototype.notify = function(info) {
    var subs = this.subs.slice();
    if (!config.async) {
      subs.sort(function(a, b) {
        return a.id - b.id;
      });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      if (info) {
        var sub = subs[i];
        sub.onTrigger && sub.onTrigger(__assign({ effect: subs[i] }, info));
      }
      subs[i].update();
    }
  };
  return Dep2;
}();
Dep.target = null;
var targetStack = [];
function pushTarget(target2) {
  targetStack.push(target2);
  Dep.target = target2;
}
function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
methodsToPatch.forEach(function(method) {
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted)
      ob.observeArray(inserted);
    if (true) {
      ob.dep.notify({
        type: "array mutation",
        target: this,
        key: method
      });
    } else {
      ob.dep.notify();
    }
    return result;
  });
});
var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var NO_INIITIAL_VALUE = {};
var shouldObserve = true;
function toggleObserving(value) {
  shouldObserve = value;
}
var mockDep = {
  notify: noop,
  depend: noop,
  addSub: noop,
  removeSub: noop
};
var Observer = function() {
  function Observer2(value, shallow, mock) {
    if (shallow === void 0) {
      shallow = false;
    }
    if (mock === void 0) {
      mock = false;
    }
    this.value = value;
    this.shallow = shallow;
    this.mock = mock;
    this.dep = mock ? mockDep : new Dep();
    this.vmCount = 0;
    def(value, "__ob__", this);
    if (isArray(value)) {
      if (!mock) {
        if (hasProto) {
          value.__proto__ = arrayMethods;
        } else {
          for (var i = 0, l = arrayKeys.length; i < l; i++) {
            var key = arrayKeys[i];
            def(value, key, arrayMethods[key]);
          }
        }
      }
      if (!shallow) {
        this.observeArray(value);
      }
    } else {
      var keys = Object.keys(value);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        defineReactive(value, key, NO_INIITIAL_VALUE, void 0, shallow, mock);
      }
    }
  }
  Observer2.prototype.observeArray = function(value) {
    for (var i = 0, l = value.length; i < l; i++) {
      observe(value[i], false, this.mock);
    }
  };
  return Observer2;
}();
function observe(value, shallow, ssrMockReactivity) {
  if (!isObject(value) || isRef(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && (ssrMockReactivity || !isServerRendering()) && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value.__v_skip) {
    ob = new Observer(value, shallow, ssrMockReactivity);
  }
  return ob;
}
function defineReactive(obj, key, val, customSetter, shallow, mock) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
    val = obj[key];
  }
  var childOb = !shallow && observe(val, false, mock);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        if (true) {
          dep.depend({
            target: obj,
            type: "get",
            key
          });
        } else {
          dep.depend();
        }
        if (childOb) {
          childOb.dep.depend();
          if (isArray(value)) {
            dependArray(value);
          }
        }
      }
      return isRef(value) && !shallow ? value.value : value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (!hasChanged(value, newVal)) {
        return;
      }
      if (customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else if (getter) {
        return;
      } else if (!shallow && isRef(value) && !isRef(newVal)) {
        value.value = newVal;
        return;
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal, false, mock);
      if (true) {
        dep.notify({
          type: "set",
          target: obj,
          key,
          newValue: newVal,
          oldValue: value
        });
      } else {
        dep.notify();
      }
    }
  });
  return dep;
}
function set(target2, key, val) {
  if (isUndef(target2) || isPrimitive(target2)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: ".concat(target2));
  }
  if (isReadonly(target2)) {
    warn('Set operation on key "'.concat(key, '" failed: target is readonly.'));
    return;
  }
  var ob = target2.__ob__;
  if (isArray(target2) && isValidArrayIndex(key)) {
    target2.length = Math.max(target2.length, key);
    target2.splice(key, 1, val);
    if (ob && !ob.shallow && ob.mock) {
      observe(val, false, true);
    }
    return val;
  }
  if (key in target2 && !(key in Object.prototype)) {
    target2[key] = val;
    return val;
  }
  if (target2._isVue || ob && ob.vmCount) {
    warn("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
    return val;
  }
  if (!ob) {
    target2[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val, void 0, ob.shallow, ob.mock);
  if (true) {
    ob.dep.notify({
      type: "add",
      target: target2,
      key,
      newValue: val,
      oldValue: void 0
    });
  } else {
    ob.dep.notify();
  }
  return val;
}
function del(target2, key) {
  if (isUndef(target2) || isPrimitive(target2)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target2));
  }
  if (isArray(target2) && isValidArrayIndex(key)) {
    target2.splice(key, 1);
    return;
  }
  var ob = target2.__ob__;
  if (target2._isVue || ob && ob.vmCount) {
    warn("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
    return;
  }
  if (isReadonly(target2)) {
    warn('Delete operation on key "'.concat(key, '" failed: target is readonly.'));
    return;
  }
  if (!hasOwn(target2, key)) {
    return;
  }
  delete target2[key];
  if (!ob) {
    return;
  }
  if (true) {
    ob.dep.notify({
      type: "delete",
      target: target2,
      key
    });
  } else {
    ob.dep.notify();
  }
}
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    if (e && e.__ob__) {
      e.__ob__.dep.depend();
    }
    if (isArray(e)) {
      dependArray(e);
    }
  }
}
function shallowReactive(target2) {
  makeReactive(target2, true);
  def(target2, "__v_isShallow", true);
  return target2;
}
function makeReactive(target2, shallow) {
  if (!isReadonly(target2)) {
    if (true) {
      if (isArray(target2)) {
        warn("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
      }
      var existingOb = target2 && target2.__ob__;
      if (existingOb && existingOb.shallow !== shallow) {
        warn("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
      }
    }
    var ob = observe(target2, shallow, isServerRendering());
    if (!ob) {
      if (target2 == null || isPrimitive(target2)) {
        warn("value cannot be made reactive: ".concat(String(target2)));
      }
      if (isCollectionType(target2)) {
        warn("Vue 2 does not support reactive collection types such as Map or Set.");
      }
    }
  }
}
function isReadonly(value) {
  return !!(value && value.__v_isReadonly);
}
function isCollectionType(value) {
  var type = toRawType(value);
  return type === "Map" || type === "WeakMap" || type === "Set" || type === "WeakSet";
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function proxyWithRefUnwrap(target2, source, key) {
  Object.defineProperty(target2, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      var val = source[key];
      if (isRef(val)) {
        return val.value;
      } else {
        var ob = val && val.__ob__;
        if (ob)
          ob.dep.depend();
        return val;
      }
    },
    set: function(value) {
      var oldValue = source[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
      } else {
        source[key] = value;
      }
    }
  });
}
var WATCHER = "watcher";
var WATCHER_CB = "".concat(WATCHER, " callback");
var WATCHER_GETTER = "".concat(WATCHER, " getter");
var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
var activeEffectScope;
var EffectScope = function() {
  function EffectScope3(detached) {
    if (detached === void 0) {
      detached = false;
    }
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  EffectScope3.prototype.run = function(fn) {
    if (this.active) {
      var currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn("cannot run an inactive effect scope.");
    }
  };
  EffectScope3.prototype.on = function() {
    activeEffectScope = this;
  };
  EffectScope3.prototype.off = function() {
    activeEffectScope = this.parent;
  };
  EffectScope3.prototype.stop = function(fromParent) {
    if (this.active) {
      var i = void 0, l = void 0;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].teardown();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        var last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  };
  return EffectScope3;
}();
function recordEffectScope(effect, scope) {
  if (scope === void 0) {
    scope = activeEffectScope;
  }
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function resolveProvided(vm) {
  var existing = vm._provided;
  var parentProvides = vm.$parent && vm.$parent._provided;
  if (parentProvides === existing) {
    return vm._provided = Object.create(parentProvides);
  } else {
    return existing;
  }
}
var normalizeEvent = cached(function(name) {
  var passive = name.charAt(0) === "&";
  name = passive ? name.slice(1) : name;
  var once2 = name.charAt(0) === "~";
  name = once2 ? name.slice(1) : name;
  var capture = name.charAt(0) === "!";
  name = capture ? name.slice(1) : name;
  return {
    name,
    once: once2,
    capture,
    passive
  };
});
function createFnInvoker(fns, vm) {
  function invoker() {
    var fns2 = invoker.fns;
    if (isArray(fns2)) {
      var cloned = fns2.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
      }
    } else {
      return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
    }
  }
  invoker.fns = fns;
  return invoker;
}
function updateListeners(on, oldOn, add2, remove2, createOnceHandler2, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      warn('Invalid handler for event "'.concat(event.name, '": got ') + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler2(event.name, cur, event.capture);
      }
      add2(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove2(event.name, oldOn[name], event.capture);
    }
  }
}
function mergeVNodeHook(def3, hookKey, hook) {
  if (def3 instanceof VNode) {
    def3 = def3.data.hook || (def3.data.hook = {});
  }
  var invoker;
  var oldHook = def3[hookKey];
  function wrappedHook() {
    hook.apply(this, arguments);
    remove$2(invoker.fns, wrappedHook);
  }
  if (isUndef(oldHook)) {
    invoker = createFnInvoker([wrappedHook]);
  } else {
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }
  invoker.merged = true;
  def3[hookKey] = invoker;
}
function extractPropsFromVNodeData(data, Ctor, tag) {
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs2 = data.attrs, props2 = data.props;
  if (isDef(attrs2) || isDef(props2)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs2 && hasOwn(attrs2, keyInLowerCase)) {
          tip('Prop "'.concat(keyInLowerCase, '" is passed to component ') + "".concat(formatComponentName(tag || Ctor), ", but the declared prop name is") + ' "'.concat(key, '". ') + "Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM " + 'templates. You should probably use "'.concat(altKey, '" instead of "').concat(key, '".'));
        }
      }
      checkProp(res, props2, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
    }
  }
  return res;
}
function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : void 0;
}
function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === "boolean")
      continue;
    lastIndex = res.length - 1;
    last = res[lastIndex];
    if (isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, "".concat(nestedIndex || "", "_").concat(i));
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== "") {
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
        }
        res.push(c);
      }
    }
  }
  return res;
}
function renderList(val, render) {
  var ret = null, i, l, keys, key;
  if (isArray(val) || typeof val === "string") {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === "number") {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  ret._isVList = true;
  return ret;
}
function renderSlot(name, fallbackRender, props2, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    props2 = props2 || {};
    if (bindObject) {
      if (!isObject(bindObject)) {
        warn("slot v-bind without argument expects an Object", this);
      }
      props2 = extend(extend({}, bindObject), props2);
    }
    nodes = scopedSlotFn(props2) || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
  }
  var target2 = props2 && props2.slot;
  if (target2) {
    return this.$createElement("template", { slot: target2 }, nodes);
  } else {
    return nodes;
  }
}
function resolveFilter(id) {
  return resolveAsset(this.$options, "filters", id, true) || identity;
}
function isKeyNotMatch(expect, actual) {
  if (isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
  return eventKeyCode === void 0;
}
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      warn("v-bind without argument expects an Object or Array value", this);
    } else {
      if (isArray(value)) {
        value = toObject(value);
      }
      var hash = void 0;
      var _loop_1 = function(key2) {
        if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key2) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key2);
        var hyphenatedKey = hyphenate(key2);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key2] = value[key2];
          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:".concat(key2)] = function($event) {
              value[key2] = $event;
            };
          }
        }
      };
      for (var key in value) {
        _loop_1(key);
      }
    }
  }
  return data;
}
function renderStatic(index2, isInFor) {
  var cached2 = this._staticTrees || (this._staticTrees = []);
  var tree = cached2[index2];
  if (tree && !isInFor) {
    return tree;
  }
  tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, this._c, this);
  markStatic(tree, "__static__".concat(index2), false);
  return tree;
}
function markOnce(tree, index2, key) {
  markStatic(tree, "__once__".concat(index2).concat(key ? "_".concat(key) : ""), true);
  return tree;
}
function markStatic(tree, key, isOnce) {
  if (isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== "string") {
        markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}
function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      warn("v-on without argument expects an Object value", this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}
function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    res.$key = contentHashKey;
  }
  return res;
}
function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === "string" && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== "" && key !== null) {
      warn("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
    }
  }
  return baseObj;
}
function prependModifier(value, symbol) {
  return typeof value === "string" ? symbol + value : value;
}
function installRenderHelpers(target2) {
  target2._o = markOnce;
  target2._n = toNumber;
  target2._s = toString;
  target2._l = renderList;
  target2._t = renderSlot;
  target2._q = looseEqual;
  target2._i = looseIndexOf;
  target2._m = renderStatic;
  target2._f = resolveFilter;
  target2._k = checkKeyCodes;
  target2._b = bindObjectProps;
  target2._v = createTextVNode;
  target2._e = createEmptyVNode;
  target2._u = resolveScopedSlots;
  target2._g = bindObjectListeners;
  target2._d = bindDynamicKeys;
  target2._p = prependModifier;
}
function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name_1 = data.slot;
      var slot = slots[name_1] || (slots[name_1] = []);
      if (child.tag === "template") {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  for (var name_2 in slots) {
    if (slots[name_2].every(isWhitespace)) {
      delete slots[name_2];
    }
  }
  return slots;
}
function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === " ";
}
function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
  var key = scopedSlots && scopedSlots.$key;
  if (!scopedSlots) {
    res = {};
  } else if (scopedSlots._normalized) {
    return scopedSlots._normalized;
  } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject && key === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {
    return prevScopedSlots;
  } else {
    res = {};
    for (var key_1 in scopedSlots) {
      if (scopedSlots[key_1] && key_1[0] !== "$") {
        res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
      }
    }
  }
  for (var key_2 in normalSlots) {
    if (!(key_2 in res)) {
      res[key_2] = proxyNormalSlot(normalSlots, key_2);
    }
  }
  if (scopedSlots && Object.isExtensible(scopedSlots)) {
    scopedSlots._normalized = res;
  }
  def(res, "$stable", isStable);
  def(res, "$key", key);
  def(res, "$hasNormal", hasNormalSlots);
  return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
  var normalized = function() {
    var cur = currentInstance;
    setCurrentInstance(vm);
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === "object" && !isArray(res) ? [res] : normalizeChildren(res);
    var vnode = res && res[0];
    setCurrentInstance(cur);
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
  };
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized;
}
function proxyNormalSlot(slots, key) {
  return function() {
    return slots[key];
  };
}
function initSetup(vm) {
  var options = vm.$options;
  var setup = options.setup;
  if (setup) {
    var ctx = vm._setupContext = createSetupContext(vm);
    setCurrentInstance(vm);
    pushTarget();
    var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
    popTarget();
    setCurrentInstance();
    if (isFunction(setupResult)) {
      options.render = setupResult;
    } else if (isObject(setupResult)) {
      if (setupResult instanceof VNode) {
        warn("setup() should not return VNodes directly - return a render function instead.");
      }
      vm._setupState = setupResult;
      if (!setupResult.__sfc) {
        for (var key in setupResult) {
          if (!isReserved(key)) {
            proxyWithRefUnwrap(vm, setupResult, key);
          } else if (true) {
            warn("Avoid using variables that start with _ or $ in setup().");
          }
        }
      } else {
        var proxy3 = vm._setupProxy = {};
        for (var key in setupResult) {
          if (key !== "__sfc") {
            proxyWithRefUnwrap(proxy3, setupResult, key);
          }
        }
      }
    } else if (setupResult !== void 0) {
      warn("setup() should return an object. Received: ".concat(setupResult === null ? "null" : typeof setupResult));
    }
  }
}
function createSetupContext(vm) {
  var exposeCalled = false;
  return {
    get attrs() {
      if (!vm._attrsProxy) {
        var proxy3 = vm._attrsProxy = {};
        def(proxy3, "_v_attr_proxy", true);
        syncSetupProxy(proxy3, vm.$attrs, emptyObject, vm, "$attrs");
      }
      return vm._attrsProxy;
    },
    get listeners() {
      if (!vm._listenersProxy) {
        var proxy3 = vm._listenersProxy = {};
        syncSetupProxy(proxy3, vm.$listeners, emptyObject, vm, "$listeners");
      }
      return vm._listenersProxy;
    },
    get slots() {
      return initSlotsProxy(vm);
    },
    emit: bind(vm.$emit, vm),
    expose: function(exposed) {
      if (true) {
        if (exposeCalled) {
          warn("expose() should be called only once per setup().", vm);
        }
        exposeCalled = true;
      }
      if (exposed) {
        Object.keys(exposed).forEach(function(key) {
          return proxyWithRefUnwrap(vm, exposed, key);
        });
      }
    }
  };
}
function syncSetupProxy(to, from, prev, instance, type) {
  var changed = false;
  for (var key in from) {
    if (!(key in to)) {
      changed = true;
      defineProxyAttr(to, key, instance, type);
    } else if (from[key] !== prev[key]) {
      changed = true;
    }
  }
  for (var key in to) {
    if (!(key in from)) {
      changed = true;
      delete to[key];
    }
  }
  return changed;
}
function defineProxyAttr(proxy3, key, instance, type) {
  Object.defineProperty(proxy3, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      return instance[type][key];
    }
  });
}
function initSlotsProxy(vm) {
  if (!vm._slotsProxy) {
    syncSetupSlots(vm._slotsProxy = {}, vm.$scopedSlots);
  }
  return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  for (var key in to) {
    if (!(key in from)) {
      delete to[key];
    }
  }
}
function initRender(vm) {
  vm._vnode = null;
  vm._staticTrees = null;
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = parentVnode ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject;
  vm._c = function(a, b, c, d) {
    return createElement$1(vm, a, b, c, d, false);
  };
  vm.$createElement = function(a, b, c, d) {
    return createElement$1(vm, a, b, c, d, true);
  };
  var parentData = parentVnode && parentVnode.data;
  if (true) {
    defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, "$listeners", options._parentListeners || emptyObject, function() {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, "$listeners", options._parentListeners || emptyObject, null, true);
  }
}
var currentRenderingInstance = null;
function renderMixin(Vue3) {
  installRenderHelpers(Vue3.prototype);
  Vue3.prototype.$nextTick = function(fn) {
    return nextTick(fn, this);
  };
  Vue3.prototype._render = function() {
    var vm = this;
    var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
    if (_parentVnode && vm._isMounted) {
      vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
      if (vm._slotsProxy) {
        syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
      }
    }
    vm.$vnode = _parentVnode;
    var vnode;
    try {
      setCurrentInstance(vm);
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e2) {
          handleError(e2, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
      setCurrentInstance();
    }
    if (isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    if (!(vnode instanceof VNode)) {
      if (isArray(vnode)) {
        warn("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
      }
      vnode = createEmptyVNode();
    }
    vnode.parent = _parentVnode;
    return vnode;
  };
}
function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data, context, children, tag };
  return node;
}
function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }
  if (isDef(factory.resolved)) {
    return factory.resolved;
  }
  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    factory.owners.push(owner);
  }
  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }
  if (owner && !isDef(factory.owners)) {
    var owners_1 = factory.owners = [owner];
    var sync_1 = true;
    var timerLoading_1 = null;
    var timerTimeout_1 = null;
    owner.$on("hook:destroyed", function() {
      return remove$2(owners_1, owner);
    });
    var forceRender_1 = function(renderCompleted) {
      for (var i = 0, l = owners_1.length; i < l; i++) {
        owners_1[i].$forceUpdate();
      }
      if (renderCompleted) {
        owners_1.length = 0;
        if (timerLoading_1 !== null) {
          clearTimeout(timerLoading_1);
          timerLoading_1 = null;
        }
        if (timerTimeout_1 !== null) {
          clearTimeout(timerTimeout_1);
          timerTimeout_1 = null;
        }
      }
    };
    var resolve = once(function(res) {
      factory.resolved = ensureCtor(res, baseCtor);
      if (!sync_1) {
        forceRender_1(true);
      } else {
        owners_1.length = 0;
      }
    });
    var reject_1 = once(function(reason) {
      warn("Failed to resolve async component: ".concat(String(factory)) + (reason ? "\nReason: ".concat(reason) : ""));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender_1(true);
      }
    });
    var res_1 = factory(resolve, reject_1);
    if (isObject(res_1)) {
      if (isPromise(res_1)) {
        if (isUndef(factory.resolved)) {
          res_1.then(resolve, reject_1);
        }
      } else if (isPromise(res_1.component)) {
        res_1.component.then(resolve, reject_1);
        if (isDef(res_1.error)) {
          factory.errorComp = ensureCtor(res_1.error, baseCtor);
        }
        if (isDef(res_1.loading)) {
          factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
          if (res_1.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading_1 = setTimeout(function() {
              timerLoading_1 = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender_1(false);
              }
            }, res_1.delay || 200);
          }
        }
        if (isDef(res_1.timeout)) {
          timerTimeout_1 = setTimeout(function() {
            timerTimeout_1 = null;
            if (isUndef(factory.resolved)) {
              reject_1(true ? "timeout (".concat(res_1.timeout, "ms)") : null);
            }
          }, res_1.timeout);
        }
      }
    }
    sync_1 = false;
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
function getFirstComponentChild(children) {
  if (isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = void 0;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + "Always create fresh vnode data objects in each render!", context);
    return createEmptyVNode();
  }
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    return createEmptyVNode();
  }
  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    warn("Avoid using non-primitive value as key, use string/number value instead.", context);
  }
  if (isArray(children) && isFunction(children[0])) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === "string") {
    var Ctor = void 0;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      if (isDef(data) && isDef(data.nativeOn) && data.tag !== "component") {
        warn("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
      }
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      vnode = new VNode(tag, data, children, void 0, void 0, context);
    }
  } else {
    vnode = createComponent(tag, data, context, children);
  }
  if (isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns))
      applyNS(vnode, ns);
    if (isDef(data))
      registerDeepBindings(data);
    return vnode;
  } else {
    return createEmptyVNode();
  }
}
function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === "foreignObject") {
    ns = void 0;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
        applyNS(child, ns, force);
      }
    }
  }
}
function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}
function handleError(err, vm, info) {
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks2 = cur.$options.errorCaptured;
        if (hooks2) {
          for (var i = 0; i < hooks2.length; i++) {
            try {
              var capture = hooks2[i].call(cur, err, vm, info) === false;
              if (capture)
                return;
            } catch (e) {
              globalHandleError(e, cur, "errorCaptured hook");
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function(e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res;
}
function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      if (e !== err) {
        logError(e, null, "config.errorHandler");
      }
    }
  }
  logError(err, vm, info);
}
function logError(err, vm, info) {
  if (true) {
    warn("Error in ".concat(info, ': "').concat(err.toString(), '"'), vm);
  }
  if (inBrowser && typeof console !== "undefined") {
    console.error(err);
  } else {
    throw err;
  }
}
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
var timerFunc;
if (typeof Promise !== "undefined" && isNative(Promise)) {
  p_1 = Promise.resolve();
  timerFunc = function() {
    p_1.then(flushCallbacks);
    if (isIOS)
      setTimeout(noop);
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  counter_1 = 1;
  observer = new MutationObserver(flushCallbacks);
  textNode_1 = document.createTextNode(String(counter_1));
  observer.observe(textNode_1, {
    characterData: true
  });
  timerFunc = function() {
    counter_1 = (counter_1 + 1) % 2;
    textNode_1.data = String(counter_1);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
  timerFunc = function() {
    setImmediate(flushCallbacks);
  };
} else {
  timerFunc = function() {
    setTimeout(flushCallbacks, 0);
  };
}
var p_1;
var counter_1;
var observer;
var textNode_1;
function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function() {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, "nextTick");
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  if (!cb && typeof Promise !== "undefined") {
    return new Promise(function(resolve) {
      _resolve = resolve;
    });
  }
}
function createLifeCycle(hookName) {
  return function(fn, target2) {
    if (target2 === void 0) {
      target2 = currentInstance;
    }
    if (!target2) {
      warn("".concat(formatName(hookName), " is called when there is no active component instance to be ") + "associated with. Lifecycle injection APIs can only be used during execution of setup().");
      return;
    }
    return injectHook(target2, hookName, fn);
  };
}
function formatName(name) {
  if (name === "beforeDestroy") {
    name = "beforeUnmount";
  } else if (name === "destroyed") {
    name = "unmounted";
  }
  return "on".concat(name[0].toUpperCase() + name.slice(1));
}
function injectHook(instance, hookName, fn) {
  var options = instance.$options;
  options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
var onBeforeMount = createLifeCycle("beforeMount");
var onMounted = createLifeCycle("mounted");
var onBeforeUpdate = createLifeCycle("beforeUpdate");
var onUpdated = createLifeCycle("updated");
var onBeforeUnmount = createLifeCycle("beforeDestroy");
var onUnmounted = createLifeCycle("destroyed");
var onErrorCaptured = createLifeCycle("errorCaptured");
var onActivated = createLifeCycle("activated");
var onDeactivated = createLifeCycle("deactivated");
var onServerPrefetch = createLifeCycle("serverPrefetch");
var onRenderTracked = createLifeCycle("renderTracked");
var onRenderTriggered = createLifeCycle("renderTriggered");
var version = "2.7.8";
var seenObjects = new _Set();
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
  return val;
}
function _traverse(val, seen) {
  var i, keys;
  var isA = isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--)
      _traverse(val[i], seen);
  } else if (isRef(val)) {
    _traverse(val.value, seen);
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--)
      _traverse(val[keys[i]], seen);
  }
}
var uid$1 = 0;
var Watcher = function() {
  function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
    recordEffectScope(this, activeEffectScope || (vm ? vm._scope : void 0));
    if (this.vm = vm) {
      if (isRenderWatcher) {
        vm._watcher = this;
      }
    }
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
      if (true) {
        this.onTrack = options.onTrack;
        this.onTrigger = options.onTrigger;
      }
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$1;
    this.active = true;
    this.post = false;
    this.dirty = this.lazy;
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = true ? expOrFn.toString() : "";
    if (isFunction(expOrFn)) {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn('Failed watching path: "'.concat(expOrFn, '" ') + "Watcher only accepts simple dot-delimited paths. For full control, use a function instead.", vm);
      }
    }
    this.value = this.lazy ? void 0 : this.get();
  }
  Watcher2.prototype.get = function() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, 'getter for watcher "'.concat(this.expression, '"'));
      } else {
        throw e;
      }
    } finally {
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };
  Watcher2.prototype.addDep = function(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };
  Watcher2.prototype.cleanupDeps = function() {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
  Watcher2.prototype.update = function() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };
  Watcher2.prototype.run = function() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value || isObject(value) || this.deep) {
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          var info = 'callback for watcher "'.concat(this.expression, '"');
          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };
  Watcher2.prototype.evaluate = function() {
    this.value = this.get();
    this.dirty = false;
  };
  Watcher2.prototype.depend = function() {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };
  Watcher2.prototype.teardown = function() {
    if (this.vm && !this.vm._isBeingDestroyed) {
      remove$2(this.vm._scope.effects, this);
    }
    if (this.active) {
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
      if (this.onStop) {
        this.onStop();
      }
    }
  };
  return Watcher2;
}();
var mark;
var measure;
if (true) {
  perf_1 = inBrowser && window.performance;
  if (perf_1 && perf_1.mark && perf_1.measure && perf_1.clearMarks && perf_1.clearMeasures) {
    mark = function(tag) {
      return perf_1.mark(tag);
    };
    measure = function(name, startTag, endTag) {
      perf_1.measure(name, startTag, endTag);
      perf_1.clearMarks(startTag);
      perf_1.clearMarks(endTag);
    };
  }
}
var perf_1;
function initEvents(vm) {
  vm._events = /* @__PURE__ */ Object.create(null);
  vm._hasHookEvent = false;
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}
var target$1;
function add$1(event, fn) {
  target$1.$on(event, fn);
}
function remove$1(event, fn) {
  target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
  var _target = target$1;
  return function onceHandler() {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}
function updateComponentListeners(vm, listeners, oldListeners) {
  target$1 = vm;
  updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
  target$1 = void 0;
}
function eventsMixin(Vue3) {
  var hookRE = /^hook:/;
  Vue3.prototype.$on = function(event, fn) {
    var vm = this;
    if (isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };
  Vue3.prototype.$once = function(event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };
  Vue3.prototype.$off = function(event, fn) {
    var vm = this;
    if (!arguments.length) {
      vm._events = /* @__PURE__ */ Object.create(null);
      return vm;
    }
    if (isArray(event)) {
      for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
        vm.$off(event[i_1], fn);
      }
      return vm;
    }
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };
  Vue3.prototype.$emit = function(event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip('Event "'.concat(lowerCaseEvent, '" is emitted in component ') + "".concat(formatComponentName(vm), ' but the handler is registered for "').concat(event, '". ') + "Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. " + 'You should probably use "'.concat(hyphenate(event), '" instead of "').concat(event, '".'));
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = 'event handler for "'.concat(event, '"');
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm;
  };
}
var activeInstance = null;
var isUpdatingChildComponent = false;
function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function() {
    activeInstance = prevActiveInstance;
  };
}
function initLifecycle(vm) {
  var options = vm.$options;
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }
  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._provided = parent ? parent._provided : /* @__PURE__ */ Object.create(null);
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue3) {
  Vue3.prototype._update = function(vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    if (!prevVnode) {
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
    } else {
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
  };
  Vue3.prototype.$forceUpdate = function() {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };
  Vue3.prototype.$destroy = function() {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook$1(vm, "beforeDestroy");
    vm._isBeingDestroyed = true;
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove$2(parent.$children, vm);
    }
    vm._scope.stop();
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    vm._isDestroyed = true;
    vm.__patch__(vm._vnode, null);
    callHook$1(vm, "destroyed");
    vm.$off();
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}
function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
        warn("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
      } else {
        warn("Failed to mount component: template or render function not defined.", vm);
      }
    }
  }
  callHook$1(vm, "beforeMount");
  var updateComponent;
  if (config.performance && mark) {
    updateComponent = function() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:".concat(id);
      var endTag = "vue-perf-end:".concat(id);
      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue ".concat(name, " render"), startTag, endTag);
      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue ".concat(name, " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function() {
      vm._update(vm._render(), hydrating);
    };
  }
  var watcherOptions = {
    before: function() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook$1(vm, "beforeUpdate");
      }
    }
  };
  if (true) {
    watcherOptions.onTrack = function(e) {
      return callHook$1(vm, "renderTracked", [e]);
    };
    watcherOptions.onTrigger = function(e) {
      return callHook$1(vm, "renderTriggered", [e]);
    };
  }
  new Watcher(vm, updateComponent, noop, watcherOptions, true);
  hydrating = false;
  var preWatchers = vm._preWatchers;
  if (preWatchers) {
    for (var i = 0; i < preWatchers.length; i++) {
      preWatchers[i].run();
    }
  }
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook$1(vm, "mounted");
  }
  return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  }
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
  var needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
  var prevVNode = vm.$vnode;
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode;
  if (vm._vnode) {
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;
  var attrs2 = parentVnode.data.attrs || emptyObject;
  if (vm._attrsProxy) {
    if (syncSetupProxy(vm._attrsProxy, attrs2, prevVNode.data && prevVNode.data.attrs || emptyObject, vm, "$attrs")) {
      needsForceUpdate = true;
    }
  }
  vm.$attrs = attrs2;
  listeners = listeners || emptyObject;
  var prevListeners = vm.$options._parentListeners;
  if (vm._listenersProxy) {
    syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, "$listeners");
  }
  vm.$listeners = vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, prevListeners);
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props2 = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props;
      props2[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    vm.$options.propsData = propsData;
  }
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
  if (true) {
    isUpdatingChildComponent = false;
  }
}
function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive)
      return true;
  }
  return false;
}
function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook$1(vm, "activated");
  }
}
function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook$1(vm, "deactivated");
  }
}
function callHook$1(vm, hook, args, setContext) {
  if (setContext === void 0) {
    setContext = true;
  }
  pushTarget();
  var prev = currentInstance;
  setContext && setCurrentInstance(vm);
  var handlers = vm.$options[hook];
  var info = "".concat(hook, " hook");
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit("hook:" + hook);
  }
  setContext && setCurrentInstance(prev);
  popTarget();
}
var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}
var currentFlushTimestamp = 0;
var getNow = Date.now;
if (inBrowser && !isIE) {
  performance_1 = window.performance;
  if (performance_1 && typeof performance_1.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
    getNow = function() {
      return performance_1.now();
    };
  }
}
var performance_1;
var sortCompareFn = function(a, b) {
  if (a.post) {
    if (!b.post)
      return 1;
  } else if (b.post) {
    return -1;
  }
  return a.id - b.id;
};
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;
  queue.sort(sortCompareFn);
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "'.concat(watcher.expression, '"') : "in a component render function."), watcher.vm);
        break;
      }
    }
  }
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState();
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);
  if (devtools && config.devtools) {
    devtools.emit("flush");
  }
}
function callUpdatedHooks(queue2) {
  var i = queue2.length;
  while (i--) {
    var watcher = queue2[i];
    var vm = watcher.vm;
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook$1(vm, "updated");
    }
  }
}
function queueActivatedComponent(vm) {
  vm._inactive = false;
  activatedChildren.push(vm);
}
function callActivatedHooks(queue2) {
  for (var i = 0; i < queue2.length; i++) {
    queue2[i]._inactive = true;
    activateChildComponent(queue2[i], true);
  }
}
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] != null) {
    return;
  }
  if (watcher === Dep.target && watcher.noRecurse) {
    return;
  }
  has[id] = true;
  if (!flushing) {
    queue.push(watcher);
  } else {
    var i = queue.length - 1;
    while (i > index && queue[i].id > watcher.id) {
      i--;
    }
    queue.splice(i + 1, 0, watcher);
  }
  if (!waiting) {
    waiting = true;
    if (!config.async) {
      flushSchedulerQueue();
      return;
    }
    nextTick(flushSchedulerQueue);
  }
}
function initProvide(vm) {
  var provideOption = vm.$options.provide;
  if (provideOption) {
    var provided = isFunction(provideOption) ? provideOption.call(vm) : provideOption;
    if (!isObject(provided)) {
      return;
    }
    var source = resolveProvided(vm);
    var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
    }
  }
}
function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function(key) {
      if (true) {
        defineReactive(vm, key, result[key], function() {
          warn("Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. " + 'injection being mutated: "'.concat(key, '"'), vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}
function resolveInject(inject2, vm) {
  if (inject2) {
    var result = /* @__PURE__ */ Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject2) : Object.keys(inject2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key === "__ob__")
        continue;
      var provideKey = inject2[key].from;
      if (provideKey in vm._provided) {
        result[key] = vm._provided[provideKey];
      } else if ("default" in inject2[key]) {
        var provideDefault = inject2[key].default;
        result[key] = isFunction(provideDefault) ? provideDefault.call(vm) : provideDefault;
      } else if (true) {
        warn('Injection "'.concat(key, '" not found'), vm);
      }
    }
    return result;
  }
}
function FunctionalRenderContext(data, props2, children, parent, Ctor) {
  var _this = this;
  var options = Ctor.options;
  var contextVm;
  if (hasOwn(parent, "_uid")) {
    contextVm = Object.create(parent);
    contextVm._original = parent;
  } else {
    contextVm = parent;
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props2;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function() {
    if (!_this.$slots) {
      normalizeScopedSlots(parent, data.scopedSlots, _this.$slots = resolveSlots(children, parent));
    }
    return _this.$slots;
  };
  Object.defineProperty(this, "scopedSlots", {
    enumerable: true,
    get: function() {
      return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
    }
  });
  if (isCompiled) {
    this.$options = options;
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
  }
  if (options._scopeId) {
    this._c = function(a, b, c, d) {
      var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
      if (vnode && !isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function(a, b, c, d) {
      return createElement$1(contextVm, a, b, c, d, needNormalization);
    };
  }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props2 = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props2[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs))
      mergeProps(props2, data.attrs);
    if (isDef(data.props))
      mergeProps(props2, data.props);
  }
  var renderContext = new FunctionalRenderContext(data, props2, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);
  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res;
  }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone;
}
function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
function getComponentName(options) {
  return options.name || options.__name || options._componentTag;
}
var componentVNodeHooks = {
  init: function(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      var mountedNode = vnode;
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : void 0, hydrating);
    }
  },
  prepatch: function(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
  },
  insert: function(vnode) {
    var context = vnode.context, componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook$1(componentInstance, "mounted");
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true);
      }
    }
  },
  destroy: function(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true);
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }
  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
  if (typeof Ctor !== "function") {
    if (true) {
      warn("Invalid Component definition: ".concat(String(Ctor)), context);
    }
    return;
  }
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === void 0) {
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }
  data = data || {};
  resolveConstructorOptions(Ctor);
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }
  var listeners = data.on;
  data.on = data.nativeOn;
  if (isTrue(Ctor.options.abstract)) {
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }
  installComponentHooks(data);
  var name = getComponentName(Ctor.options) || tag;
  var vnode = new VNode("vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ""), data, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
  return vnode;
}
function createComponentInstanceForVnode(vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  };
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
  var hooks2 = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks2[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks2[key] = existing ? mergeHook(toMerge, existing) : toMerge;
    }
  }
}
function mergeHook(f1, f2) {
  var merged = function(a, b) {
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged;
}
function transformModel(options, data) {
  var prop = options.model && options.model.prop || "value";
  var event = options.model && options.model.event || "input";
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
var warn = noop;
var tip = noop;
var generateComponentTrace;
var formatComponentName;
if (true) {
  hasConsole_1 = typeof console !== "undefined";
  classifyRE_1 = /(?:^|[-_])(\w)/g;
  classify_1 = function(str) {
    return str.replace(classifyRE_1, function(c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, "");
  };
  warn = function(msg, vm) {
    if (vm === void 0) {
      vm = currentInstance;
    }
    var trace = vm ? generateComponentTrace(vm) : "";
    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole_1 && !config.silent) {
      console.error("[Vue warn]: ".concat(msg).concat(trace));
    }
  };
  tip = function(msg, vm) {
    if (hasConsole_1 && !config.silent) {
      console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ""));
    }
  };
  formatComponentName = function(vm, includeFile) {
    if (vm.$root === vm) {
      return "<Root>";
    }
    var options = isFunction(vm) && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = getComponentName(options);
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }
    return (name ? "<".concat(classify_1(name), ">") : "<Anonymous>") + (file && includeFile !== false ? " at ".concat(file) : "");
  };
  repeat_1 = function(str, n) {
    var res = "";
    while (n) {
      if (n % 2 === 1)
        res += str;
      if (n > 1)
        str += str;
      n >>= 1;
    }
    return res;
  };
  generateComponentTrace = function(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return "\n\nfound in\n\n" + tree.map(function(vm2, i) {
        return "".concat(i === 0 ? "---> " : repeat_1(" ", 5 + i * 2)).concat(isArray(vm2) ? "".concat(formatComponentName(vm2[0]), "... (").concat(vm2[1], " recursive calls)") : formatComponentName(vm2));
      }).join("\n");
    } else {
      return "\n\n(found in ".concat(formatComponentName(vm), ")");
    }
  };
}
var hasConsole_1;
var classifyRE_1;
var classify_1;
var repeat_1;
var strats = config.optionMergeStrategies;
if (true) {
  strats.el = strats.propsData = function(parent, child, vm, key) {
    if (!vm) {
      warn('option "'.concat(key, '" can only be used during instance ') + "creation with the `new` keyword.");
    }
    return defaultStrat(parent, child);
  };
}
function mergeData(to, from) {
  if (!from)
    return to;
  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    if (key === "__ob__")
      continue;
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    return function mergedDataFn() {
      return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      var instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal;
      var defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}
strats.data = function(parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== "function") {
      warn('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }
  return mergeDataOrFn(parentVal, childVal, vm);
};
function mergeLifecycleHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks2) {
  var res = [];
  for (var i = 0; i < hooks2.length; i++) {
    if (res.indexOf(hooks2[i]) === -1) {
      res.push(hooks2[i]);
    }
  }
  return res;
}
LIFECYCLE_HOOKS.forEach(function(hook) {
  strats[hook] = mergeLifecycleHook;
});
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}
ASSET_TYPES.forEach(function(type) {
  strats[type + "s"] = mergeAssets;
});
strats.watch = function(parentVal, childVal, vm, key) {
  if (parentVal === nativeWatch)
    parentVal = void 0;
  if (childVal === nativeWatch)
    childVal = void 0;
  if (!childVal)
    return Object.create(parentVal || null);
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal)
    return childVal;
  var ret = {};
  extend(ret, parentVal);
  for (var key_1 in childVal) {
    var parent_1 = ret[key_1];
    var child = childVal[key_1];
    if (parent_1 && !isArray(parent_1)) {
      parent_1 = [parent_1];
    }
    ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
  }
  return ret;
};
strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
  if (childVal && true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal)
    return childVal;
  var ret = /* @__PURE__ */ Object.create(null);
  extend(ret, parentVal);
  if (childVal)
    extend(ret, childVal);
  return ret;
};
strats.provide = mergeDataOrFn;
var defaultStrat = function(parentVal, childVal) {
  return childVal === void 0 ? parentVal : childVal;
};
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}
function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
    warn('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function normalizeProps(options, vm) {
  var props2 = options.props;
  if (!props2)
    return;
  var res = {};
  var i, val, name;
  if (isArray(props2)) {
    i = props2.length;
    while (i--) {
      val = props2[i];
      if (typeof val === "string") {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn("props must be strings when using array syntax.");
      }
    }
  } else if (isPlainObject(props2)) {
    for (var key in props2) {
      val = props2[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (true) {
    warn('Invalid value for option "props": expected an Array or an Object, ' + "but got ".concat(toRawType(props2), "."), vm);
  }
  options.props = res;
}
function normalizeInject(options, vm) {
  var inject2 = options.inject;
  if (!inject2)
    return;
  var normalized = options.inject = {};
  if (isArray(inject2)) {
    for (var i = 0; i < inject2.length; i++) {
      normalized[inject2[i]] = { from: inject2[i] };
    }
  } else if (isPlainObject(inject2)) {
    for (var key in inject2) {
      var val = inject2[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (true) {
    warn('Invalid value for option "inject": expected an Array or an Object, ' + "but got ".concat(toRawType(inject2), "."), vm);
  }
}
function normalizeDirectives$1(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def3 = dirs[key];
      if (isFunction(def3)) {
        dirs[key] = { bind: def3, update: def3 };
      }
    }
  }
}
function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn('Invalid value for option "'.concat(name, '": expected an Object, ') + "but got ".concat(toRawType(value), "."), vm);
  }
}
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }
  if (isFunction(child)) {
    child = child.options;
  }
  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives$1(child);
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key2) {
    var strat = strats[key2] || defaultStrat;
    options[key2] = strat(parent[key2], child[key2], vm, key2);
  }
  return options;
}
function resolveAsset(options, type, id, warnMissing) {
  if (typeof id !== "string") {
    return;
  }
  var assets = options[type];
  if (hasOwn(assets, id))
    return assets[id];
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId))
    return assets[camelizedId];
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId))
    return assets[PascalCaseId];
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (warnMissing && !res) {
    warn("Failed to resolve " + type.slice(0, -1) + ": " + id);
  }
  return res;
}
function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, "default")) {
      value = false;
    } else if (value === "" || value === hyphenate(key)) {
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  if (value === void 0) {
    value = getPropDefaultValue(vm, prop, key);
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
function getPropDefaultValue(vm, prop, key) {
  if (!hasOwn(prop, "default")) {
    return void 0;
  }
  var def3 = prop.default;
  if (isObject(def3)) {
    warn('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
  }
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
    return vm._props[key];
  }
  return isFunction(def3) && getType(prop.type) !== "Function" ? def3.call(vm) : def3;
}
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || "");
      valid = assertedType.valid;
    }
  }
  var haveExpectedTypes = expectedTypes.some(function(t) {
    return t;
  });
  if (!valid && haveExpectedTypes) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}
var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isPlainObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid,
    expectedType
  };
}
var functionTypeCheckRE = /^\s*function (\w+)/;
function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (!isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }
  return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = 'Invalid prop: type check failed for prop "'.concat(name, '".') + " Expected ".concat(expectedTypes.map(capitalize).join(", "));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
    message += " with value ".concat(styleValue(value, expectedType));
  }
  message += ", got ".concat(receivedType, " ");
  if (isExplicable(receivedType)) {
    message += "with value ".concat(styleValue(value, receivedType), ".");
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return '"'.concat(value, '"');
  } else if (type === "Number") {
    return "".concat(Number(value));
  } else {
    return "".concat(value);
  }
}
var EXPLICABLE_TYPES = ["string", "number", "boolean"];
function isExplicable(value) {
  return EXPLICABLE_TYPES.some(function(elem) {
    return value.toLowerCase() === elem;
  });
}
function isBoolean() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.some(function(elem) {
    return elem.toLowerCase() === "boolean";
  });
}
var initProxy;
if (true) {
  allowedGlobals_1 = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
  warnNonPresent_1 = function(target2, key) {
    warn('Property or method "'.concat(key, '" is not defined on the instance but ') + "referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.", target2);
  };
  warnReservedPrefix_1 = function(target2, key) {
    warn('Property "'.concat(key, '" must be accessed with "$data.').concat(key, '" because ') + 'properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data', target2);
  };
  hasProxy_1 = typeof Proxy !== "undefined" && isNative(Proxy);
  if (hasProxy_1) {
    isBuiltInModifier_1 = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function(target2, key, value) {
        if (isBuiltInModifier_1(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
          return false;
        } else {
          target2[key] = value;
          return true;
        }
      }
    });
  }
  hasHandler_1 = {
    has: function(target2, key) {
      var has2 = key in target2;
      var isAllowed = allowedGlobals_1(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
      if (!has2 && !isAllowed) {
        if (key in target2.$data)
          warnReservedPrefix_1(target2, key);
        else
          warnNonPresent_1(target2, key);
      }
      return has2 || !isAllowed;
    }
  };
  getHandler_1 = {
    get: function(target2, key) {
      if (typeof key === "string" && !(key in target2)) {
        if (key in target2.$data)
          warnReservedPrefix_1(target2, key);
        else
          warnNonPresent_1(target2, key);
      }
      return target2[key];
    }
  };
  initProxy = function initProxy2(vm) {
    if (hasProxy_1) {
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
var allowedGlobals_1;
var warnNonPresent_1;
var warnReservedPrefix_1;
var hasProxy_1;
var isBuiltInModifier_1;
var hasHandler_1;
var getHandler_1;
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};
function proxy(target2, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function initState(vm) {
  var opts = vm.$options;
  if (opts.props)
    initProps$1(vm, opts.props);
  initSetup(vm);
  if (opts.methods)
    initMethods(vm, opts.methods);
  if (opts.data) {
    initData(vm);
  } else {
    var ob = observe(vm._data = {});
    ob && ob.vmCount++;
  }
  if (opts.computed)
    initComputed$1(vm, opts.computed);
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
function initProps$1(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props2 = vm._props = shallowReactive({});
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var _loop_1 = function(key2) {
    keys.push(key2);
    var value = validateProp(key2, propsOptions, propsData, vm);
    if (true) {
      var hyphenatedKey = hyphenate(key2);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn('"'.concat(hyphenatedKey, '" is a reserved attribute and cannot be used as component prop.'), vm);
      }
      defineReactive(props2, key2, value, function() {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's " + 'value. Prop being mutated: "'.concat(key2, '"'), vm);
        }
      });
    } else {
      defineReactive(props2, key2, value);
    }
    if (!(key2 in vm)) {
      proxy(vm, "_props", key2);
    }
  };
  for (var key in propsOptions) {
    _loop_1(key);
  }
  toggleObserving(true);
}
function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    warn("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
  }
  var keys = Object.keys(data);
  var props2 = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn('Method "'.concat(key, '" has already been defined as a data property.'), vm);
      }
    }
    if (props2 && hasOwn(props2, key)) {
      warn('The data property "'.concat(key, '" is already declared as a prop. ') + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  var ob = observe(data);
  ob && ob.vmCount++;
}
function getData(data, vm) {
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed2) {
  var watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
  var isSSR = isServerRendering();
  for (var key in computed2) {
    var userDef = computed2[key];
    var getter = isFunction(userDef) ? userDef : userDef.get;
    if (getter == null) {
      warn('Getter is missing for computed property "'.concat(key, '".'), vm);
    }
    if (!isSSR) {
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn('The computed property "'.concat(key, '" is already defined in data.'), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn('The computed property "'.concat(key, '" is already defined as a prop.'), vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn('The computed property "'.concat(key, '" is already defined as a method.'), vm);
      }
    }
  }
}
function defineComputed(target2, key, userDef) {
  var shouldCache = !isServerRendering();
  if (isFunction(userDef)) {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function() {
      warn('Computed property "'.concat(key, '" was assigned to but it has no setter.'), this);
    };
  }
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        if (Dep.target.onTrack) {
          Dep.target.onTrack({
            effect: Dep.target,
            target: this,
            type: "get",
            key
          });
        }
        watcher.depend();
      }
      return watcher.value;
    }
  };
}
function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}
function initMethods(vm, methods) {
  var props2 = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== "function") {
        warn('Method "'.concat(key, '" has type "').concat(typeof methods[key], '" in the component definition. ') + "Did you reference the function correctly?", vm);
      }
      if (props2 && hasOwn(props2, key)) {
        warn('Method "'.concat(key, '" has already been defined as a prop.'), vm);
      }
      if (key in vm && isReserved(key)) {
        warn('Method "'.concat(key, '" conflicts with an existing Vue instance method. ') + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
  }
}
function initWatch(vm, watch2) {
  for (var key in watch2) {
    var handler = watch2[key];
    if (isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}
function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === "string") {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue3) {
  var dataDef = {};
  dataDef.get = function() {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function() {
    return this._props;
  };
  if (true) {
    dataDef.set = function() {
      warn("Avoid replacing instance root $data. Use nested data properties instead.", this);
    };
    propsDef.set = function() {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue3.prototype, "$data", dataDef);
  Object.defineProperty(Vue3.prototype, "$props", propsDef);
  Vue3.prototype.$set = set;
  Vue3.prototype.$delete = del;
  Vue3.prototype.$watch = function(expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = 'callback for immediate watcher "'.concat(watcher.expression, '"');
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
var uid = 0;
function initMixin$1(Vue3) {
  Vue3.prototype._init = function(options) {
    var vm = this;
    vm._uid = uid++;
    var startTag, endTag;
    if (config.performance && mark) {
      startTag = "vue-perf-start:".concat(vm._uid);
      endTag = "vue-perf-end:".concat(vm._uid);
      mark(startTag);
    }
    vm._isVue = true;
    vm.__v_skip = true;
    vm._scope = new EffectScope(true);
    if (options && options._isComponent) {
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook$1(vm, "beforeCreate", void 0, false);
    initInjections(vm);
    initState(vm);
    initProvide(vm);
    callHook$1(vm, "created");
    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue ".concat(vm._name, " init"), startTag, endTag);
    }
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}
function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}
function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions;
      var modifiedOptions = resolveModifiedOptions(Ctor);
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}
function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified)
        modified = {};
      modified[key] = latest[key];
    }
  }
  return modified;
}
function Vue(options) {
  if (!(this instanceof Vue)) {
    warn("Vue is a constructor and should be called with the `new` keyword");
  }
  this._init(options);
}
initMixin$1(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
function initUse(Vue3) {
  Vue3.use = function(plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (isFunction(plugin.install)) {
      plugin.install.apply(plugin, args);
    } else if (isFunction(plugin)) {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}
function initMixin(Vue3) {
  Vue3.mixin = function(mixin2) {
    this.options = mergeOptions(this.options, mixin2);
    return this;
  };
}
function initExtend(Vue3) {
  Vue3.cid = 0;
  var cid = 1;
  Vue3.extend = function(extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }
    var name = getComponentName(extendOptions) || getComponentName(Super.options);
    if (name) {
      validateComponentName(name);
    }
    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub["super"] = Super;
    if (Sub.options.props) {
      initProps(Sub);
    }
    if (Sub.options.computed) {
      initComputed(Sub);
    }
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;
    ASSET_TYPES.forEach(function(type) {
      Sub[type] = Super[type];
    });
    if (name) {
      Sub.options.components[name] = Sub;
    }
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}
function initProps(Comp) {
  var props2 = Comp.options.props;
  for (var key in props2) {
    proxy(Comp.prototype, "_props", key);
  }
}
function initComputed(Comp) {
  var computed2 = Comp.options.computed;
  for (var key in computed2) {
    defineComputed(Comp.prototype, key, computed2[key]);
  }
}
function initAssetRegisters(Vue3) {
  ASSET_TYPES.forEach(function(type) {
    Vue3[type] = function(id, definition) {
      if (!definition) {
        return this.options[type + "s"][id];
      } else {
        if (type === "component") {
          validateComponentName(id);
        }
        if (type === "component" && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === "directive" && isFunction(definition)) {
          definition = { bind: definition, update: definition };
        }
        this.options[type + "s"][id] = definition;
        return definition;
      }
    };
  });
}
function _getComponentName(opts) {
  return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === "string") {
    return pattern.split(",").indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name_1 = entry.name;
      if (name_1 && !filter(name_1)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}
function pruneCacheEntry(cache, key, keys, current) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove$2(keys, key);
}
var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: "keep-alive",
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function() {
      var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: _getComponentName(componentOptions),
          tag,
          componentInstance
        };
        keys.push(keyToCache);
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },
  created: function() {
    this.cache = /* @__PURE__ */ Object.create(null);
    this.keys = [];
  },
  destroyed: function() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function() {
    var _this = this;
    this.cacheVNode();
    this.$watch("include", function(val) {
      pruneCache(_this, function(name) {
        return matches(val, name);
      });
    });
    this.$watch("exclude", function(val) {
      pruneCache(_this, function(name) {
        return !matches(val, name);
      });
    });
  },
  updated: function() {
    this.cacheVNode();
  },
  render: function() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      var name_2 = _getComponentName(componentOptions);
      var _a = this, include = _a.include, exclude = _a.exclude;
      if (include && (!name_2 || !matches(include, name_2)) || exclude && name_2 && matches(exclude, name_2)) {
        return vnode;
      }
      var _b = this, cache = _b.cache, keys = _b.keys;
      var key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? "::".concat(componentOptions.tag) : "") : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        remove$2(keys, key);
        keys.push(key);
      } else {
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }
      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive
};
function initGlobalAPI(Vue3) {
  var configDef = {};
  configDef.get = function() {
    return config;
  };
  if (true) {
    configDef.set = function() {
      warn("Do not replace the Vue.config object, set individual fields instead.");
    };
  }
  Object.defineProperty(Vue3, "config", configDef);
  Vue3.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  };
  Vue3.set = set;
  Vue3.delete = del;
  Vue3.nextTick = nextTick;
  Vue3.observable = function(obj) {
    observe(obj);
    return obj;
  };
  Vue3.options = /* @__PURE__ */ Object.create(null);
  ASSET_TYPES.forEach(function(type) {
    Vue3.options[type + "s"] = /* @__PURE__ */ Object.create(null);
  });
  Vue3.options._base = Vue3;
  extend(Vue3.options.components, builtInComponents);
  initUse(Vue3);
  initMixin(Vue3);
  initExtend(Vue3);
  initAssetRegisters(Vue3);
}
initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, "$isServer", {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, "$ssrContext", {
  get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty(Vue, "FunctionalRenderContext", {
  value: FunctionalRenderContext
});
Vue.version = version;
var isReservedAttr = makeMap("style,class");
var acceptValue = makeMap("input,textarea,option,select,progress");
var mustUseProp = function(tag, type, attr) {
  return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
};
var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
var convertEnumeratedValue = function(key, value) {
  return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
};
var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
var xlinkNS = "http://www.w3.org/1999/xlink";
var isXlink = function(name) {
  return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
};
var getXlinkProp = function(name) {
  return isXlink(name) ? name.slice(6, name.length) : "";
};
var isFalsyAttrValue = function(val) {
  return val == null || val === false;
};
function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode2 = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode2 = parentNode2.parent)) {
    if (parentNode2 && parentNode2.data) {
      data = mergeClassData(data, parentNode2.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}
function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  return "";
}
function concat(a, b) {
  return a ? b ? a + " " + b : a : b || "";
}
function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === "string") {
    return value;
  }
  return "";
}
function stringifyArray(value) {
  var res = "";
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
      if (res)
        res += " ";
      res += stringified;
    }
  }
  return res;
}
function stringifyObject(value) {
  var res = "";
  for (var key in value) {
    if (value[key]) {
      if (res)
        res += " ";
      res += key;
    }
  }
  return res;
}
var namespaceMap = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
};
var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
var isReservedTag = function(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return "svg";
  }
  if (tag === "math") {
    return "math";
  }
}
var unknownElementCache = /* @__PURE__ */ Object.create(null);
function isUnknownElement(tag) {
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf("-") > -1) {
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}
var isTextInputType = makeMap("text,number,password,search,email,tel,url");
function query(el) {
  if (typeof el === "string") {
    var selected = document.querySelector(el);
    if (!selected) {
      warn("Cannot find element: " + el);
      return document.createElement("div");
    }
    return selected;
  } else {
    return el;
  }
}
function createElement(tagName2, vnode) {
  var elm = document.createElement(tagName2);
  if (tagName2 !== "select") {
    return elm;
  }
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
    elm.setAttribute("multiple", "multiple");
  }
  return elm;
}
function createElementNS(namespace, tagName2) {
  return document.createElementNS(namespaceMap[namespace], tagName2);
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function createComment(text) {
  return document.createComment(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(node) {
  return node.tagName;
}
function setTextContent(node, text) {
  node.textContent = text;
}
function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, "");
}
var nodeOps = Object.freeze({
  __proto__: null,
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  setStyleScope
});
var ref = {
  create: function(_, vnode) {
    registerRef(vnode);
  },
  update: function(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function(vnode) {
    registerRef(vnode, true);
  }
};
function registerRef(vnode, isRemoval) {
  var ref3 = vnode.data.ref;
  if (!isDef(ref3))
    return;
  var vm = vnode.context;
  var refValue = vnode.componentInstance || vnode.elm;
  var value = isRemoval ? null : refValue;
  var $refsValue = isRemoval ? void 0 : refValue;
  if (isFunction(ref3)) {
    invokeWithErrorHandling(ref3, vm, [value], vm, "template ref function");
    return;
  }
  var isFor = vnode.data.refInFor;
  var _isString = typeof ref3 === "string" || typeof ref3 === "number";
  var _isRef = isRef(ref3);
  var refs = vm.$refs;
  if (_isString || _isRef) {
    if (isFor) {
      var existing = _isString ? refs[ref3] : ref3.value;
      if (isRemoval) {
        isArray(existing) && remove$2(existing, refValue);
      } else {
        if (!isArray(existing)) {
          if (_isString) {
            refs[ref3] = [refValue];
            setSetupRef(vm, ref3, refs[ref3]);
          } else {
            ref3.value = [refValue];
          }
        } else if (!existing.includes(refValue)) {
          existing.push(refValue);
        }
      }
    } else if (_isString) {
      if (isRemoval && refs[ref3] !== refValue) {
        return;
      }
      refs[ref3] = $refsValue;
      setSetupRef(vm, ref3, value);
    } else if (_isRef) {
      if (isRemoval && ref3.value !== refValue) {
        return;
      }
      ref3.value = value;
    } else if (true) {
      warn("Invalid template ref type: ".concat(typeof ref3));
    }
  }
}
function setSetupRef(_a, key, val) {
  var _setupState = _a._setupState;
  if (_setupState && hasOwn(_setupState, key)) {
    if (isRef(_setupState[key])) {
      _setupState[key].value = val;
    } else {
      _setupState[key] = val;
    }
  }
}
var emptyNode = new VNode("", {}, []);
var hooks = ["create", "activate", "update", "remove", "destroy"];
function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}
function sameInputType(a, b) {
  if (a.tag !== "input")
    return true;
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key))
      map[key] = i;
  }
  return map;
}
function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules2 = backend.modules, nodeOps2 = backend.nodeOps;
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules2.length; ++j) {
      if (isDef(modules2[j][hooks[i]])) {
        cbs[hooks[i]].push(modules2[j][hooks[i]]);
      }
    }
  }
  function emptyNodeAt(elm) {
    return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    function remove2() {
      if (--remove2.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove2.listeners = listeners;
    return remove2;
  }
  function removeNode(el) {
    var parent = nodeOps2.parentNode(el);
    if (isDef(parent)) {
      nodeOps2.removeChild(parent, el);
    }
  }
  function isUnknownElement2(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }
  var creatingElmInVPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    vnode.isRootInsert = !nested;
    if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }
    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement2(vnode, creatingElmInVPre)) {
          warn("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
      setScope(vnode);
      createChildren(vnode, children, insertedVnodeQueue);
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
      }
      insert(parentElm, vnode.elm, refElm);
      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps2.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps2.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }
  function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2 = vnode.data;
    if (isDef(i2)) {
      var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
      if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
        i2(vnode, false);
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }
  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      registerRef(vnode);
      insertedVnodeQueue.push(vnode);
    }
  }
  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2;
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
        for (i2 = 0; i2 < cbs.activate.length; ++i2) {
          cbs.activate[i2](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    insert(parentElm, vnode.elm, refElm);
  }
  function insert(parent, elm, ref3) {
    if (isDef(parent)) {
      if (isDef(ref3)) {
        if (nodeOps2.parentNode(ref3) === parent) {
          nodeOps2.insertBefore(parent, elm, ref3);
        }
      } else {
        nodeOps2.appendChild(parent, elm);
      }
    }
  }
  function createChildren(vnode, children, insertedVnodeQueue) {
    if (isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i_1 = 0; i_1 < children.length; ++i_1) {
        createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
    }
  }
  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }
  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
      cbs.create[i_2](emptyNode, vnode);
    }
    i = vnode.data.hook;
    if (isDef(i)) {
      if (isDef(i.create))
        i.create(emptyNode, vnode);
      if (isDef(i.insert))
        insertedVnodeQueue.push(vnode);
    }
  }
  function setScope(vnode) {
    var i2;
    if (isDef(i2 = vnode.fnScopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
          nodeOps2.setStyleScope(vnode.elm, i2);
        }
        ancestor = ancestor.parent;
      }
    }
    if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    }
  }
  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }
  function invokeDestroyHook(vnode) {
    var i2, j2;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy))
        i2(vnode);
      for (i2 = 0; i2 < cbs.destroy.length; ++i2)
        cbs.destroy[i2](vnode);
    }
    if (isDef(i2 = vnode.children)) {
      for (j2 = 0; j2 < vnode.children.length; ++j2) {
        invokeDestroyHook(vnode.children[j2]);
      }
    }
  }
  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          removeNode(ch.elm);
        }
      }
    }
  }
  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i_3;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        rm.listeners += listeners;
      } else {
        rm = createRmCb(vnode.elm, listeners);
      }
      if (isDef(i_3 = vnode.componentInstance) && isDef(i_3 = i_3._vnode) && isDef(i_3.data)) {
        removeAndInvokeRemoveHook(i_3, rm);
      }
      for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
        cbs.remove[i_3](vnode, rm);
      }
      if (isDef(i_3 = vnode.data.hook) && isDef(i_3 = i_3.remove)) {
        i_3(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
    var canMove = !removeOnly;
    if (true) {
      checkDuplicateKeys(newCh);
    }
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx))
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = void 0;
            canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }
  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i_4 = 0; i_4 < children.length; i_4++) {
      var vnode = children[i_4];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }
  function findIdxInOld(node, oldCh, start, end) {
    for (var i_5 = start; i_5 < end; i_5++) {
      var c = oldCh[i_5];
      if (isDef(c) && sameVnode(node, c))
        return i_5;
    }
  }
  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i2;
    var data = vnode.data;
    if (isDef(data) && isDef(i2 = data.hook) && isDef(i2 = i2.prepatch)) {
      i2(oldVnode, vnode);
    }
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i2 = 0; i2 < cbs.update.length; ++i2)
        cbs.update[i2](oldVnode, vnode);
      if (isDef(i2 = data.hook) && isDef(i2 = i2.update))
        i2(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch)
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text))
          nodeOps2.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps2.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps2.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.postpatch))
        i2(oldVnode, vnode);
    }
  }
  function invokeInsertHook(vnode, queue2, initial) {
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue2;
    } else {
      for (var i_6 = 0; i_6 < queue2.length; ++i_6) {
        queue2[i_6].data.hook.insert(queue2[i_6]);
      }
    }
  }
  var hydrationBailed = false;
  var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i2;
    var tag = vnode.tag, data = vnode.data, children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.init))
        i2(vnode, true);
      if (isDef(i2 = vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          if (isDef(i2 = data) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
            if (i2 !== elm.innerHTML) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true;
                console.warn("Parent: ", elm);
                console.warn("server innerHTML: ", i2);
                console.warn("client innerHTML: ", elm.innerHTML);
              }
              return false;
            }
          } else {
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i_7 = 0; i_7 < children.length; i_7++) {
              if (!childNode || !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            if (!childrenMatch || childNode) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true;
                console.warn("Parent: ", elm);
                console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data["class"]) {
          traverse(data["class"]);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }
  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement2(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }
  return function patch2(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode))
        invokeDestroyHook(oldVnode);
      return;
    }
    var isInitialPatch = false;
    var insertedVnodeQueue = [];
    if (isUndef(oldVnode)) {
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
            }
          }
          oldVnode = emptyNodeAt(oldVnode);
        }
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps2.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
              cbs.destroy[i_8](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                cbs.create[i_9](emptyNode, ancestor);
              }
              var insert_1 = ancestor.data.hook.insert;
              if (insert_1.merged) {
                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
                  insert_1.fns[i_10]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};
function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}
function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      callHook(dir, "bind", vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook(dir, "update", vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }
  if (dirsWithInsert.length) {
    var callInsert = function() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], "inserted", vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, "insert", callInsert);
    } else {
      callInsert();
    }
  }
  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, "postpatch", function() {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
      }
    });
  }
  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        callHook(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
      }
    }
  }
}
var emptyModifiers = /* @__PURE__ */ Object.create(null);
function normalizeDirectives(dirs, vm) {
  var res = /* @__PURE__ */ Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    if (vm._setupState && vm._setupState.__sfc) {
      dir.def = dir.def || resolveAsset(vm, "_setupState", "v-" + dir.name);
    }
    dir.def = dir.def || resolveAsset(vm.$options, "directives", dir.name, true);
  }
  return res;
}
function getRawDirName(dir) {
  return dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join("."));
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
    }
  }
}
var baseModules = [ref, directives];
function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs2 = vnode.data.attrs || {};
  if (isDef(attrs2.__ob__) || isTrue(attrs2._v_attr_proxy)) {
    attrs2 = vnode.data.attrs = extend({}, attrs2);
  }
  for (key in attrs2) {
    cur = attrs2[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
    setAttr(elm, "value", attrs2.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs2[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}
function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf("-") > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}
function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
      var blocker_1 = function(e) {
        e.stopImmediatePropagation();
        el.removeEventListener("input", blocker_1);
      };
      el.addEventListener("input", blocker_1);
      el.__ieph = true;
    }
    el.setAttribute(key, value);
  }
}
var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }
  var cls = genClassForVnode(vnode);
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }
  if (cls !== el._prevClass) {
    el.setAttribute("class", cls);
    el._prevClass = cls;
  }
}
var klass = {
  create: updateClass,
  update: updateClass
};
var RANGE_TOKEN = "__r";
var CHECKBOX_RADIO_TOKEN = "__c";
function normalizeEvents(on) {
  if (isDef(on[RANGE_TOKEN])) {
    var event_1 = isIE ? "change" : "input";
    on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}
var target;
function createOnceHandler(event, handler, capture) {
  var _target = target;
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove(event, onceHandler, capture, _target);
    }
  };
}
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
  if (useMicrotaskFix) {
    var attachedTimestamp_1 = currentFlushTimestamp;
    var original_1 = handler;
    handler = original_1._wrapper = function(e) {
      if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp_1 || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
        return original_1.apply(this, arguments);
      }
    };
  }
  target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);
}
function remove(name, handler, capture, _target) {
  (_target || target).removeEventListener(name, handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target = vnode.elm || oldVnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
  target = void 0;
}
var events = {
  create: updateDOMListeners,
  update: updateDOMListeners,
  destroy: function(vnode) {
    return updateDOMListeners(vnode, emptyNode);
  }
};
var svgContainer;
function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props2 = vnode.data.domProps || {};
  if (isDef(props2.__ob__) || isTrue(props2._v_attr_proxy)) {
    props2 = vnode.data.domProps = extend({}, props2);
  }
  for (key in oldProps) {
    if (!(key in props2)) {
      elm[key] = "";
    }
  }
  for (key in props2) {
    cur = props2[key];
    if (key === "textContent" || key === "innerHTML") {
      if (vnode.children)
        vnode.children.length = 0;
      if (cur === oldProps[key])
        continue;
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }
    if (key === "value" && elm.tagName !== "PROGRESS") {
      elm._value = cur;
      var strCur = isUndef(cur) ? "" : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      svgContainer = svgContainer || document.createElement("div");
      svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (cur !== oldProps[key]) {
      try {
        elm[key] = cur;
      } catch (e) {
      }
    }
  }
}
function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}
function isNotInFocusAndDirty(elm, checkVal) {
  var notInFocus = true;
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {
  }
  return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers;
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}
var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
var parseStyleText = cached(function(cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});
function normalizeStyleData(data) {
  var style2 = normalizeStyleBinding(data.style);
  return data.staticStyle ? extend(data.staticStyle, style2) : style2;
}
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === "string") {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;
  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }
  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }
  var parentNode2 = vnode;
  while (parentNode2 = parentNode2.parent) {
    if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
      extend(res, styleData);
    }
  }
  return res;
}
var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function(el, name, val) {
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};
var vendorNames = ["Webkit", "Moz", "ms"];
var emptyStyle;
var normalize = cached(function(prop) {
  emptyStyle = emptyStyle || document.createElement("div").style;
  prop = camelize(prop);
  if (prop !== "filter" && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name_1 = vendorNames[i] + capName;
    if (name_1 in emptyStyle) {
      return name_1;
    }
  }
});
function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }
  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style2 = normalizeStyleBinding(vnode.data.style) || {};
  vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
  var newStyle = getStyle(vnode, true);
  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, "");
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      setProp(el, name, cur == null ? "" : cur);
    }
  }
}
var style = {
  create: updateStyle,
  update: updateStyle
};
var whitespaceRE = /\s+/;
function addClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " ".concat(el.getAttribute("class") || "", " ");
    if (cur.indexOf(" " + cls + " ") < 0) {
      el.setAttribute("class", (cur + cls).trim());
    }
  }
}
function removeClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute("class");
    }
  } else {
    var cur = " ".concat(el.getAttribute("class") || "", " ");
    var tar = " " + cls + " ";
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, " ");
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute("class", cur);
    } else {
      el.removeAttribute("class");
    }
  }
}
function resolveTransition(def3) {
  if (!def3) {
    return;
  }
  if (typeof def3 === "object") {
    var res = {};
    if (def3.css !== false) {
      extend(res, autoCssTransition(def3.name || "v"));
    }
    extend(res, def3);
    return res;
  } else if (typeof def3 === "string") {
    return autoCssTransition(def3);
  }
}
var autoCssTransition = cached(function(name) {
  return {
    enterClass: "".concat(name, "-enter"),
    enterToClass: "".concat(name, "-enter-to"),
    enterActiveClass: "".concat(name, "-enter-active"),
    leaveClass: "".concat(name, "-leave"),
    leaveToClass: "".concat(name, "-leave-to"),
    leaveActiveClass: "".concat(name, "-leave-active")
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = "transition";
var ANIMATION = "animation";
var transitionProp = "transition";
var transitionEndEvent = "transitionend";
var animationProp = "animation";
var animationEndEvent = "animationend";
if (hasTransition) {
  if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
    transitionProp = "WebkitTransition";
    transitionEndEvent = "webkitTransitionEnd";
  }
  if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
    animationProp = "WebkitAnimation";
    animationEndEvent = "webkitAnimationEnd";
  }
}
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
  return fn();
};
function nextFrame(fn) {
  raf(function() {
    raf(fn);
  });
}
function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}
function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove$2(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
  var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
  if (!type)
    return cb();
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function() {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
  var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
  var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max.apply(null, durations.map(function(d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function enter(vnode, toggleDisplay) {
  var el = vnode.elm;
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }
  var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter2 = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }
  var isAppear = !context._isMounted || !vnode.isRootInsert;
  if (isAppear && !appear && appear !== "") {
    return;
  }
  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? isFunction(appear) ? appear : enter2 : enter2;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, "enter", vnode);
  }
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function() {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });
  if (!vnode.data.show) {
    mergeVNodeHook(vnode, "insert", function() {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function() {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }
  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }
  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}
function leave(vnode, rm) {
  var el = vnode.elm;
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  if (isDef(el._leaveCb)) {
    return;
  }
  var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave2 = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave2);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, "leave", vnode);
  }
  var cb = el._leaveCb = once(function() {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });
  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }
  function performLeave() {
    if (cb.cancelled) {
      return;
    }
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function() {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave2 && leave2(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}
function checkDuration(val, name, vnode) {
  if (typeof val !== "number") {
    warn("<transition> explicit ".concat(name, " duration is not a valid number - ") + "got ".concat(JSON.stringify(val), "."), vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit ".concat(name, " duration is NaN - ") + "the duration expression might be incorrect.", vnode.context);
  }
}
function isValidDuration(val) {
  return typeof val === "number" && !isNaN(val);
}
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}
function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}
var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function(vnode, rm) {
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps, modules });
if (isIE9) {
  document.addEventListener("selectionchange", function() {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, "input");
    }
  });
}
var directive = {
  inserted: function(el, binding, vnode, oldVnode) {
    if (vnode.tag === "select") {
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, "postpatch", function() {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener("compositionstart", onCompositionStart);
        el.addEventListener("compositionend", onCompositionEnd);
        el.addEventListener("change", onCompositionEnd);
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function(el, binding, vnode) {
    if (vnode.tag === "select") {
      setSelected(el, binding, vnode.context);
      var prevOptions_1 = el._vOptions;
      var curOptions_1 = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions_1.some(function(o, i) {
        return !looseEqual(o, prevOptions_1[i]);
      })) {
        var needReset = el.multiple ? binding.value.some(function(v) {
          return hasNoMatchingOption(v, curOptions_1);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions_1);
        if (needReset) {
          trigger(el, "change");
        }
      }
    }
  }
};
function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  if (isIE || isEdge) {
    setTimeout(function() {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}
function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    warn('<select multiple v-model="'.concat(binding.expression, '"> ') + "expects an Array value for its binding, but got ".concat(Object.prototype.toString.call(value).slice(8, -1)), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}
function hasNoMatchingOption(value, options) {
  return options.every(function(o) {
    return !looseEqual(o, value);
  });
}
function getValue(option) {
  return "_value" in option ? option._value : option.value;
}
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  if (!e.target.composing)
    return;
  e.target.composing = false;
  trigger(e.target, "input");
}
function trigger(el, type) {
  var e = document.createEvent("HTMLEvents");
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}
var show = {
  bind: function(el, _a, vnode) {
    var value = _a.value;
    vnode = locateNode(vnode);
    var transition2 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
    if (value && transition2) {
      vnode.data.show = true;
      enter(vnode, function() {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : "none";
    }
  },
  update: function(el, _a, vnode) {
    var value = _a.value, oldValue = _a.oldValue;
    if (!value === !oldValue)
      return;
    vnode = locateNode(vnode);
    var transition2 = vnode.data && vnode.data.transition;
    if (transition2) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function() {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function() {
          el.style.display = "none";
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : "none";
    }
  },
  unbind: function(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show
};
var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}
function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  var listeners = options._parentListeners;
  for (var key in listeners) {
    data[camelize(key)] = listeners[key];
  }
  return data;
}
function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h("keep-alive", {
      props: rawChild.componentOptions.propsData
    });
  }
}
function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}
function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function(c) {
  return c.tag || isAsyncPlaceholder(c);
};
var isVShowDirective = function(d) {
  return d.name === "show";
};
var Transition = {
  name: "transition",
  props: transitionProps,
  abstract: true,
  render: function(h) {
    var _this = this;
    var children = this.$slots.default;
    if (!children) {
      return;
    }
    children = children.filter(isNotTextNode);
    if (!children.length) {
      return;
    }
    if (children.length > 1) {
      warn("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
    }
    var mode = this.mode;
    if (mode && mode !== "in-out" && mode !== "out-in") {
      warn("invalid <transition> mode: " + mode, this.$parent);
    }
    var rawChild = children[0];
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }
    var child = getRealChild(rawChild);
    if (!child) {
      return rawChild;
    }
    if (this._leaving) {
      return placeholder(h, rawChild);
    }
    var id = "__transition-".concat(this._uid, "-");
    child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }
    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      var oldData = oldChild.data.transition = extend({}, data);
      if (mode === "out-in") {
        this._leaving = true;
        mergeVNodeHook(oldData, "afterLeave", function() {
          _this._leaving = false;
          _this.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === "in-out") {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave_1;
        var performLeave = function() {
          delayedLeave_1();
        };
        mergeVNodeHook(data, "afterEnter", performLeave);
        mergeVNodeHook(data, "enterCancelled", performLeave);
        mergeVNodeHook(oldData, "delayLeave", function(leave2) {
          delayedLeave_1 = leave2;
        });
      }
    }
    return rawChild;
  }
};
var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props,
  beforeMount: function() {
    var _this = this;
    var update = this._update;
    this._update = function(vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(_this);
      _this.__patch__(_this._vnode, _this.kept, false, true);
      _this._vnode = _this.kept;
      restoreActiveInstance();
      update.call(_this, vnode, hydrating);
    };
  },
  render: function(h) {
    var tag = this.tag || this.$vnode.data.tag || "span";
    var map = /* @__PURE__ */ Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);
    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name_1 = opts ? getComponentName(opts.Ctor.options) || opts.tag || "" : c.tag;
          warn("<transition-group> children must be keyed: <".concat(name_1, ">"));
        }
      }
    }
    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i = 0; i < prevChildren.length; i++) {
        var c = prevChildren[i];
        c.data.transition = transitionData;
        c.data.pos = c.elm.getBoundingClientRect();
        if (map[c.key]) {
          kept.push(c);
        } else {
          removed.push(c);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }
    return h(tag, null, children);
  },
  updated: function() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || "v") + "-move";
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);
    this._reflow = document.body.offsetHeight;
    children.forEach(function(c) {
      if (c.data.moved) {
        var el_1 = c.elm;
        var s = el_1.style;
        addTransitionClass(el_1, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = "";
        el_1.addEventListener(transitionEndEvent, el_1._moveCb = function cb(e) {
          if (e && e.target !== el_1) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el_1.removeEventListener(transitionEndEvent, cb);
            el_1._moveCb = null;
            removeTransitionClass(el_1, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function(el, moveClass) {
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove) {
        return this._hasMove;
      }
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function(cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = "none";
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};
function callPendingCbs(c) {
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}
function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
    s.transitionDuration = "0s";
  }
}
var platformComponents = {
  Transition,
  TransitionGroup
};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
Vue.prototype.__patch__ = inBrowser ? patch : noop;
Vue.prototype.$mount = function(el, hydrating) {
  el = el && inBrowser ? query(el) : void 0;
  return mountComponent(this, el, hydrating);
};
if (inBrowser) {
  setTimeout(function() {
    if (config.devtools) {
      if (devtools) {
        devtools.emit("init", Vue);
      } else if (true) {
        console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
      }
    }
    if (config.productionTip !== false && typeof console !== "undefined") {
      console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}

// node_modules/@vue/composition-api/dist/vue-composition-api.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function warn$1(message) {
  var _a;
  warn2(message, (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
}
var activeEffectScope2;
var effectScopeStack = [];
var EffectScopeImpl = function() {
  function EffectScopeImpl2(vm) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.vm = vm;
  }
  EffectScopeImpl2.prototype.run = function(fn) {
    if (this.active) {
      try {
        this.on();
        return fn();
      } finally {
        this.off();
      }
    } else if (true) {
      warn$1("cannot run an inactive effect scope.");
    }
    return;
  };
  EffectScopeImpl2.prototype.on = function() {
    if (this.active) {
      effectScopeStack.push(this);
      activeEffectScope2 = this;
    }
  };
  EffectScopeImpl2.prototype.off = function() {
    if (this.active) {
      effectScopeStack.pop();
      activeEffectScope2 = effectScopeStack[effectScopeStack.length - 1];
    }
  };
  EffectScopeImpl2.prototype.stop = function() {
    if (this.active) {
      this.vm.$destroy();
      this.effects.forEach(function(e) {
        return e.stop();
      });
      this.cleanups.forEach(function(cleanup) {
        return cleanup();
      });
      this.active = false;
    }
  };
  return EffectScopeImpl2;
}();
var EffectScope2 = function(_super) {
  __extends(EffectScope3, _super);
  function EffectScope3(detached) {
    if (detached === void 0) {
      detached = false;
    }
    var _this = this;
    var vm = void 0;
    withCurrentInstanceTrackingDisabled(function() {
      vm = defineComponentInstance(getVueConstructor());
    });
    _this = _super.call(this, vm) || this;
    if (!detached) {
      recordEffectScope2(_this);
    }
    return _this;
  }
  return EffectScope3;
}(EffectScopeImpl);
function recordEffectScope2(effect, scope) {
  var _a;
  scope = scope || activeEffectScope2;
  if (scope && scope.active) {
    scope.effects.push(effect);
    return;
  }
  var vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
  vm && vm.$on("hook:destroyed", function() {
    return effect.stop();
  });
}
function effectScope(detached) {
  return new EffectScope2(detached);
}
function getCurrentScope() {
  return activeEffectScope2;
}
function onScopeDispose(fn) {
  if (activeEffectScope2) {
    activeEffectScope2.cleanups.push(fn);
  } else if (true) {
    warn$1("onScopeDispose() is called when there is no active effect scope to be associated with.");
  }
}
function getCurrentScopeVM() {
  var _a, _b;
  return ((_a = getCurrentScope()) === null || _a === void 0 ? void 0 : _a.vm) || ((_b = getCurrentInstance()) === null || _b === void 0 ? void 0 : _b.proxy);
}
function bindCurrentScopeToVM(vm) {
  if (!vm.scope) {
    var scope_1 = new EffectScopeImpl(vm.proxy);
    vm.scope = scope_1;
    vm.proxy.$on("hook:destroyed", function() {
      return scope_1.stop();
    });
  }
  return vm.scope;
}
var vueDependency = void 0;
try {
  requiredVue = require_vue_runtime_common();
  if (requiredVue && isVue(requiredVue)) {
    vueDependency = requiredVue;
  } else if (requiredVue && "default" in requiredVue && isVue(requiredVue.default)) {
    vueDependency = requiredVue.default;
  }
} catch (_a) {
}
var requiredVue;
var vueConstructor = null;
var currentInstance2 = null;
var currentInstanceTracking = true;
var PluginInstalledFlag = "__composition_api_installed__";
function isVue(obj) {
  return obj && isFunction2(obj) && obj.name === "Vue";
}
function isVueRegistered(Vue3) {
  return vueConstructor && hasOwn2(Vue3, PluginInstalledFlag);
}
function getVueConstructor() {
  if (true) {
    assert(vueConstructor, "must call Vue.use(VueCompositionAPI) before using any function.");
  }
  return vueConstructor;
}
function getRegisteredVueOrDefault() {
  var constructor = vueConstructor || vueDependency;
  if (true) {
    assert(constructor, "No vue dependency found.");
  }
  return constructor;
}
function setVueConstructor(Vue3) {
  if (vueConstructor && Vue3.__proto__ !== vueConstructor.__proto__) {
    warn2("[vue-composition-api] another instance of Vue installed");
  }
  vueConstructor = Vue3;
  Object.defineProperty(Vue3, PluginInstalledFlag, {
    configurable: true,
    writable: true,
    value: true
  });
}
function withCurrentInstanceTrackingDisabled(fn) {
  var prev = currentInstanceTracking;
  currentInstanceTracking = false;
  try {
    fn();
  } finally {
    currentInstanceTracking = prev;
  }
}
function setCurrentInstance2(instance) {
  if (!currentInstanceTracking)
    return;
  var prev = currentInstance2;
  prev === null || prev === void 0 ? void 0 : prev.scope.off();
  currentInstance2 = instance;
  currentInstance2 === null || currentInstance2 === void 0 ? void 0 : currentInstance2.scope.on();
}
function getCurrentInstance() {
  return currentInstance2;
}
var instanceMapCache = /* @__PURE__ */ new WeakMap();
function toVue3ComponentInstance(vm) {
  if (instanceMapCache.has(vm)) {
    return instanceMapCache.get(vm);
  }
  var instance = {
    proxy: vm,
    update: vm.$forceUpdate,
    type: vm.$options,
    uid: vm._uid,
    emit: vm.$emit.bind(vm),
    parent: null,
    root: null
  };
  bindCurrentScopeToVM(instance);
  var instanceProps = [
    "data",
    "props",
    "attrs",
    "refs",
    "vnode",
    "slots"
  ];
  instanceProps.forEach(function(prop) {
    proxy2(instance, prop, {
      get: function() {
        return vm["$".concat(prop)];
      }
    });
  });
  proxy2(instance, "isMounted", {
    get: function() {
      return vm._isMounted;
    }
  });
  proxy2(instance, "isUnmounted", {
    get: function() {
      return vm._isDestroyed;
    }
  });
  proxy2(instance, "isDeactivated", {
    get: function() {
      return vm._inactive;
    }
  });
  proxy2(instance, "emitted", {
    get: function() {
      return vm._events;
    }
  });
  instanceMapCache.set(vm, instance);
  if (vm.$parent) {
    instance.parent = toVue3ComponentInstance(vm.$parent);
  }
  if (vm.$root) {
    instance.root = toVue3ComponentInstance(vm.$root);
  }
  return instance;
}
var toString2 = function(x) {
  return Object.prototype.toString.call(x);
};
function isNative2(Ctor) {
  return typeof Ctor === "function" && /native code/.test(Ctor.toString());
}
var hasSymbol2 = typeof Symbol !== "undefined" && isNative2(Symbol) && typeof Reflect !== "undefined" && isNative2(Reflect.ownKeys);
var noopFn = function(_) {
  return _;
};
function proxy2(target2, key, _a) {
  var get2 = _a.get, set3 = _a.set;
  Object.defineProperty(target2, key, {
    enumerable: true,
    configurable: true,
    get: get2 || noopFn,
    set: set3 || noopFn
  });
}
function def2(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
function hasOwn2(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vue-composition-api] ".concat(msg));
  }
}
function isPrimitive2(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
}
function isArray2(x) {
  return Array.isArray(x);
}
var objectToString = Object.prototype.toString;
var toTypeString = function(value) {
  return objectToString.call(value);
};
var isMap = function(val) {
  return toTypeString(val) === "[object Map]";
};
var isSet = function(val) {
  return toTypeString(val) === "[object Set]";
};
var MAX_VALID_ARRAY_LENGTH = 4294967295;
function isValidArrayIndex2(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val) && n <= MAX_VALID_ARRAY_LENGTH;
}
function isObject2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject2(x) {
  return toString2(x) === "[object Object]";
}
function isFunction2(x) {
  return typeof x === "function";
}
function isUndef2(v) {
  return v === void 0 || v === null;
}
function warn2(msg, vm) {
  var Vue3 = getRegisteredVueOrDefault();
  if (!Vue3 || !Vue3.util)
    console.warn("[vue-composition-api] ".concat(msg));
  else
    Vue3.util.warn(msg, vm);
}
function logError2(err, vm, info) {
  if (true) {
    warn2("Error in ".concat(info, ': "').concat(err.toString(), '"'), vm);
  }
  if (typeof window !== "undefined" && typeof console !== "undefined") {
    console.error(err);
  } else {
    throw err;
  }
}
function isSame(value1, value2) {
  if (value1 === value2) {
    return value1 !== 0 || 1 / value1 === 1 / value2;
  } else {
    return value1 !== value1 && value2 !== value2;
  }
}
function getCurrentInstanceForFn(hook, target2) {
  target2 = target2 || getCurrentInstance();
  if (!target2) {
    warn2("".concat(hook, " is called when there is no active component instance to be ") + "associated with. Lifecycle injection APIs can only be used during execution of setup().");
  }
  return target2;
}
function defineComponentInstance(Ctor, options) {
  if (options === void 0) {
    options = {};
  }
  var silent = Ctor.config.silent;
  Ctor.config.silent = true;
  var vm = new Ctor(options);
  Ctor.config.silent = silent;
  return vm;
}
function isComponentInstance(obj) {
  var Vue3 = getVueConstructor();
  return Vue3 && obj instanceof Vue3;
}
function createSlotProxy(vm, slotName) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!vm.$scopedSlots[slotName]) {
      if (true)
        return warn2("slots.".concat(slotName, '() got called outside of the "render()" scope'), vm);
      return;
    }
    return vm.$scopedSlots[slotName].apply(vm, args);
  };
}
function resolveSlots2(slots, normalSlots) {
  var res;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    return slots._normalized;
  } else {
    res = {};
    for (var key in slots) {
      if (slots[key] && key[0] !== "$") {
        res[key] = true;
      }
    }
  }
  for (var key in normalSlots) {
    if (!(key in res)) {
      res[key] = true;
    }
  }
  return res;
}
var vueInternalClasses;
var getVueInternalClasses = function() {
  if (!vueInternalClasses) {
    var vm = defineComponentInstance(getVueConstructor(), {
      computed: {
        value: function() {
          return 0;
        }
      }
    });
    var Watcher2 = vm._computedWatchers.value.constructor;
    var Dep2 = vm._data.__ob__.dep.constructor;
    vueInternalClasses = {
      Watcher: Watcher2,
      Dep: Dep2
    };
    vm.$destroy();
  }
  return vueInternalClasses;
};
function createSymbol(name) {
  return hasSymbol2 ? Symbol.for(name) : name;
}
var WatcherPreFlushQueueKey = createSymbol("composition-api.preFlushQueue");
var WatcherPostFlushQueueKey = createSymbol("composition-api.postFlushQueue");
var RefKey = "composition-api.refKey";
var accessModifiedSet = /* @__PURE__ */ new WeakMap();
var rawSet = /* @__PURE__ */ new WeakMap();
var readonlySet = /* @__PURE__ */ new WeakMap();
function set$1(target2, key, val) {
  var Vue3 = getVueConstructor();
  var _a = Vue3.util, warn3 = _a.warn, defineReactive2 = _a.defineReactive;
  if (isUndef2(target2) || isPrimitive2(target2)) {
    warn3("Cannot set reactive property on undefined, null, or primitive value: ".concat(target2));
  }
  var ob = target2.__ob__;
  function ssrMockReactivity() {
    if (ob && isObject2(val) && !hasOwn2(val, "__ob__")) {
      mockReactivityDeep(val);
    }
  }
  if (isArray2(target2)) {
    if (isValidArrayIndex2(key)) {
      target2.length = Math.max(target2.length, key);
      target2.splice(key, 1, val);
      ssrMockReactivity();
      return val;
    } else if (key === "length" && val !== target2.length) {
      target2.length = val;
      ob === null || ob === void 0 ? void 0 : ob.dep.notify();
      return val;
    }
  }
  if (key in target2 && !(key in Object.prototype)) {
    target2[key] = val;
    ssrMockReactivity();
    return val;
  }
  if (target2._isVue || ob && ob.vmCount) {
    warn3("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
    return val;
  }
  if (!ob) {
    target2[key] = val;
    return val;
  }
  defineReactive2(ob.value, key, val);
  defineAccessControl(target2, key, val);
  ssrMockReactivity();
  ob.dep.notify();
  return val;
}
var _isForceTrigger = false;
function isForceTrigger() {
  return _isForceTrigger;
}
function setForceTrigger(v) {
  _isForceTrigger = v;
}
var RefImpl = function() {
  function RefImpl2(_a) {
    var get2 = _a.get, set3 = _a.set;
    proxy2(this, "value", {
      get: get2,
      set: set3
    });
  }
  return RefImpl2;
}();
function createRef(options, isReadonly3, isComputed) {
  if (isReadonly3 === void 0) {
    isReadonly3 = false;
  }
  if (isComputed === void 0) {
    isComputed = false;
  }
  var r = new RefImpl(options);
  if (isComputed)
    r.effect = true;
  var sealed = Object.seal(r);
  if (isReadonly3)
    readonlySet.set(sealed, true);
  return sealed;
}
function ref2(raw) {
  var _a;
  if (isRef2(raw)) {
    return raw;
  }
  var value = reactive((_a = {}, _a[RefKey] = raw, _a));
  return createRef({
    get: function() {
      return value[RefKey];
    },
    set: function(v) {
      return value[RefKey] = v;
    }
  });
}
function isRef2(value) {
  return value instanceof RefImpl;
}
function unref(ref3) {
  return isRef2(ref3) ? ref3.value : ref3;
}
function toRefs(obj) {
  if (!isReactive(obj)) {
    warn2("toRefs() expects a reactive object but received a plain one.");
  }
  if (!isPlainObject2(obj))
    return obj;
  var ret = {};
  for (var key in obj) {
    ret[key] = toRef(obj, key);
  }
  return ret;
}
function customRef(factory) {
  var version3 = ref2(0);
  return createRef(factory(function() {
    return void version3.value;
  }, function() {
    ++version3.value;
  }));
}
function toRef(object, key) {
  if (!(key in object))
    set$1(object, key, void 0);
  var v = object[key];
  if (isRef2(v))
    return v;
  return createRef({
    get: function() {
      return object[key];
    },
    set: function(v2) {
      return object[key] = v2;
    }
  });
}
function shallowRef(raw) {
  var _a;
  if (isRef2(raw)) {
    return raw;
  }
  var value = shallowReactive2((_a = {}, _a[RefKey] = raw, _a));
  return createRef({
    get: function() {
      return value[RefKey];
    },
    set: function(v) {
      return value[RefKey] = v;
    }
  });
}
function triggerRef(value) {
  if (!isRef2(value))
    return;
  setForceTrigger(true);
  value.value = value.value;
  setForceTrigger(false);
}
function proxyRefs(objectWithRefs) {
  var _a, e_1, _b;
  if (isReactive(objectWithRefs)) {
    return objectWithRefs;
  }
  var value = reactive((_a = {}, _a[RefKey] = objectWithRefs, _a));
  def2(value, RefKey, value[RefKey], false);
  var _loop_1 = function(key2) {
    proxy2(value, key2, {
      get: function() {
        if (isRef2(value[RefKey][key2])) {
          return value[RefKey][key2].value;
        }
        return value[RefKey][key2];
      },
      set: function(v) {
        if (isRef2(value[RefKey][key2])) {
          return value[RefKey][key2].value = unref(v);
        }
        value[RefKey][key2] = unref(v);
      }
    });
  };
  try {
    for (var _c = __values(Object.keys(objectWithRefs)), _d = _c.next(); !_d.done; _d = _c.next()) {
      var key = _d.value;
      _loop_1(key);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_d && !_d.done && (_b = _c.return))
        _b.call(_c);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return value;
}
var SKIPFLAG = "__v_skip";
function isRaw(obj) {
  var _a;
  return Boolean(obj && hasOwn2(obj, "__ob__") && typeof obj.__ob__ === "object" && ((_a = obj.__ob__) === null || _a === void 0 ? void 0 : _a[SKIPFLAG]));
}
function isReactive(obj) {
  var _a;
  return Boolean(obj && hasOwn2(obj, "__ob__") && typeof obj.__ob__ === "object" && !((_a = obj.__ob__) === null || _a === void 0 ? void 0 : _a[SKIPFLAG]));
}
function setupAccessControl(target2) {
  if (!isPlainObject2(target2) || isRaw(target2) || isArray2(target2) || isRef2(target2) || isComponentInstance(target2) || accessModifiedSet.has(target2))
    return;
  accessModifiedSet.set(target2, true);
  var keys = Object.keys(target2);
  for (var i = 0; i < keys.length; i++) {
    defineAccessControl(target2, keys[i]);
  }
}
function defineAccessControl(target2, key, val) {
  if (key === "__ob__")
    return;
  if (isRaw(target2[key]))
    return;
  var getter;
  var setter;
  var property = Object.getOwnPropertyDescriptor(target2, key);
  if (property) {
    if (property.configurable === false) {
      return;
    }
    getter = property.get;
    setter = property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = target2[key];
    }
  }
  setupAccessControl(val);
  proxy2(target2, key, {
    get: function getterHandler() {
      var value = getter ? getter.call(target2) : val;
      if (key !== RefKey && isRef2(value)) {
        return value.value;
      } else {
        return value;
      }
    },
    set: function setterHandler(newVal) {
      if (getter && !setter)
        return;
      if (key !== RefKey && isRef2(val) && !isRef2(newVal)) {
        val.value = newVal;
      } else if (setter) {
        setter.call(target2, newVal);
        val = newVal;
      } else {
        val = newVal;
      }
      setupAccessControl(newVal);
    }
  });
}
function observe2(obj) {
  var Vue3 = getRegisteredVueOrDefault();
  var observed;
  if (Vue3.observable) {
    observed = Vue3.observable(obj);
  } else {
    var vm = defineComponentInstance(Vue3, {
      data: {
        $$state: obj
      }
    });
    observed = vm._data.$$state;
  }
  if (!hasOwn2(observed, "__ob__")) {
    mockReactivityDeep(observed);
  }
  return observed;
}
function mockReactivityDeep(obj, seen) {
  var e_1, _a;
  if (seen === void 0) {
    seen = /* @__PURE__ */ new Set();
  }
  if (seen.has(obj) || hasOwn2(obj, "__ob__") || !Object.isExtensible(obj))
    return;
  def2(obj, "__ob__", mockObserver(obj));
  seen.add(obj);
  try {
    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var value = obj[key];
      if (!(isPlainObject2(value) || isArray2(value)) || isRaw(value) || !Object.isExtensible(value)) {
        continue;
      }
      mockReactivityDeep(value, seen);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function mockObserver(value) {
  if (value === void 0) {
    value = {};
  }
  return {
    value,
    dep: {
      notify: noopFn,
      depend: noopFn,
      addSub: noopFn,
      removeSub: noopFn
    }
  };
}
function createObserver() {
  return observe2({}).__ob__;
}
function shallowReactive2(obj) {
  var e_2, _a;
  if (!isObject2(obj)) {
    if (true) {
      warn2('"shallowReactive()" must be called on an object.');
    }
    return obj;
  }
  if (!(isPlainObject2(obj) || isArray2(obj)) || isRaw(obj) || !Object.isExtensible(obj)) {
    return obj;
  }
  var observed = observe2(isArray2(obj) ? [] : {});
  var ob = observed.__ob__;
  var _loop_1 = function(key2) {
    var val = obj[key2];
    var getter;
    var setter;
    var property = Object.getOwnPropertyDescriptor(obj, key2);
    if (property) {
      if (property.configurable === false) {
        return "continue";
      }
      getter = property.get;
      setter = property.set;
    }
    proxy2(observed, key2, {
      get: function getterHandler() {
        var _a2;
        (_a2 = ob.dep) === null || _a2 === void 0 ? void 0 : _a2.depend();
        return val;
      },
      set: function setterHandler(newVal) {
        var _a2;
        if (getter && !setter)
          return;
        if (!isForceTrigger() && val === newVal)
          return;
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        (_a2 = ob.dep) === null || _a2 === void 0 ? void 0 : _a2.notify();
      }
    });
  };
  try {
    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      _loop_1(key);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return observed;
}
function reactive(obj) {
  if (!isObject2(obj)) {
    if (true) {
      warn2('"reactive()" must be called on an object.');
    }
    return obj;
  }
  if (!(isPlainObject2(obj) || isArray2(obj)) || isRaw(obj) || !Object.isExtensible(obj)) {
    return obj;
  }
  var observed = observe2(obj);
  setupAccessControl(observed);
  return observed;
}
function markRaw(obj) {
  if (!(isPlainObject2(obj) || isArray2(obj)) || !Object.isExtensible(obj)) {
    return obj;
  }
  var ob = createObserver();
  ob[SKIPFLAG] = true;
  def2(obj, "__ob__", ob);
  rawSet.set(obj, true);
  return obj;
}
function toRaw(observed) {
  var _a;
  if (isRaw(observed) || !Object.isExtensible(observed)) {
    return observed;
  }
  return ((_a = observed === null || observed === void 0 ? void 0 : observed.__ob__) === null || _a === void 0 ? void 0 : _a.value) || observed;
}
function isReadonly2(obj) {
  return readonlySet.has(obj);
}
function readonly(target2) {
  if (!isObject2(target2)) {
    warn2("value cannot be made reactive: ".concat(String(target2)));
  } else {
    readonlySet.set(target2, true);
  }
  return target2;
}
function shallowReadonly(obj) {
  var e_1, _a;
  if (!isObject2(obj)) {
    if (true) {
      warn2("value cannot be made reactive: ".concat(String(obj)));
    }
    return obj;
  }
  if (!(isPlainObject2(obj) || isArray2(obj)) || !Object.isExtensible(obj) && !isRef2(obj)) {
    return obj;
  }
  var readonlyObj = isRef2(obj) ? new RefImpl({}) : isReactive(obj) ? observe2({}) : {};
  var source = reactive({});
  var ob = source.__ob__;
  var _loop_1 = function(key2) {
    var val = obj[key2];
    var getter;
    var property = Object.getOwnPropertyDescriptor(obj, key2);
    if (property) {
      if (property.configurable === false && !isRef2(obj)) {
        return "continue";
      }
      getter = property.get;
    }
    proxy2(readonlyObj, key2, {
      get: function getterHandler() {
        var value = getter ? getter.call(obj) : val;
        ob.dep.depend();
        return value;
      },
      set: function(v) {
        if (true) {
          warn2('Set operation on key "'.concat(key2, '" failed: target is readonly.'));
        }
      }
    });
  };
  try {
    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      _loop_1(key);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  readonlySet.set(readonlyObj, true);
  return readonlyObj;
}
function del2(target2, key) {
  var Vue3 = getVueConstructor();
  var warn3 = Vue3.util.warn;
  if (isUndef2(target2) || isPrimitive2(target2)) {
    warn3("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target2));
  }
  if (isArray2(target2) && isValidArrayIndex2(key)) {
    target2.splice(key, 1);
    return;
  }
  var ob = target2.__ob__;
  if (target2._isVue || ob && ob.vmCount) {
    warn3("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
    return;
  }
  if (!hasOwn2(target2, key)) {
    return;
  }
  delete target2[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}
var genName = function(name) {
  return "on".concat(name[0].toUpperCase() + name.slice(1));
};
function createLifeCycle2(lifeCyclehook) {
  return function(callback, target2) {
    var instance = getCurrentInstanceForFn(genName(lifeCyclehook), target2);
    return instance && injectHookOption(getVueConstructor(), instance, lifeCyclehook, callback);
  };
}
function injectHookOption(Vue3, instance, hook, val) {
  var options = instance.proxy.$options;
  var mergeFn = Vue3.config.optionMergeStrategies[hook];
  var wrappedHook = wrapHookCall(instance, val);
  options[hook] = mergeFn(options[hook], wrappedHook);
  return wrappedHook;
}
function wrapHookCall(instance, fn) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var prev = getCurrentInstance();
    setCurrentInstance2(instance);
    try {
      return fn.apply(void 0, __spreadArray([], __read(args), false));
    } finally {
      setCurrentInstance2(prev);
    }
  };
}
var onBeforeMount2 = createLifeCycle2("beforeMount");
var onMounted2 = createLifeCycle2("mounted");
var onBeforeUpdate2 = createLifeCycle2("beforeUpdate");
var onUpdated2 = createLifeCycle2("updated");
var onBeforeUnmount2 = createLifeCycle2("beforeDestroy");
var onUnmounted2 = createLifeCycle2("destroyed");
var onErrorCaptured2 = createLifeCycle2("errorCaptured");
var onActivated2 = createLifeCycle2("activated");
var onDeactivated2 = createLifeCycle2("deactivated");
var onServerPrefetch2 = createLifeCycle2("serverPrefetch");
var fallbackVM;
function flushPreQueue() {
  flushQueue(this, WatcherPreFlushQueueKey);
}
function flushPostQueue() {
  flushQueue(this, WatcherPostFlushQueueKey);
}
function hasWatchEnv(vm) {
  return vm[WatcherPreFlushQueueKey] !== void 0;
}
function installWatchEnv(vm) {
  vm[WatcherPreFlushQueueKey] = [];
  vm[WatcherPostFlushQueueKey] = [];
  vm.$on("hook:beforeUpdate", flushPreQueue);
  vm.$on("hook:updated", flushPostQueue);
}
function getWatcherOption(options) {
  return __assign2({
    immediate: false,
    deep: false,
    flush: "pre"
  }, options);
}
function getWatchEffectOption(options) {
  return __assign2({
    flush: "pre"
  }, options);
}
function getWatcherVM() {
  var vm = getCurrentScopeVM();
  if (!vm) {
    if (!fallbackVM) {
      fallbackVM = defineComponentInstance(getVueConstructor());
    }
    vm = fallbackVM;
  } else if (!hasWatchEnv(vm)) {
    installWatchEnv(vm);
  }
  return vm;
}
function flushQueue(vm, key) {
  var queue2 = vm[key];
  for (var index2 = 0; index2 < queue2.length; index2++) {
    queue2[index2]();
  }
  queue2.length = 0;
}
function queueFlushJob(vm, fn, mode) {
  var fallbackFlush = function() {
    vm.$nextTick(function() {
      if (vm[WatcherPreFlushQueueKey].length) {
        flushQueue(vm, WatcherPreFlushQueueKey);
      }
      if (vm[WatcherPostFlushQueueKey].length) {
        flushQueue(vm, WatcherPostFlushQueueKey);
      }
    });
  };
  switch (mode) {
    case "pre":
      fallbackFlush();
      vm[WatcherPreFlushQueueKey].push(fn);
      break;
    case "post":
      fallbackFlush();
      vm[WatcherPostFlushQueueKey].push(fn);
      break;
    default:
      assert(false, 'flush must be one of ["post", "pre", "sync"], but got '.concat(mode));
      break;
  }
}
function createVueWatcher(vm, getter, callback, options) {
  var index2 = vm._watchers.length;
  vm.$watch(getter, callback, {
    immediate: options.immediateInvokeCallback,
    deep: options.deep,
    lazy: options.noRun,
    sync: options.sync,
    before: options.before
  });
  return vm._watchers[index2];
}
function patchWatcherTeardown(watcher, runCleanup) {
  var _teardown = watcher.teardown;
  watcher.teardown = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    _teardown.apply(watcher, args);
    runCleanup();
  };
}
function createWatcher2(vm, source, cb, options) {
  var _a;
  if (!cb) {
    if (options.immediate !== void 0) {
      warn2('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');
    }
    if (options.deep !== void 0) {
      warn2('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.');
    }
  }
  var flushMode = options.flush;
  var isSync = flushMode === "sync";
  var cleanup;
  var registerCleanup = function(fn) {
    cleanup = function() {
      try {
        fn();
      } catch (error) {
        logError2(error, vm, "onCleanup()");
      }
    };
  };
  var runCleanup = function() {
    if (cleanup) {
      cleanup();
      cleanup = null;
    }
  };
  var createScheduler = function(fn) {
    if (isSync || vm === fallbackVM) {
      return fn;
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return queueFlushJob(vm, function() {
        fn.apply(void 0, __spreadArray([], __read(args), false));
      }, flushMode);
    };
  };
  if (cb === null) {
    var running_1 = false;
    var getter_1 = function() {
      if (running_1) {
        return;
      }
      try {
        running_1 = true;
        source(registerCleanup);
      } finally {
        running_1 = false;
      }
    };
    var watcher_1 = createVueWatcher(vm, getter_1, noopFn, {
      deep: options.deep || false,
      sync: isSync,
      before: runCleanup
    });
    patchWatcherTeardown(watcher_1, runCleanup);
    watcher_1.lazy = false;
    var originGet = watcher_1.get.bind(watcher_1);
    watcher_1.get = createScheduler(originGet);
    return function() {
      watcher_1.teardown();
    };
  }
  var deep = options.deep;
  var isMultiSource = false;
  var getter;
  if (isRef2(source)) {
    getter = function() {
      return source.value;
    };
  } else if (isReactive(source)) {
    getter = function() {
      return source;
    };
    deep = true;
  } else if (isArray2(source)) {
    isMultiSource = true;
    getter = function() {
      return source.map(function(s) {
        if (isRef2(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse2(s);
        } else if (isFunction2(s)) {
          return s();
        } else {
          warn2("Invalid watch source: ".concat(JSON.stringify(s), ".\n          A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."), vm);
          return noopFn;
        }
      });
    };
  } else if (isFunction2(source)) {
    getter = source;
  } else {
    getter = noopFn;
    warn2("Invalid watch source: ".concat(JSON.stringify(source), ".\n      A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."), vm);
  }
  if (deep) {
    var baseGetter_1 = getter;
    getter = function() {
      return traverse2(baseGetter_1());
    };
  }
  var applyCb = function(n, o) {
    if (!deep && isMultiSource && n.every(function(v, i) {
      return isSame(v, o[i]);
    }))
      return;
    runCleanup();
    return cb(n, o, registerCleanup);
  };
  var callback = createScheduler(applyCb);
  if (options.immediate) {
    var originalCallback_1 = callback;
    var shiftCallback_1 = function(n, o) {
      shiftCallback_1 = originalCallback_1;
      return applyCb(n, isArray2(n) ? [] : o);
    };
    callback = function(n, o) {
      return shiftCallback_1(n, o);
    };
  }
  var stop = vm.$watch(getter, callback, {
    immediate: options.immediate,
    deep,
    sync: isSync
  });
  var watcher = vm._watchers[vm._watchers.length - 1];
  if (isReactive(watcher.value) && ((_a = watcher.value.__ob__) === null || _a === void 0 ? void 0 : _a.dep) && deep) {
    watcher.value.__ob__.dep.addSub({
      update: function() {
        watcher.run();
      }
    });
  }
  patchWatcherTeardown(watcher, runCleanup);
  return function() {
    stop();
  };
}
function watchEffect(effect, options) {
  var opts = getWatchEffectOption(options);
  var vm = getWatcherVM();
  return createWatcher2(vm, effect, null, opts);
}
function watchPostEffect(effect) {
  return watchEffect(effect, { flush: "post" });
}
function watchSyncEffect(effect) {
  return watchEffect(effect, { flush: "sync" });
}
function watch(source, cb, options) {
  var callback = null;
  if (isFunction2(cb)) {
    callback = cb;
  } else {
    if (true) {
      warn2("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.");
    }
    options = cb;
    callback = null;
  }
  var opts = getWatcherOption(options);
  var vm = getWatcherVM();
  return createWatcher2(vm, source, callback, opts);
}
function traverse2(value, seen) {
  if (seen === void 0) {
    seen = /* @__PURE__ */ new Set();
  }
  if (!isObject2(value) || seen.has(value) || rawSet.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef2(value)) {
    traverse2(value.value, seen);
  } else if (isArray2(value)) {
    for (var i = 0; i < value.length; i++) {
      traverse2(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach(function(v) {
      traverse2(v, seen);
    });
  } else if (isPlainObject2(value)) {
    for (var key in value) {
      traverse2(value[key], seen);
    }
  }
  return value;
}
function computed(getterOrOptions) {
  var vm = getCurrentScopeVM();
  var getter;
  var setter;
  if (isFunction2(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  var computedSetter;
  var computedGetter;
  if (vm && !vm.$isServer) {
    var _a = getVueInternalClasses(), Watcher_1 = _a.Watcher, Dep_1 = _a.Dep;
    var watcher_1;
    computedGetter = function() {
      if (!watcher_1) {
        watcher_1 = new Watcher_1(vm, getter, noopFn, { lazy: true });
      }
      if (watcher_1.dirty) {
        watcher_1.evaluate();
      }
      if (Dep_1.target) {
        watcher_1.depend();
      }
      return watcher_1.value;
    };
    computedSetter = function(v) {
      if (!setter) {
        warn2("Write operation failed: computed value is readonly.", vm);
        return;
      }
      if (setter) {
        setter(v);
      }
    };
  } else {
    var computedHost_1 = defineComponentInstance(getVueConstructor(), {
      computed: {
        $$state: {
          get: getter,
          set: setter
        }
      }
    });
    vm && vm.$on("hook:destroyed", function() {
      return computedHost_1.$destroy();
    });
    computedGetter = function() {
      return computedHost_1.$$state;
    };
    computedSetter = function(v) {
      if (!setter) {
        warn2("Write operation failed: computed value is readonly.", vm);
        return;
      }
      computedHost_1.$$state = v;
    };
  }
  return createRef({
    get: computedGetter,
    set: computedSetter
  }, !setter, true);
}
var NOT_FOUND = {};
function resolveInject2(provideKey, vm) {
  var source = vm;
  while (source) {
    if (source._provided && hasOwn2(source._provided, provideKey)) {
      return source._provided[provideKey];
    }
    source = source.$parent;
  }
  return NOT_FOUND;
}
function provide(key, value) {
  var _a;
  var vm = (_a = getCurrentInstanceForFn("provide")) === null || _a === void 0 ? void 0 : _a.proxy;
  if (!vm)
    return;
  if (!vm._provided) {
    var provideCache_1 = {};
    proxy2(vm, "_provided", {
      get: function() {
        return provideCache_1;
      },
      set: function(v) {
        return Object.assign(provideCache_1, v);
      }
    });
  }
  vm._provided[key] = value;
}
function inject(key, defaultValue, treatDefaultAsFactory) {
  var _a;
  if (treatDefaultAsFactory === void 0) {
    treatDefaultAsFactory = false;
  }
  var vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
  if (!vm) {
    warn2("inject() can only be used inside setup() or functional components.");
    return;
  }
  if (!key) {
    warn2('injection "'.concat(String(key), '" not found.'), vm);
    return defaultValue;
  }
  var val = resolveInject2(key, vm);
  if (val !== NOT_FOUND) {
    return val;
  } else if (arguments.length > 1) {
    return treatDefaultAsFactory && isFunction2(defaultValue) ? defaultValue() : defaultValue;
  } else if (true) {
    warn2('Injection "'.concat(String(key), '" not found.'), vm);
  }
}
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var useCssModule = function(name) {
  var _a;
  if (name === void 0) {
    name = "$style";
  }
  var instance = getCurrentInstance();
  if (!instance) {
    warn2("useCssModule must be called inside setup()");
    return EMPTY_OBJ;
  }
  var mod = (_a = instance.proxy) === null || _a === void 0 ? void 0 : _a[name];
  if (!mod) {
    warn2('Current instance does not have CSS module named "'.concat(name, '".'));
    return EMPTY_OBJ;
  }
  return mod;
};
var useCSSModule = useCssModule;
function createApp(rootComponent, rootProps) {
  if (rootProps === void 0) {
    rootProps = void 0;
  }
  var V = getVueConstructor();
  var mountedVM = void 0;
  var provide2 = {};
  var app = {
    config: V.config,
    use: V.use.bind(V),
    mixin: V.mixin.bind(V),
    component: V.component.bind(V),
    provide: function(key, value) {
      provide2[key] = value;
      return this;
    },
    directive: function(name, dir) {
      if (dir) {
        V.directive(name, dir);
        return app;
      } else {
        return V.directive(name);
      }
    },
    mount: function(el, hydrating) {
      if (!mountedVM) {
        mountedVM = new V(__assign2(__assign2({ propsData: rootProps }, rootComponent), { provide: __assign2(__assign2({}, provide2), rootComponent.provide) }));
        mountedVM.$mount(el, hydrating);
        return mountedVM;
      } else {
        if (true) {
          warn2("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        }
        return mountedVM;
      }
    },
    unmount: function() {
      if (mountedVM) {
        mountedVM.$destroy();
        mountedVM = void 0;
      } else if (true) {
        warn2("Cannot unmount an app that is not mounted.");
      }
    }
  };
  return app;
}
var nextTick2 = function nextTick3() {
  var _a;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return (_a = getVueConstructor()) === null || _a === void 0 ? void 0 : _a.nextTick.apply(this, args);
};
var fallbackCreateElement;
var createElement2 = function createElement3() {
  var _a;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var instance = (this === null || this === void 0 ? void 0 : this.proxy) || ((_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
  if (!instance) {
    warn2("`createElement()` has been called outside of render function.");
    if (!fallbackCreateElement) {
      fallbackCreateElement = defineComponentInstance(getVueConstructor()).$createElement;
    }
    return fallbackCreateElement.apply(fallbackCreateElement, args);
  }
  return instance.$createElement.apply(instance, args);
};
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  var i = getCurrentInstance();
  if (!i) {
    warn2("useContext() called without active instance.");
  }
  return i.setupContext;
}
function set2(vm, key, value) {
  var state = vm.__composition_api_state__ = vm.__composition_api_state__ || {};
  state[key] = value;
}
function get(vm, key) {
  return (vm.__composition_api_state__ || {})[key];
}
var vmStateManager = {
  set: set2,
  get
};
function asVmProperty(vm, propName, propValue) {
  var props2 = vm.$options.props;
  if (!(propName in vm) && !(props2 && hasOwn2(props2, propName))) {
    if (isRef2(propValue)) {
      proxy2(vm, propName, {
        get: function() {
          return propValue.value;
        },
        set: function(val) {
          propValue.value = val;
        }
      });
    } else {
      proxy2(vm, propName, {
        get: function() {
          if (isReactive(propValue)) {
            propValue.__ob__.dep.depend();
          }
          return propValue;
        },
        set: function(val) {
          propValue = val;
        }
      });
    }
    if (true) {
      vm.$nextTick(function() {
        if (Object.keys(vm._data).indexOf(propName) !== -1) {
          return;
        }
        if (isRef2(propValue)) {
          proxy2(vm._data, propName, {
            get: function() {
              return propValue.value;
            },
            set: function(val) {
              propValue.value = val;
            }
          });
        } else {
          proxy2(vm._data, propName, {
            get: function() {
              return propValue;
            },
            set: function(val) {
              propValue = val;
            }
          });
        }
      });
    }
  } else if (true) {
    if (props2 && hasOwn2(props2, propName)) {
      warn2('The setup binding property "'.concat(propName, '" is already declared as a prop.'), vm);
    } else {
      warn2('The setup binding property "'.concat(propName, '" is already declared.'), vm);
    }
  }
}
function updateTemplateRef(vm) {
  var rawBindings = vmStateManager.get(vm, "rawBindings") || {};
  if (!rawBindings || !Object.keys(rawBindings).length)
    return;
  var refs = vm.$refs;
  var oldRefKeys = vmStateManager.get(vm, "refs") || [];
  for (var index2 = 0; index2 < oldRefKeys.length; index2++) {
    var key = oldRefKeys[index2];
    var setupValue = rawBindings[key];
    if (!refs[key] && setupValue && isRef2(setupValue)) {
      setupValue.value = null;
    }
  }
  var newKeys = Object.keys(refs);
  var validNewKeys = [];
  for (var index2 = 0; index2 < newKeys.length; index2++) {
    var key = newKeys[index2];
    var setupValue = rawBindings[key];
    if (refs[key] && setupValue && isRef2(setupValue)) {
      setupValue.value = refs[key];
      validNewKeys.push(key);
    }
  }
  vmStateManager.set(vm, "refs", validNewKeys);
}
function afterRender(vm) {
  var stack = [vm._vnode];
  while (stack.length) {
    var vnode = stack.pop();
    if (vnode) {
      if (vnode.context)
        updateTemplateRef(vnode.context);
      if (vnode.children) {
        for (var i = 0; i < vnode.children.length; ++i) {
          stack.push(vnode.children[i]);
        }
      }
    }
  }
}
function updateVmAttrs(vm, ctx) {
  var e_1, _a;
  if (!vm) {
    return;
  }
  var attrBindings = vmStateManager.get(vm, "attrBindings");
  if (!attrBindings && !ctx) {
    return;
  }
  if (!attrBindings) {
    var observedData = reactive({});
    attrBindings = { ctx, data: observedData };
    vmStateManager.set(vm, "attrBindings", attrBindings);
    proxy2(ctx, "attrs", {
      get: function() {
        return attrBindings === null || attrBindings === void 0 ? void 0 : attrBindings.data;
      },
      set: function() {
        warn2("Cannot assign to '$attrs' because it is a read-only property", vm);
      }
    });
  }
  var source = vm.$attrs;
  var _loop_1 = function(attr2) {
    if (!hasOwn2(attrBindings.data, attr2)) {
      proxy2(attrBindings.data, attr2, {
        get: function() {
          return vm.$attrs[attr2];
        }
      });
    }
  };
  try {
    for (var _b = __values(Object.keys(source)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var attr = _c.value;
      _loop_1(attr);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function resolveScopedSlots2(vm, slotsProxy) {
  var parentVNode = vm.$options._parentVnode;
  if (!parentVNode)
    return;
  var prevSlots = vmStateManager.get(vm, "slots") || [];
  var curSlots = resolveSlots2(parentVNode.data.scopedSlots, vm.$slots);
  for (var index2 = 0; index2 < prevSlots.length; index2++) {
    var key = prevSlots[index2];
    if (!curSlots[key]) {
      delete slotsProxy[key];
    }
  }
  var slotNames = Object.keys(curSlots);
  for (var index2 = 0; index2 < slotNames.length; index2++) {
    var key = slotNames[index2];
    if (!slotsProxy[key]) {
      slotsProxy[key] = createSlotProxy(vm, key);
    }
  }
  vmStateManager.set(vm, "slots", slotNames);
}
function activateCurrentInstance(instance, fn, onError) {
  var preVm = getCurrentInstance();
  setCurrentInstance2(instance);
  try {
    return fn(instance);
  } catch (err) {
    if (onError) {
      onError(err);
    } else {
      throw err;
    }
  } finally {
    setCurrentInstance2(preVm);
  }
}
function mixin(Vue3) {
  Vue3.mixin({
    beforeCreate: functionApiInit,
    mounted: function() {
      afterRender(this);
    },
    beforeUpdate: function() {
      updateVmAttrs(this);
    },
    updated: function() {
      afterRender(this);
    }
  });
  function functionApiInit() {
    var vm = this;
    var $options = vm.$options;
    var setup = $options.setup, render = $options.render;
    if (render) {
      $options.render = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return activateCurrentInstance(toVue3ComponentInstance(vm), function() {
          return render.apply(_this, args);
        });
      };
    }
    if (!setup) {
      return;
    }
    if (!isFunction2(setup)) {
      if (true) {
        warn2('The "setup" option should be a function that returns a object in component definitions.', vm);
      }
      return;
    }
    var data = $options.data;
    $options.data = function wrappedData() {
      initSetup2(vm, vm.$props);
      return isFunction2(data) ? data.call(vm, vm) : data || {};
    };
  }
  function initSetup2(vm, props2) {
    if (props2 === void 0) {
      props2 = {};
    }
    var setup = vm.$options.setup;
    var ctx = createSetupContext2(vm);
    var instance = toVue3ComponentInstance(vm);
    instance.setupContext = ctx;
    def2(props2, "__ob__", createObserver());
    resolveScopedSlots2(vm, ctx.slots);
    var binding;
    activateCurrentInstance(instance, function() {
      binding = setup(props2, ctx);
    });
    if (!binding)
      return;
    if (isFunction2(binding)) {
      var bindingFunc_1 = binding;
      vm.$options.render = function() {
        resolveScopedSlots2(vm, ctx.slots);
        return activateCurrentInstance(instance, function() {
          return bindingFunc_1();
        });
      };
      return;
    } else if (isObject2(binding)) {
      if (isReactive(binding)) {
        binding = toRefs(binding);
      }
      vmStateManager.set(vm, "rawBindings", binding);
      var bindingObj_1 = binding;
      Object.keys(bindingObj_1).forEach(function(name) {
        var bindingValue = bindingObj_1[name];
        if (!isRef2(bindingValue)) {
          if (!isReactive(bindingValue)) {
            if (isFunction2(bindingValue)) {
              var copy_1 = bindingValue;
              bindingValue = bindingValue.bind(vm);
              Object.keys(copy_1).forEach(function(ele) {
                bindingValue[ele] = copy_1[ele];
              });
            } else if (!isObject2(bindingValue)) {
              bindingValue = ref2(bindingValue);
            } else if (hasReactiveArrayChild(bindingValue)) {
              customReactive(bindingValue);
            }
          } else if (isArray2(bindingValue)) {
            bindingValue = ref2(bindingValue);
          }
        }
        asVmProperty(vm, name, bindingValue);
      });
      return;
    }
    if (true) {
      assert(false, '"setup" must return a "Object" or a "Function", got "'.concat(Object.prototype.toString.call(binding).slice(8, -1), '"'));
    }
  }
  function customReactive(target2, seen) {
    if (seen === void 0) {
      seen = /* @__PURE__ */ new Set();
    }
    if (seen.has(target2))
      return;
    if (!isPlainObject2(target2) || isRef2(target2) || isReactive(target2) || isRaw(target2))
      return;
    var Vue4 = getVueConstructor();
    var defineReactive2 = Vue4.util.defineReactive;
    Object.keys(target2).forEach(function(k) {
      var val = target2[k];
      defineReactive2(target2, k, val);
      if (val) {
        seen.add(val);
        customReactive(val, seen);
      }
      return;
    });
  }
  function hasReactiveArrayChild(target2, visited) {
    if (visited === void 0) {
      visited = /* @__PURE__ */ new Map();
    }
    if (visited.has(target2)) {
      return visited.get(target2);
    }
    visited.set(target2, false);
    if (isArray2(target2) && isReactive(target2)) {
      visited.set(target2, true);
      return true;
    }
    if (!isPlainObject2(target2) || isRaw(target2) || isRef2(target2)) {
      return false;
    }
    return Object.keys(target2).some(function(x) {
      return hasReactiveArrayChild(target2[x], visited);
    });
  }
  function createSetupContext2(vm) {
    var ctx = { slots: {} };
    var propsPlain = [
      "root",
      "parent",
      "refs",
      "listeners",
      "isServer",
      "ssrContext"
    ];
    var methodReturnVoid = ["emit"];
    propsPlain.forEach(function(key) {
      var srcKey = "$".concat(key);
      proxy2(ctx, key, {
        get: function() {
          return vm[srcKey];
        },
        set: function() {
          warn2("Cannot assign to '".concat(key, "' because it is a read-only property"), vm);
        }
      });
    });
    updateVmAttrs(vm, ctx);
    methodReturnVoid.forEach(function(key) {
      var srcKey = "$".concat(key);
      proxy2(ctx, key, {
        get: function() {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var fn = vm[srcKey];
            fn.apply(vm, args);
          };
        }
      });
    });
    if (false) {
      ctx._vm = vm;
    }
    return ctx;
  }
}
function mergeData2(from, to) {
  if (!from)
    return to;
  if (!to)
    return from;
  var key;
  var toVal;
  var fromVal;
  var keys = hasSymbol2 ? Reflect.ownKeys(from) : Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    if (key === "__ob__")
      continue;
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn2(to, key)) {
      to[key] = fromVal;
    } else if (toVal !== fromVal && isPlainObject2(toVal) && !isRef2(toVal) && isPlainObject2(fromVal) && !isRef2(fromVal)) {
      mergeData2(fromVal, toVal);
    }
  }
  return to;
}
function install(Vue3) {
  if (isVueRegistered(Vue3)) {
    if (true) {
      warn2("[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.");
    }
    return;
  }
  if (true) {
    if (Vue3.version) {
      if (Vue3.version[0] !== "2" || Vue3.version[1] !== ".") {
        warn2("[vue-composition-api] only works with Vue 2, v".concat(Vue3.version, " found."));
      }
    } else {
      warn2("[vue-composition-api] no Vue version found");
    }
  }
  Vue3.config.optionMergeStrategies.setup = function(parent, child) {
    return function mergedSetupFn(props2, context) {
      return mergeData2(isFunction2(parent) ? parent(props2, context) || {} : void 0, isFunction2(child) ? child(props2, context) || {} : void 0);
    };
  };
  setVueConstructor(Vue3);
  mixin(Vue3);
}
var Plugin = {
  install: function(Vue3) {
    return install(Vue3);
  }
};
function defineComponent(options) {
  return options;
}
function defineAsyncComponent(source) {
  if (isFunction2(source)) {
    source = { loader: source };
  }
  var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, _b = source.suspensible, suspensible = _b === void 0 ? false : _b, userOnError = source.onError;
  if (suspensible) {
    warn2("The suspensiblbe option for async components is not supported in Vue2. It is ignored.");
  }
  var pendingRequest = null;
  var retries = 0;
  var retry = function() {
    retries++;
    pendingRequest = null;
    return load();
  };
  var load = function() {
    var thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(function(err) {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise(function(resolve, reject) {
          var userRetry = function() {
            return resolve(retry());
          };
          var userFail = function() {
            return reject(err);
          };
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(function(comp) {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (!comp) {
        warn2("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.");
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (comp && !isObject2(comp) && !isFunction2(comp)) {
        throw new Error("Invalid async component load result: ".concat(comp));
      }
      return comp;
    }));
  };
  return function() {
    var component = load();
    return {
      component,
      delay,
      timeout,
      error: errorComponent,
      loading: loadingComponent
    };
  };
}
if (typeof window !== "undefined" && window.Vue) {
  window.Vue.use(Plugin);
}

// node_modules/vue-demi/lib/index.mjs
function install2(_vue) {
  _vue = _vue || Vue;
  if (_vue && !_vue["__composition_api_installed__"])
    Vue.use(Plugin);
}
install2(Vue);
var isVue2 = true;
var isVue3 = false;
var Vue2 = Vue;
var version2 = Vue.version;
export {
  EffectScope2 as EffectScope,
  Vue,
  Vue2,
  computed,
  createApp,
  createRef,
  customRef,
  defineAsyncComponent,
  defineComponent,
  del2 as del,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  createElement2 as h,
  inject,
  install2 as install,
  isRaw,
  isReactive,
  isReadonly2 as isReadonly,
  isRef2 as isRef,
  isVue2,
  isVue3,
  markRaw,
  nextTick2 as nextTick,
  onActivated2 as onActivated,
  onBeforeMount2 as onBeforeMount,
  onBeforeUnmount2 as onBeforeUnmount,
  onBeforeUpdate2 as onBeforeUpdate,
  onDeactivated2 as onDeactivated,
  onErrorCaptured2 as onErrorCaptured,
  onMounted2 as onMounted,
  onScopeDispose,
  onServerPrefetch2 as onServerPrefetch,
  onUnmounted2 as onUnmounted,
  onUpdated2 as onUpdated,
  provide,
  proxyRefs,
  reactive,
  readonly,
  ref2 as ref,
  set$1 as set,
  shallowReactive2 as shallowReactive,
  shallowReadonly,
  shallowRef,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  useAttrs,
  useCSSModule,
  useCssModule,
  useSlots,
  version2 as version,
  warn$1 as warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect
};
/*!
 * Vue.js v2.7.7
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
//# sourceMappingURL=vue-demi.js.map
